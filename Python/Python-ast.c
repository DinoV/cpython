// File automatically generated by Parser/asdl_c.py.

#include "Python.h"
#include "pycore_ast.h"
#include "pycore_ast_state.h"     // struct ast_state
#include "pycore_ceval.h"         // _Py_EnterRecursiveCall()
#include "pycore_lock.h"          // _PyOnceFlag
#include "pycore_modsupport.h"    // _PyArg_NoPositional()
#include "pycore_pystate.h"       // _PyInterpreterState_GET()
#include "pycore_runtime.h"       // _Py_ID()
#include "pycore_setobject.h"     // _PySet_NextEntry()
#include "pycore_unionobject.h"   // _Py_union_type_or

#include <stddef.h>               // offsetof()


// Forward declaration
static int init_types(void *arg);

static struct ast_state*
get_ast_state(void)
{
    PyInterpreterState *interp = _PyInterpreterState_GET();
    struct ast_state *state = &interp->ast;
    assert(!state->finalized);
    if (_PyOnceFlag_CallOnce(&state->once, (_Py_once_fn_t *)&init_types, state) < 0) {
        return NULL;
    }
    return state;
}

void _PyAST_Fini(PyInterpreterState *interp)
{
    struct ast_state *state = &interp->ast;

    Py_CLEAR(state->AST_type);
    Py_CLEAR(state->Add_singleton);
    Py_CLEAR(state->Add_type);
    Py_CLEAR(state->And_singleton);
    Py_CLEAR(state->And_type);
    Py_CLEAR(state->AnnAssign_type);
    Py_CLEAR(state->Assert_type);
    Py_CLEAR(state->Assign_type);
    Py_CLEAR(state->AsyncFor_type);
    Py_CLEAR(state->AsyncFunctionDef_type);
    Py_CLEAR(state->AsyncWith_type);
    Py_CLEAR(state->Attribute_type);
    Py_CLEAR(state->AugAssign_type);
    Py_CLEAR(state->Await_type);
    Py_CLEAR(state->BinOp_type);
    Py_CLEAR(state->BitAnd_singleton);
    Py_CLEAR(state->BitAnd_type);
    Py_CLEAR(state->BitOr_singleton);
    Py_CLEAR(state->BitOr_type);
    Py_CLEAR(state->BitXor_singleton);
    Py_CLEAR(state->BitXor_type);
    Py_CLEAR(state->BoolOp_type);
    Py_CLEAR(state->Break_type);
    Py_CLEAR(state->Call_type);
    Py_CLEAR(state->ClassDef_type);
    Py_CLEAR(state->Compare_type);
    Py_CLEAR(state->Constant_type);
    Py_CLEAR(state->Continue_type);
    Py_CLEAR(state->Del_singleton);
    Py_CLEAR(state->Del_type);
    Py_CLEAR(state->Delete_type);
    Py_CLEAR(state->DictComp_type);
    Py_CLEAR(state->Dict_type);
    Py_CLEAR(state->Div_singleton);
    Py_CLEAR(state->Div_type);
    Py_CLEAR(state->Eq_singleton);
    Py_CLEAR(state->Eq_type);
    Py_CLEAR(state->ExceptHandler_type);
    Py_CLEAR(state->Expr_type);
    Py_CLEAR(state->Expression_type);
    Py_CLEAR(state->FloorDiv_singleton);
    Py_CLEAR(state->FloorDiv_type);
    Py_CLEAR(state->For_type);
    Py_CLEAR(state->FormattedValue_type);
    Py_CLEAR(state->FunctionDef_type);
    Py_CLEAR(state->FunctionType_type);
    Py_CLEAR(state->GeneratorExp_type);
    Py_CLEAR(state->Global_type);
    Py_CLEAR(state->GtE_singleton);
    Py_CLEAR(state->GtE_type);
    Py_CLEAR(state->Gt_singleton);
    Py_CLEAR(state->Gt_type);
    Py_CLEAR(state->IfExp_type);
    Py_CLEAR(state->If_type);
    Py_CLEAR(state->ImportFrom_type);
    Py_CLEAR(state->Import_type);
    Py_CLEAR(state->In_singleton);
    Py_CLEAR(state->In_type);
    Py_CLEAR(state->Interactive_type);
    Py_CLEAR(state->Interpolation_type);
    Py_CLEAR(state->Invert_singleton);
    Py_CLEAR(state->Invert_type);
    Py_CLEAR(state->IsNot_singleton);
    Py_CLEAR(state->IsNot_type);
    Py_CLEAR(state->Is_singleton);
    Py_CLEAR(state->Is_type);
    Py_CLEAR(state->JoinedStr_type);
    Py_CLEAR(state->LShift_singleton);
    Py_CLEAR(state->LShift_type);
    Py_CLEAR(state->Lambda_type);
    Py_CLEAR(state->ListComp_type);
    Py_CLEAR(state->List_type);
    Py_CLEAR(state->Load_singleton);
    Py_CLEAR(state->Load_type);
    Py_CLEAR(state->LtE_singleton);
    Py_CLEAR(state->LtE_type);
    Py_CLEAR(state->Lt_singleton);
    Py_CLEAR(state->Lt_type);
    Py_CLEAR(state->MatMult_singleton);
    Py_CLEAR(state->MatMult_type);
    Py_CLEAR(state->MatchAs_type);
    Py_CLEAR(state->MatchClass_type);
    Py_CLEAR(state->MatchMapping_type);
    Py_CLEAR(state->MatchOr_type);
    Py_CLEAR(state->MatchSequence_type);
    Py_CLEAR(state->MatchSingleton_type);
    Py_CLEAR(state->MatchStar_type);
    Py_CLEAR(state->MatchValue_type);
    Py_CLEAR(state->Match_type);
    Py_CLEAR(state->Mod_singleton);
    Py_CLEAR(state->Mod_type);
    Py_CLEAR(state->Module_type);
    Py_CLEAR(state->Mult_singleton);
    Py_CLEAR(state->Mult_type);
    Py_CLEAR(state->Name_type);
    Py_CLEAR(state->NamedExpr_type);
    Py_CLEAR(state->Nonlocal_type);
    Py_CLEAR(state->NotEq_singleton);
    Py_CLEAR(state->NotEq_type);
    Py_CLEAR(state->NotIn_singleton);
    Py_CLEAR(state->NotIn_type);
    Py_CLEAR(state->Not_singleton);
    Py_CLEAR(state->Not_type);
    Py_CLEAR(state->Or_singleton);
    Py_CLEAR(state->Or_type);
    Py_CLEAR(state->ParamSpec_type);
    Py_CLEAR(state->Pass_type);
    Py_CLEAR(state->Pow_singleton);
    Py_CLEAR(state->Pow_type);
    Py_CLEAR(state->RShift_singleton);
    Py_CLEAR(state->RShift_type);
    Py_CLEAR(state->Raise_type);
    Py_CLEAR(state->Return_type);
    Py_CLEAR(state->SetComp_type);
    Py_CLEAR(state->Set_type);
    Py_CLEAR(state->Slice_type);
    Py_CLEAR(state->Starred_type);
    Py_CLEAR(state->Store_singleton);
    Py_CLEAR(state->Store_type);
    Py_CLEAR(state->Sub_singleton);
    Py_CLEAR(state->Sub_type);
    Py_CLEAR(state->Subscript_type);
    Py_CLEAR(state->TemplateStr_type);
    Py_CLEAR(state->TryStar_type);
    Py_CLEAR(state->Try_type);
    Py_CLEAR(state->Tuple_type);
    Py_CLEAR(state->TypeAlias_type);
    Py_CLEAR(state->TypeIgnore_type);
    Py_CLEAR(state->TypeVarTuple_type);
    Py_CLEAR(state->TypeVar_type);
    Py_CLEAR(state->UAdd_singleton);
    Py_CLEAR(state->UAdd_type);
    Py_CLEAR(state->USub_singleton);
    Py_CLEAR(state->USub_type);
    Py_CLEAR(state->UnaryOp_type);
    Py_CLEAR(state->While_type);
    Py_CLEAR(state->With_type);
    Py_CLEAR(state->YieldFrom_type);
    Py_CLEAR(state->Yield_type);
    Py_CLEAR(state->_AST_type);
    Py_CLEAR(state->_Add_singleton);
    Py_CLEAR(state->_Add_type);
    Py_CLEAR(state->_And_singleton);
    Py_CLEAR(state->_And_type);
    Py_CLEAR(state->_AnnAssign_type);
    Py_CLEAR(state->_Assert_type);
    Py_CLEAR(state->_Assign_type);
    Py_CLEAR(state->_AsyncFor_type);
    Py_CLEAR(state->_AsyncFunctionDef_type);
    Py_CLEAR(state->_AsyncWith_type);
    Py_CLEAR(state->_Attribute_type);
    Py_CLEAR(state->_AugAssign_type);
    Py_CLEAR(state->_Await_type);
    Py_CLEAR(state->_BinOp_type);
    Py_CLEAR(state->_BitAnd_singleton);
    Py_CLEAR(state->_BitAnd_type);
    Py_CLEAR(state->_BitOr_singleton);
    Py_CLEAR(state->_BitOr_type);
    Py_CLEAR(state->_BitXor_singleton);
    Py_CLEAR(state->_BitXor_type);
    Py_CLEAR(state->_BoolOp_type);
    Py_CLEAR(state->_Break_type);
    Py_CLEAR(state->_Call_type);
    Py_CLEAR(state->_ClassDef_type);
    Py_CLEAR(state->_Compare_type);
    Py_CLEAR(state->_Constant_type);
    Py_CLEAR(state->_Continue_type);
    Py_CLEAR(state->_Del_singleton);
    Py_CLEAR(state->_Del_type);
    Py_CLEAR(state->_Delete_type);
    Py_CLEAR(state->_DictComp_type);
    Py_CLEAR(state->_Dict_type);
    Py_CLEAR(state->_Div_singleton);
    Py_CLEAR(state->_Div_type);
    Py_CLEAR(state->_Eq_singleton);
    Py_CLEAR(state->_Eq_type);
    Py_CLEAR(state->_ExceptHandler_type);
    Py_CLEAR(state->_Expr_type);
    Py_CLEAR(state->_Expression_type);
    Py_CLEAR(state->_FloorDiv_singleton);
    Py_CLEAR(state->_FloorDiv_type);
    Py_CLEAR(state->_For_type);
    Py_CLEAR(state->_FormattedValue_type);
    Py_CLEAR(state->_FunctionDef_type);
    Py_CLEAR(state->_FunctionType_type);
    Py_CLEAR(state->_GeneratorExp_type);
    Py_CLEAR(state->_Global_type);
    Py_CLEAR(state->_GtE_singleton);
    Py_CLEAR(state->_GtE_type);
    Py_CLEAR(state->_Gt_singleton);
    Py_CLEAR(state->_Gt_type);
    Py_CLEAR(state->_IfExp_type);
    Py_CLEAR(state->_If_type);
    Py_CLEAR(state->_ImportFrom_type);
    Py_CLEAR(state->_Import_type);
    Py_CLEAR(state->_In_singleton);
    Py_CLEAR(state->_In_type);
    Py_CLEAR(state->_Interactive_type);
    Py_CLEAR(state->_Interpolation_type);
    Py_CLEAR(state->_Invert_singleton);
    Py_CLEAR(state->_Invert_type);
    Py_CLEAR(state->_IsNot_singleton);
    Py_CLEAR(state->_IsNot_type);
    Py_CLEAR(state->_Is_singleton);
    Py_CLEAR(state->_Is_type);
    Py_CLEAR(state->_JoinedStr_type);
    Py_CLEAR(state->_LShift_singleton);
    Py_CLEAR(state->_LShift_type);
    Py_CLEAR(state->_Lambda_type);
    Py_CLEAR(state->_ListComp_type);
    Py_CLEAR(state->_List_type);
    Py_CLEAR(state->_Load_singleton);
    Py_CLEAR(state->_Load_type);
    Py_CLEAR(state->_LtE_singleton);
    Py_CLEAR(state->_LtE_type);
    Py_CLEAR(state->_Lt_singleton);
    Py_CLEAR(state->_Lt_type);
    Py_CLEAR(state->_MatMult_singleton);
    Py_CLEAR(state->_MatMult_type);
    Py_CLEAR(state->_MatchAs_type);
    Py_CLEAR(state->_MatchClass_type);
    Py_CLEAR(state->_MatchMapping_type);
    Py_CLEAR(state->_MatchOr_type);
    Py_CLEAR(state->_MatchSequence_type);
    Py_CLEAR(state->_MatchSingleton_type);
    Py_CLEAR(state->_MatchStar_type);
    Py_CLEAR(state->_MatchValue_type);
    Py_CLEAR(state->_Match_type);
    Py_CLEAR(state->_Mod_singleton);
    Py_CLEAR(state->_Mod_type);
    Py_CLEAR(state->_Module_type);
    Py_CLEAR(state->_Mult_singleton);
    Py_CLEAR(state->_Mult_type);
    Py_CLEAR(state->_Name_type);
    Py_CLEAR(state->_NamedExpr_type);
    Py_CLEAR(state->_Nonlocal_type);
    Py_CLEAR(state->_NotEq_singleton);
    Py_CLEAR(state->_NotEq_type);
    Py_CLEAR(state->_NotIn_singleton);
    Py_CLEAR(state->_NotIn_type);
    Py_CLEAR(state->_Not_singleton);
    Py_CLEAR(state->_Not_type);
    Py_CLEAR(state->_Or_singleton);
    Py_CLEAR(state->_Or_type);
    Py_CLEAR(state->_ParamSpec_type);
    Py_CLEAR(state->_Pass_type);
    Py_CLEAR(state->_Pow_singleton);
    Py_CLEAR(state->_Pow_type);
    Py_CLEAR(state->_RShift_singleton);
    Py_CLEAR(state->_RShift_type);
    Py_CLEAR(state->_Raise_type);
    Py_CLEAR(state->_Return_type);
    Py_CLEAR(state->_SetComp_type);
    Py_CLEAR(state->_Set_type);
    Py_CLEAR(state->_Slice_type);
    Py_CLEAR(state->_Starred_type);
    Py_CLEAR(state->_Store_singleton);
    Py_CLEAR(state->_Store_type);
    Py_CLEAR(state->_Sub_singleton);
    Py_CLEAR(state->_Sub_type);
    Py_CLEAR(state->_Subscript_type);
    Py_CLEAR(state->_TemplateStr_type);
    Py_CLEAR(state->_TryStar_type);
    Py_CLEAR(state->_Try_type);
    Py_CLEAR(state->_Tuple_type);
    Py_CLEAR(state->_TypeAlias_type);
    Py_CLEAR(state->_TypeIgnore_type);
    Py_CLEAR(state->_TypeVarTuple_type);
    Py_CLEAR(state->_TypeVar_type);
    Py_CLEAR(state->_UAdd_singleton);
    Py_CLEAR(state->_UAdd_type);
    Py_CLEAR(state->_USub_singleton);
    Py_CLEAR(state->_USub_type);
    Py_CLEAR(state->_UnaryOp_type);
    Py_CLEAR(state->_While_type);
    Py_CLEAR(state->_With_type);
    Py_CLEAR(state->_YieldFrom_type);
    Py_CLEAR(state->_Yield_type);
    Py_CLEAR(state->__dict__);
    Py_CLEAR(state->__doc__);
    Py_CLEAR(state->__match_args__);
    Py_CLEAR(state->__module__);
    Py_CLEAR(state->_alias_seq_type);
    Py_CLEAR(state->_alias_type);
    Py_CLEAR(state->_arg_seq_type);
    Py_CLEAR(state->_arg_type);
    Py_CLEAR(state->_arguments_seq_type);
    Py_CLEAR(state->_arguments_type);
    Py_CLEAR(state->_attributes);
    Py_CLEAR(state->_boolop_seq_type);
    Py_CLEAR(state->_boolop_type);
    Py_CLEAR(state->_cmpop_seq_type);
    Py_CLEAR(state->_cmpop_type);
    Py_CLEAR(state->_comprehension_seq_type);
    Py_CLEAR(state->_comprehension_type);
    Py_CLEAR(state->_excepthandler_seq_type);
    Py_CLEAR(state->_excepthandler_type);
    Py_CLEAR(state->_expr_context_seq_type);
    Py_CLEAR(state->_expr_context_type);
    Py_CLEAR(state->_expr_seq_type);
    Py_CLEAR(state->_expr_type);
    Py_CLEAR(state->_fields);
    Py_CLEAR(state->_identifier_seq_type);
    Py_CLEAR(state->_int_seq_type);
    Py_CLEAR(state->_keyword_seq_type);
    Py_CLEAR(state->_keyword_type);
    Py_CLEAR(state->_match_case_seq_type);
    Py_CLEAR(state->_match_case_type);
    Py_CLEAR(state->_mod_seq_type);
    Py_CLEAR(state->_mod_type);
    Py_CLEAR(state->_operator_seq_type);
    Py_CLEAR(state->_operator_type);
    Py_CLEAR(state->_pattern_seq_type);
    Py_CLEAR(state->_pattern_type);
    Py_CLEAR(state->_stmt_seq_type);
    Py_CLEAR(state->_stmt_type);
    Py_CLEAR(state->_type_ignore_seq_type);
    Py_CLEAR(state->_type_ignore_type);
    Py_CLEAR(state->_type_param_seq_type);
    Py_CLEAR(state->_type_param_type);
    Py_CLEAR(state->_unaryop_seq_type);
    Py_CLEAR(state->_unaryop_type);
    Py_CLEAR(state->_withitem_seq_type);
    Py_CLEAR(state->_withitem_type);
    Py_CLEAR(state->alias_type);
    Py_CLEAR(state->annotation);
    Py_CLEAR(state->arg);
    Py_CLEAR(state->arg_type);
    Py_CLEAR(state->args);
    Py_CLEAR(state->argtypes);
    Py_CLEAR(state->arguments_type);
    Py_CLEAR(state->asname);
    Py_CLEAR(state->ast);
    Py_CLEAR(state->attr);
    Py_CLEAR(state->bases);
    Py_CLEAR(state->body);
    Py_CLEAR(state->boolop_type);
    Py_CLEAR(state->bound);
    Py_CLEAR(state->cases);
    Py_CLEAR(state->cause);
    Py_CLEAR(state->cls);
    Py_CLEAR(state->cmpop_type);
    Py_CLEAR(state->col_offset);
    Py_CLEAR(state->comparators);
    Py_CLEAR(state->comprehension_type);
    Py_CLEAR(state->context_expr);
    Py_CLEAR(state->conversion);
    Py_CLEAR(state->ctx);
    Py_CLEAR(state->decorator_list);
    Py_CLEAR(state->default_value);
    Py_CLEAR(state->defaults);
    Py_CLEAR(state->elt);
    Py_CLEAR(state->elts);
    Py_CLEAR(state->end_col_offset);
    Py_CLEAR(state->end_lineno);
    Py_CLEAR(state->exc);
    Py_CLEAR(state->excepthandler_type);
    Py_CLEAR(state->expr_context_type);
    Py_CLEAR(state->expr_type);
    Py_CLEAR(state->finalbody);
    Py_CLEAR(state->format_spec);
    Py_CLEAR(state->func);
    Py_CLEAR(state->generators);
    Py_CLEAR(state->guard);
    Py_CLEAR(state->handlers);
    Py_CLEAR(state->id);
    Py_CLEAR(state->ifs);
    Py_CLEAR(state->is_async);
    Py_CLEAR(state->items);
    Py_CLEAR(state->iter);
    Py_CLEAR(state->key);
    Py_CLEAR(state->keys);
    Py_CLEAR(state->keyword_type);
    Py_CLEAR(state->keywords);
    Py_CLEAR(state->kind);
    Py_CLEAR(state->kw_defaults);
    Py_CLEAR(state->kwarg);
    Py_CLEAR(state->kwd_attrs);
    Py_CLEAR(state->kwd_patterns);
    Py_CLEAR(state->kwonlyargs);
    Py_CLEAR(state->left);
    Py_CLEAR(state->level);
    Py_CLEAR(state->lineno);
    Py_CLEAR(state->lower);
    Py_CLEAR(state->match_case_type);
    Py_CLEAR(state->mod_type);
    Py_CLEAR(state->module);
    Py_CLEAR(state->msg);
    Py_CLEAR(state->name);
    Py_CLEAR(state->names);
    Py_CLEAR(state->op);
    Py_CLEAR(state->operand);
    Py_CLEAR(state->operator_type);
    Py_CLEAR(state->ops);
    Py_CLEAR(state->optional_vars);
    Py_CLEAR(state->orelse);
    Py_CLEAR(state->pattern);
    Py_CLEAR(state->pattern_type);
    Py_CLEAR(state->patterns);
    Py_CLEAR(state->posonlyargs);
    Py_CLEAR(state->rest);
    Py_CLEAR(state->returns);
    Py_CLEAR(state->right);
    Py_CLEAR(state->simple);
    Py_CLEAR(state->slice);
    Py_CLEAR(state->step);
    Py_CLEAR(state->stmt_type);
    Py_CLEAR(state->str);
    Py_CLEAR(state->subject);
    Py_CLEAR(state->tag);
    Py_CLEAR(state->target);
    Py_CLEAR(state->targets);
    Py_CLEAR(state->test);
    Py_CLEAR(state->type);
    Py_CLEAR(state->type_comment);
    Py_CLEAR(state->type_ignore_type);
    Py_CLEAR(state->type_ignores);
    Py_CLEAR(state->type_param_type);
    Py_CLEAR(state->type_params);
    Py_CLEAR(state->unaryop_type);
    Py_CLEAR(state->upper);
    Py_CLEAR(state->value);
    Py_CLEAR(state->values);
    Py_CLEAR(state->vararg);
    Py_CLEAR(state->withitem_type);

    state->finalized = 1;
    state->once = (_PyOnceFlag){0};
}

static int init_identifiers(struct ast_state *state)
{
    if ((state->__dict__ = PyUnicode_InternFromString("__dict__")) == NULL) return -1;
    if ((state->__doc__ = PyUnicode_InternFromString("__doc__")) == NULL) return -1;
    if ((state->__match_args__ = PyUnicode_InternFromString("__match_args__")) == NULL) return -1;
    if ((state->__module__ = PyUnicode_InternFromString("__module__")) == NULL) return -1;
    if ((state->_attributes = PyUnicode_InternFromString("_attributes")) == NULL) return -1;
    if ((state->_fields = PyUnicode_InternFromString("_fields")) == NULL) return -1;
    if ((state->annotation = PyUnicode_InternFromString("annotation")) == NULL) return -1;
    if ((state->arg = PyUnicode_InternFromString("arg")) == NULL) return -1;
    if ((state->args = PyUnicode_InternFromString("args")) == NULL) return -1;
    if ((state->argtypes = PyUnicode_InternFromString("argtypes")) == NULL) return -1;
    if ((state->asname = PyUnicode_InternFromString("asname")) == NULL) return -1;
    if ((state->ast = PyUnicode_InternFromString("ast")) == NULL) return -1;
    if ((state->attr = PyUnicode_InternFromString("attr")) == NULL) return -1;
    if ((state->bases = PyUnicode_InternFromString("bases")) == NULL) return -1;
    if ((state->body = PyUnicode_InternFromString("body")) == NULL) return -1;
    if ((state->bound = PyUnicode_InternFromString("bound")) == NULL) return -1;
    if ((state->cases = PyUnicode_InternFromString("cases")) == NULL) return -1;
    if ((state->cause = PyUnicode_InternFromString("cause")) == NULL) return -1;
    if ((state->cls = PyUnicode_InternFromString("cls")) == NULL) return -1;
    if ((state->col_offset = PyUnicode_InternFromString("col_offset")) == NULL) return -1;
    if ((state->comparators = PyUnicode_InternFromString("comparators")) == NULL) return -1;
    if ((state->context_expr = PyUnicode_InternFromString("context_expr")) == NULL) return -1;
    if ((state->conversion = PyUnicode_InternFromString("conversion")) == NULL) return -1;
    if ((state->ctx = PyUnicode_InternFromString("ctx")) == NULL) return -1;
    if ((state->decorator_list = PyUnicode_InternFromString("decorator_list")) == NULL) return -1;
    if ((state->default_value = PyUnicode_InternFromString("default_value")) == NULL) return -1;
    if ((state->defaults = PyUnicode_InternFromString("defaults")) == NULL) return -1;
    if ((state->elt = PyUnicode_InternFromString("elt")) == NULL) return -1;
    if ((state->elts = PyUnicode_InternFromString("elts")) == NULL) return -1;
    if ((state->end_col_offset = PyUnicode_InternFromString("end_col_offset")) == NULL) return -1;
    if ((state->end_lineno = PyUnicode_InternFromString("end_lineno")) == NULL) return -1;
    if ((state->exc = PyUnicode_InternFromString("exc")) == NULL) return -1;
    if ((state->finalbody = PyUnicode_InternFromString("finalbody")) == NULL) return -1;
    if ((state->format_spec = PyUnicode_InternFromString("format_spec")) == NULL) return -1;
    if ((state->func = PyUnicode_InternFromString("func")) == NULL) return -1;
    if ((state->generators = PyUnicode_InternFromString("generators")) == NULL) return -1;
    if ((state->guard = PyUnicode_InternFromString("guard")) == NULL) return -1;
    if ((state->handlers = PyUnicode_InternFromString("handlers")) == NULL) return -1;
    if ((state->id = PyUnicode_InternFromString("id")) == NULL) return -1;
    if ((state->ifs = PyUnicode_InternFromString("ifs")) == NULL) return -1;
    if ((state->is_async = PyUnicode_InternFromString("is_async")) == NULL) return -1;
    if ((state->items = PyUnicode_InternFromString("items")) == NULL) return -1;
    if ((state->iter = PyUnicode_InternFromString("iter")) == NULL) return -1;
    if ((state->key = PyUnicode_InternFromString("key")) == NULL) return -1;
    if ((state->keys = PyUnicode_InternFromString("keys")) == NULL) return -1;
    if ((state->keywords = PyUnicode_InternFromString("keywords")) == NULL) return -1;
    if ((state->kind = PyUnicode_InternFromString("kind")) == NULL) return -1;
    if ((state->kw_defaults = PyUnicode_InternFromString("kw_defaults")) == NULL) return -1;
    if ((state->kwarg = PyUnicode_InternFromString("kwarg")) == NULL) return -1;
    if ((state->kwd_attrs = PyUnicode_InternFromString("kwd_attrs")) == NULL) return -1;
    if ((state->kwd_patterns = PyUnicode_InternFromString("kwd_patterns")) == NULL) return -1;
    if ((state->kwonlyargs = PyUnicode_InternFromString("kwonlyargs")) == NULL) return -1;
    if ((state->left = PyUnicode_InternFromString("left")) == NULL) return -1;
    if ((state->level = PyUnicode_InternFromString("level")) == NULL) return -1;
    if ((state->lineno = PyUnicode_InternFromString("lineno")) == NULL) return -1;
    if ((state->lower = PyUnicode_InternFromString("lower")) == NULL) return -1;
    if ((state->module = PyUnicode_InternFromString("module")) == NULL) return -1;
    if ((state->msg = PyUnicode_InternFromString("msg")) == NULL) return -1;
    if ((state->name = PyUnicode_InternFromString("name")) == NULL) return -1;
    if ((state->names = PyUnicode_InternFromString("names")) == NULL) return -1;
    if ((state->op = PyUnicode_InternFromString("op")) == NULL) return -1;
    if ((state->operand = PyUnicode_InternFromString("operand")) == NULL) return -1;
    if ((state->ops = PyUnicode_InternFromString("ops")) == NULL) return -1;
    if ((state->optional_vars = PyUnicode_InternFromString("optional_vars")) == NULL) return -1;
    if ((state->orelse = PyUnicode_InternFromString("orelse")) == NULL) return -1;
    if ((state->pattern = PyUnicode_InternFromString("pattern")) == NULL) return -1;
    if ((state->patterns = PyUnicode_InternFromString("patterns")) == NULL) return -1;
    if ((state->posonlyargs = PyUnicode_InternFromString("posonlyargs")) == NULL) return -1;
    if ((state->rest = PyUnicode_InternFromString("rest")) == NULL) return -1;
    if ((state->returns = PyUnicode_InternFromString("returns")) == NULL) return -1;
    if ((state->right = PyUnicode_InternFromString("right")) == NULL) return -1;
    if ((state->simple = PyUnicode_InternFromString("simple")) == NULL) return -1;
    if ((state->slice = PyUnicode_InternFromString("slice")) == NULL) return -1;
    if ((state->step = PyUnicode_InternFromString("step")) == NULL) return -1;
    if ((state->str = PyUnicode_InternFromString("str")) == NULL) return -1;
    if ((state->subject = PyUnicode_InternFromString("subject")) == NULL) return -1;
    if ((state->tag = PyUnicode_InternFromString("tag")) == NULL) return -1;
    if ((state->target = PyUnicode_InternFromString("target")) == NULL) return -1;
    if ((state->targets = PyUnicode_InternFromString("targets")) == NULL) return -1;
    if ((state->test = PyUnicode_InternFromString("test")) == NULL) return -1;
    if ((state->type = PyUnicode_InternFromString("type")) == NULL) return -1;
    if ((state->type_comment = PyUnicode_InternFromString("type_comment")) == NULL) return -1;
    if ((state->type_ignores = PyUnicode_InternFromString("type_ignores")) == NULL) return -1;
    if ((state->type_params = PyUnicode_InternFromString("type_params")) == NULL) return -1;
    if ((state->upper = PyUnicode_InternFromString("upper")) == NULL) return -1;
    if ((state->value = PyUnicode_InternFromString("value")) == NULL) return -1;
    if ((state->values = PyUnicode_InternFromString("values")) == NULL) return -1;
    if ((state->vararg = PyUnicode_InternFromString("vararg")) == NULL) return -1;
    return 0;
};

GENERATE_ASDL_SEQ_CONSTRUCTOR(mod, mod_ty)
GENERATE_ASDL_SEQ_CONSTRUCTOR(stmt, stmt_ty)
GENERATE_ASDL_SEQ_CONSTRUCTOR(expr, expr_ty)
GENERATE_ASDL_SEQ_CONSTRUCTOR(comprehension, comprehension_ty)
GENERATE_ASDL_SEQ_CONSTRUCTOR(excepthandler, excepthandler_ty)
GENERATE_ASDL_SEQ_CONSTRUCTOR(arguments, arguments_ty)
GENERATE_ASDL_SEQ_CONSTRUCTOR(arg, arg_ty)
GENERATE_ASDL_SEQ_CONSTRUCTOR(keyword, keyword_ty)
GENERATE_ASDL_SEQ_CONSTRUCTOR(alias, alias_ty)
GENERATE_ASDL_SEQ_CONSTRUCTOR(withitem, withitem_ty)
GENERATE_ASDL_SEQ_CONSTRUCTOR(match_case, match_case_ty)
GENERATE_ASDL_SEQ_CONSTRUCTOR(pattern, pattern_ty)
GENERATE_ASDL_SEQ_CONSTRUCTOR(type_ignore, type_ignore_ty)
GENERATE_ASDL_SEQ_CONSTRUCTOR(type_param, type_param_ty)

static PyObject* ast2obj_mod(struct ast_state *state, void*);
static const char * const Module_fields[]={
    "body",
    "type_ignores",
};
static const char * const Interactive_fields[]={
    "body",
};
static const char * const Expression_fields[]={
    "body",
};
static const char * const FunctionType_fields[]={
    "argtypes",
    "returns",
};
static const char * const stmt_attributes[] = {
    "lineno",
    "col_offset",
    "end_lineno",
    "end_col_offset",
};
static PyObject* ast2obj_stmt(struct ast_state *state, void*);
static const char * const FunctionDef_fields[]={
    "name",
    "args",
    "body",
    "decorator_list",
    "returns",
    "type_comment",
    "type_params",
};
static const char * const AsyncFunctionDef_fields[]={
    "name",
    "args",
    "body",
    "decorator_list",
    "returns",
    "type_comment",
    "type_params",
};
static const char * const ClassDef_fields[]={
    "name",
    "bases",
    "keywords",
    "body",
    "decorator_list",
    "type_params",
};
static const char * const Return_fields[]={
    "value",
};
static const char * const Delete_fields[]={
    "targets",
};
static const char * const Assign_fields[]={
    "targets",
    "value",
    "type_comment",
};
static const char * const TypeAlias_fields[]={
    "name",
    "type_params",
    "value",
};
static const char * const AugAssign_fields[]={
    "target",
    "op",
    "value",
};
static const char * const AnnAssign_fields[]={
    "target",
    "annotation",
    "value",
    "simple",
};
static const char * const For_fields[]={
    "target",
    "iter",
    "body",
    "orelse",
    "type_comment",
};
static const char * const AsyncFor_fields[]={
    "target",
    "iter",
    "body",
    "orelse",
    "type_comment",
};
static const char * const While_fields[]={
    "test",
    "body",
    "orelse",
};
static const char * const If_fields[]={
    "test",
    "body",
    "orelse",
};
static const char * const With_fields[]={
    "items",
    "body",
    "type_comment",
};
static const char * const AsyncWith_fields[]={
    "items",
    "body",
    "type_comment",
};
static const char * const Match_fields[]={
    "subject",
    "cases",
};
static const char * const Raise_fields[]={
    "exc",
    "cause",
};
static const char * const Try_fields[]={
    "body",
    "handlers",
    "orelse",
    "finalbody",
};
static const char * const TryStar_fields[]={
    "body",
    "handlers",
    "orelse",
    "finalbody",
};
static const char * const Assert_fields[]={
    "test",
    "msg",
};
static const char * const Import_fields[]={
    "names",
};
static const char * const ImportFrom_fields[]={
    "module",
    "names",
    "level",
};
static const char * const Global_fields[]={
    "names",
};
static const char * const Nonlocal_fields[]={
    "names",
};
static const char * const Expr_fields[]={
    "value",
};
static const char * const expr_attributes[] = {
    "lineno",
    "col_offset",
    "end_lineno",
    "end_col_offset",
};
static PyObject* ast2obj_expr(struct ast_state *state, void*);
static const char * const BoolOp_fields[]={
    "op",
    "values",
};
static const char * const NamedExpr_fields[]={
    "target",
    "value",
};
static const char * const BinOp_fields[]={
    "left",
    "op",
    "right",
};
static const char * const UnaryOp_fields[]={
    "op",
    "operand",
};
static const char * const Lambda_fields[]={
    "args",
    "body",
};
static const char * const IfExp_fields[]={
    "test",
    "body",
    "orelse",
};
static const char * const Dict_fields[]={
    "keys",
    "values",
};
static const char * const Set_fields[]={
    "elts",
};
static const char * const ListComp_fields[]={
    "elt",
    "generators",
};
static const char * const SetComp_fields[]={
    "elt",
    "generators",
};
static const char * const DictComp_fields[]={
    "key",
    "value",
    "generators",
};
static const char * const GeneratorExp_fields[]={
    "elt",
    "generators",
};
static const char * const Await_fields[]={
    "value",
};
static const char * const Yield_fields[]={
    "value",
};
static const char * const YieldFrom_fields[]={
    "value",
};
static const char * const Compare_fields[]={
    "left",
    "ops",
    "comparators",
};
static const char * const Call_fields[]={
    "func",
    "args",
    "keywords",
};
static const char * const FormattedValue_fields[]={
    "value",
    "conversion",
    "format_spec",
};
static const char * const Interpolation_fields[]={
    "value",
    "str",
    "conversion",
    "format_spec",
};
static const char * const JoinedStr_fields[]={
    "values",
};
static const char * const TemplateStr_fields[]={
    "values",
};
static const char * const Constant_fields[]={
    "value",
    "kind",
};
static const char * const Attribute_fields[]={
    "value",
    "attr",
    "ctx",
};
static const char * const Subscript_fields[]={
    "value",
    "slice",
    "ctx",
};
static const char * const Starred_fields[]={
    "value",
    "ctx",
};
static const char * const Name_fields[]={
    "id",
    "ctx",
};
static const char * const List_fields[]={
    "elts",
    "ctx",
};
static const char * const Tuple_fields[]={
    "elts",
    "ctx",
};
static const char * const Slice_fields[]={
    "lower",
    "upper",
    "step",
};
static PyObject* ast2obj_expr_context(struct ast_state *state, expr_context_ty);
static PyObject* ast2obj_boolop(struct ast_state *state, boolop_ty);
static PyObject* ast2obj_operator(struct ast_state *state, operator_ty);
static PyObject* ast2obj_unaryop(struct ast_state *state, unaryop_ty);
static PyObject* ast2obj_cmpop(struct ast_state *state, cmpop_ty);
static PyObject* ast2obj_comprehension(struct ast_state *state, void*);
static const char * const comprehension_fields[]={
    "target",
    "iter",
    "ifs",
    "is_async",
};
static const char * const excepthandler_attributes[] = {
    "lineno",
    "col_offset",
    "end_lineno",
    "end_col_offset",
};
static PyObject* ast2obj_excepthandler(struct ast_state *state, void*);
static const char * const ExceptHandler_fields[]={
    "type",
    "name",
    "body",
};
static PyObject* ast2obj_arguments(struct ast_state *state, void*);
static const char * const arguments_fields[]={
    "posonlyargs",
    "args",
    "vararg",
    "kwonlyargs",
    "kw_defaults",
    "kwarg",
    "defaults",
};
static PyObject* ast2obj_arg(struct ast_state *state, void*);
static const char * const arg_attributes[] = {
    "lineno",
    "col_offset",
    "end_lineno",
    "end_col_offset",
};
static const char * const arg_fields[]={
    "arg",
    "annotation",
    "type_comment",
};
static PyObject* ast2obj_keyword(struct ast_state *state, void*);
static const char * const keyword_attributes[] = {
    "lineno",
    "col_offset",
    "end_lineno",
    "end_col_offset",
};
static const char * const keyword_fields[]={
    "arg",
    "value",
};
static PyObject* ast2obj_alias(struct ast_state *state, void*);
static const char * const alias_attributes[] = {
    "lineno",
    "col_offset",
    "end_lineno",
    "end_col_offset",
};
static const char * const alias_fields[]={
    "name",
    "asname",
};
static PyObject* ast2obj_withitem(struct ast_state *state, void*);
static const char * const withitem_fields[]={
    "context_expr",
    "optional_vars",
};
static PyObject* ast2obj_match_case(struct ast_state *state, void*);
static const char * const match_case_fields[]={
    "pattern",
    "guard",
    "body",
};
static const char * const pattern_attributes[] = {
    "lineno",
    "col_offset",
    "end_lineno",
    "end_col_offset",
};
static PyObject* ast2obj_pattern(struct ast_state *state, void*);
static const char * const MatchValue_fields[]={
    "value",
};
static const char * const MatchSingleton_fields[]={
    "value",
};
static const char * const MatchSequence_fields[]={
    "patterns",
};
static const char * const MatchMapping_fields[]={
    "keys",
    "patterns",
    "rest",
};
static const char * const MatchClass_fields[]={
    "cls",
    "patterns",
    "kwd_attrs",
    "kwd_patterns",
};
static const char * const MatchStar_fields[]={
    "name",
};
static const char * const MatchAs_fields[]={
    "pattern",
    "name",
};
static const char * const MatchOr_fields[]={
    "patterns",
};
static PyObject* ast2obj_type_ignore(struct ast_state *state, void*);
static const char * const TypeIgnore_fields[]={
    "lineno",
    "tag",
};
static const char * const type_param_attributes[] = {
    "lineno",
    "col_offset",
    "end_lineno",
    "end_col_offset",
};
static PyObject* ast2obj_type_param(struct ast_state *state, void*);
static const char * const TypeVar_fields[]={
    "name",
    "bound",
    "default_value",
};
static const char * const ParamSpec_fields[]={
    "name",
    "default_value",
};
static const char * const TypeVarTuple_fields[]={
    "name",
    "default_value",
};


static int
add_ast_annotations(struct ast_state *state)
{
    bool cond;
    PyObject *Module_annotations = PyDict_New();
    if (!Module_annotations) return 0;
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Module_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Module_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Module_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->type_ignore_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Module_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Module_annotations, "type_ignores", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Module_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Module_type, "_field_types",
                                  Module_annotations) == 0;
    if (!cond) {
        Py_DECREF(Module_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Module_type, "__annotations__",
                                  Module_annotations) == 0;
    if (!cond) {
        Py_DECREF(Module_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Module_type, "_field_types",
                                  Module_annotations) == 0;
    if (!cond) {
        Py_DECREF(Module_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Module_type, "__annotations__",
                                  Module_annotations) == 0;
    if (!cond) {
        Py_DECREF(Module_annotations);
        return 0;
    }
    Py_DECREF(Module_annotations);
    PyObject *Interactive_annotations = PyDict_New();
    if (!Interactive_annotations) return 0;
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Interactive_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Interactive_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Interactive_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Interactive_type, "_field_types",
                                  Interactive_annotations) == 0;
    if (!cond) {
        Py_DECREF(Interactive_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Interactive_type, "__annotations__",
                                  Interactive_annotations) == 0;
    if (!cond) {
        Py_DECREF(Interactive_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Interactive_type, "_field_types",
                                  Interactive_annotations) == 0;
    if (!cond) {
        Py_DECREF(Interactive_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Interactive_type, "__annotations__",
                                  Interactive_annotations) == 0;
    if (!cond) {
        Py_DECREF(Interactive_annotations);
        return 0;
    }
    Py_DECREF(Interactive_annotations);
    PyObject *Expression_annotations = PyDict_New();
    if (!Expression_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Expression_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Expression_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Expression_type, "_field_types",
                                  Expression_annotations) == 0;
    if (!cond) {
        Py_DECREF(Expression_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Expression_type, "__annotations__",
                                  Expression_annotations) == 0;
    if (!cond) {
        Py_DECREF(Expression_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Expression_type, "_field_types",
                                  Expression_annotations) == 0;
    if (!cond) {
        Py_DECREF(Expression_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Expression_type, "__annotations__",
                                  Expression_annotations) == 0;
    if (!cond) {
        Py_DECREF(Expression_annotations);
        return 0;
    }
    Py_DECREF(Expression_annotations);
    PyObject *FunctionType_annotations = PyDict_New();
    if (!FunctionType_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(FunctionType_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(FunctionType_annotations, "argtypes", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(FunctionType_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(FunctionType_annotations, "returns", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(FunctionType_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->FunctionType_type, "_field_types",
                                  FunctionType_annotations) == 0;
    if (!cond) {
        Py_DECREF(FunctionType_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->FunctionType_type, "__annotations__",
                                  FunctionType_annotations) == 0;
    if (!cond) {
        Py_DECREF(FunctionType_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_FunctionType_type, "_field_types",
                                  FunctionType_annotations) == 0;
    if (!cond) {
        Py_DECREF(FunctionType_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_FunctionType_type, "__annotations__",
                                  FunctionType_annotations) == 0;
    if (!cond) {
        Py_DECREF(FunctionType_annotations);
        return 0;
    }
    Py_DECREF(FunctionType_annotations);
    PyObject *FunctionDef_annotations = PyDict_New();
    if (!FunctionDef_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(FunctionDef_annotations, "name", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(FunctionDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->arguments_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(FunctionDef_annotations, "args", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(FunctionDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(FunctionDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(FunctionDef_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(FunctionDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(FunctionDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(FunctionDef_annotations, "decorator_list",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(FunctionDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(FunctionDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(FunctionDef_annotations, "returns", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(FunctionDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(FunctionDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(FunctionDef_annotations, "type_comment",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(FunctionDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->type_param_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(FunctionDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(FunctionDef_annotations, "type_params",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(FunctionDef_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->FunctionDef_type, "_field_types",
                                  FunctionDef_annotations) == 0;
    if (!cond) {
        Py_DECREF(FunctionDef_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->FunctionDef_type, "__annotations__",
                                  FunctionDef_annotations) == 0;
    if (!cond) {
        Py_DECREF(FunctionDef_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_FunctionDef_type, "_field_types",
                                  FunctionDef_annotations) == 0;
    if (!cond) {
        Py_DECREF(FunctionDef_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_FunctionDef_type, "__annotations__",
                                  FunctionDef_annotations) == 0;
    if (!cond) {
        Py_DECREF(FunctionDef_annotations);
        return 0;
    }
    Py_DECREF(FunctionDef_annotations);
    PyObject *AsyncFunctionDef_annotations = PyDict_New();
    if (!AsyncFunctionDef_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(AsyncFunctionDef_annotations, "name", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncFunctionDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->arguments_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(AsyncFunctionDef_annotations, "args", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncFunctionDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(AsyncFunctionDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(AsyncFunctionDef_annotations, "body", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncFunctionDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(AsyncFunctionDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(AsyncFunctionDef_annotations,
                                    "decorator_list", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncFunctionDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(AsyncFunctionDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(AsyncFunctionDef_annotations, "returns",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncFunctionDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(AsyncFunctionDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(AsyncFunctionDef_annotations,
                                    "type_comment", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncFunctionDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->type_param_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(AsyncFunctionDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(AsyncFunctionDef_annotations,
                                    "type_params", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncFunctionDef_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->AsyncFunctionDef_type, "_field_types",
                                  AsyncFunctionDef_annotations) == 0;
    if (!cond) {
        Py_DECREF(AsyncFunctionDef_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->AsyncFunctionDef_type,
                                  "__annotations__",
                                  AsyncFunctionDef_annotations) == 0;
    if (!cond) {
        Py_DECREF(AsyncFunctionDef_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_AsyncFunctionDef_type,
                                  "_field_types", AsyncFunctionDef_annotations)
                                  == 0;
    if (!cond) {
        Py_DECREF(AsyncFunctionDef_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_AsyncFunctionDef_type,
                                  "__annotations__",
                                  AsyncFunctionDef_annotations) == 0;
    if (!cond) {
        Py_DECREF(AsyncFunctionDef_annotations);
        return 0;
    }
    Py_DECREF(AsyncFunctionDef_annotations);
    PyObject *ClassDef_annotations = PyDict_New();
    if (!ClassDef_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(ClassDef_annotations, "name", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ClassDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(ClassDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(ClassDef_annotations, "bases", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ClassDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->keyword_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(ClassDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(ClassDef_annotations, "keywords", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ClassDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(ClassDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(ClassDef_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ClassDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(ClassDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(ClassDef_annotations, "decorator_list",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ClassDef_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->type_param_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(ClassDef_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(ClassDef_annotations, "type_params", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ClassDef_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->ClassDef_type, "_field_types",
                                  ClassDef_annotations) == 0;
    if (!cond) {
        Py_DECREF(ClassDef_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->ClassDef_type, "__annotations__",
                                  ClassDef_annotations) == 0;
    if (!cond) {
        Py_DECREF(ClassDef_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_ClassDef_type, "_field_types",
                                  ClassDef_annotations) == 0;
    if (!cond) {
        Py_DECREF(ClassDef_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_ClassDef_type, "__annotations__",
                                  ClassDef_annotations) == 0;
    if (!cond) {
        Py_DECREF(ClassDef_annotations);
        return 0;
    }
    Py_DECREF(ClassDef_annotations);
    PyObject *Return_annotations = PyDict_New();
    if (!Return_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Return_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Return_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Return_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Return_type, "_field_types",
                                  Return_annotations) == 0;
    if (!cond) {
        Py_DECREF(Return_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Return_type, "__annotations__",
                                  Return_annotations) == 0;
    if (!cond) {
        Py_DECREF(Return_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Return_type, "_field_types",
                                  Return_annotations) == 0;
    if (!cond) {
        Py_DECREF(Return_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Return_type, "__annotations__",
                                  Return_annotations) == 0;
    if (!cond) {
        Py_DECREF(Return_annotations);
        return 0;
    }
    Py_DECREF(Return_annotations);
    PyObject *Delete_annotations = PyDict_New();
    if (!Delete_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Delete_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Delete_annotations, "targets", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Delete_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Delete_type, "_field_types",
                                  Delete_annotations) == 0;
    if (!cond) {
        Py_DECREF(Delete_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Delete_type, "__annotations__",
                                  Delete_annotations) == 0;
    if (!cond) {
        Py_DECREF(Delete_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Delete_type, "_field_types",
                                  Delete_annotations) == 0;
    if (!cond) {
        Py_DECREF(Delete_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Delete_type, "__annotations__",
                                  Delete_annotations) == 0;
    if (!cond) {
        Py_DECREF(Delete_annotations);
        return 0;
    }
    Py_DECREF(Delete_annotations);
    PyObject *Assign_annotations = PyDict_New();
    if (!Assign_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Assign_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Assign_annotations, "targets", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Assign_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Assign_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Assign_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Assign_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Assign_annotations, "type_comment", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Assign_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Assign_type, "_field_types",
                                  Assign_annotations) == 0;
    if (!cond) {
        Py_DECREF(Assign_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Assign_type, "__annotations__",
                                  Assign_annotations) == 0;
    if (!cond) {
        Py_DECREF(Assign_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Assign_type, "_field_types",
                                  Assign_annotations) == 0;
    if (!cond) {
        Py_DECREF(Assign_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Assign_type, "__annotations__",
                                  Assign_annotations) == 0;
    if (!cond) {
        Py_DECREF(Assign_annotations);
        return 0;
    }
    Py_DECREF(Assign_annotations);
    PyObject *TypeAlias_annotations = PyDict_New();
    if (!TypeAlias_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(TypeAlias_annotations, "name", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TypeAlias_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->type_param_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(TypeAlias_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(TypeAlias_annotations, "type_params", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TypeAlias_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(TypeAlias_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TypeAlias_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->TypeAlias_type, "_field_types",
                                  TypeAlias_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeAlias_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->TypeAlias_type, "__annotations__",
                                  TypeAlias_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeAlias_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_TypeAlias_type, "_field_types",
                                  TypeAlias_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeAlias_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_TypeAlias_type, "__annotations__",
                                  TypeAlias_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeAlias_annotations);
        return 0;
    }
    Py_DECREF(TypeAlias_annotations);
    PyObject *AugAssign_annotations = PyDict_New();
    if (!AugAssign_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(AugAssign_annotations, "target", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AugAssign_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->operator_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(AugAssign_annotations, "op", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AugAssign_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(AugAssign_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AugAssign_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->AugAssign_type, "_field_types",
                                  AugAssign_annotations) == 0;
    if (!cond) {
        Py_DECREF(AugAssign_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->AugAssign_type, "__annotations__",
                                  AugAssign_annotations) == 0;
    if (!cond) {
        Py_DECREF(AugAssign_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_AugAssign_type, "_field_types",
                                  AugAssign_annotations) == 0;
    if (!cond) {
        Py_DECREF(AugAssign_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_AugAssign_type, "__annotations__",
                                  AugAssign_annotations) == 0;
    if (!cond) {
        Py_DECREF(AugAssign_annotations);
        return 0;
    }
    Py_DECREF(AugAssign_annotations);
    PyObject *AnnAssign_annotations = PyDict_New();
    if (!AnnAssign_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(AnnAssign_annotations, "target", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AnnAssign_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(AnnAssign_annotations, "annotation", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AnnAssign_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(AnnAssign_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(AnnAssign_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AnnAssign_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyLong_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(AnnAssign_annotations, "simple", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AnnAssign_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->AnnAssign_type, "_field_types",
                                  AnnAssign_annotations) == 0;
    if (!cond) {
        Py_DECREF(AnnAssign_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->AnnAssign_type, "__annotations__",
                                  AnnAssign_annotations) == 0;
    if (!cond) {
        Py_DECREF(AnnAssign_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_AnnAssign_type, "_field_types",
                                  AnnAssign_annotations) == 0;
    if (!cond) {
        Py_DECREF(AnnAssign_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_AnnAssign_type, "__annotations__",
                                  AnnAssign_annotations) == 0;
    if (!cond) {
        Py_DECREF(AnnAssign_annotations);
        return 0;
    }
    Py_DECREF(AnnAssign_annotations);
    PyObject *For_annotations = PyDict_New();
    if (!For_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(For_annotations, "target", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(For_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(For_annotations, "iter", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(For_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(For_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(For_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(For_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(For_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(For_annotations, "orelse", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(For_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(For_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(For_annotations, "type_comment", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(For_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->For_type, "_field_types",
                                  For_annotations) == 0;
    if (!cond) {
        Py_DECREF(For_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->For_type, "__annotations__",
                                  For_annotations) == 0;
    if (!cond) {
        Py_DECREF(For_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_For_type, "_field_types",
                                  For_annotations) == 0;
    if (!cond) {
        Py_DECREF(For_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_For_type, "__annotations__",
                                  For_annotations) == 0;
    if (!cond) {
        Py_DECREF(For_annotations);
        return 0;
    }
    Py_DECREF(For_annotations);
    PyObject *AsyncFor_annotations = PyDict_New();
    if (!AsyncFor_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(AsyncFor_annotations, "target", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncFor_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(AsyncFor_annotations, "iter", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncFor_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(AsyncFor_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(AsyncFor_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncFor_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(AsyncFor_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(AsyncFor_annotations, "orelse", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncFor_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(AsyncFor_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(AsyncFor_annotations, "type_comment", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncFor_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->AsyncFor_type, "_field_types",
                                  AsyncFor_annotations) == 0;
    if (!cond) {
        Py_DECREF(AsyncFor_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->AsyncFor_type, "__annotations__",
                                  AsyncFor_annotations) == 0;
    if (!cond) {
        Py_DECREF(AsyncFor_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_AsyncFor_type, "_field_types",
                                  AsyncFor_annotations) == 0;
    if (!cond) {
        Py_DECREF(AsyncFor_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_AsyncFor_type, "__annotations__",
                                  AsyncFor_annotations) == 0;
    if (!cond) {
        Py_DECREF(AsyncFor_annotations);
        return 0;
    }
    Py_DECREF(AsyncFor_annotations);
    PyObject *While_annotations = PyDict_New();
    if (!While_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(While_annotations, "test", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(While_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(While_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(While_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(While_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(While_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(While_annotations, "orelse", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(While_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->While_type, "_field_types",
                                  While_annotations) == 0;
    if (!cond) {
        Py_DECREF(While_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->While_type, "__annotations__",
                                  While_annotations) == 0;
    if (!cond) {
        Py_DECREF(While_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_While_type, "_field_types",
                                  While_annotations) == 0;
    if (!cond) {
        Py_DECREF(While_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_While_type, "__annotations__",
                                  While_annotations) == 0;
    if (!cond) {
        Py_DECREF(While_annotations);
        return 0;
    }
    Py_DECREF(While_annotations);
    PyObject *If_annotations = PyDict_New();
    if (!If_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(If_annotations, "test", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(If_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(If_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(If_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(If_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(If_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(If_annotations, "orelse", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(If_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->If_type, "_field_types",
                                  If_annotations) == 0;
    if (!cond) {
        Py_DECREF(If_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->If_type, "__annotations__",
                                  If_annotations) == 0;
    if (!cond) {
        Py_DECREF(If_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_If_type, "_field_types",
                                  If_annotations) == 0;
    if (!cond) {
        Py_DECREF(If_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_If_type, "__annotations__",
                                  If_annotations) == 0;
    if (!cond) {
        Py_DECREF(If_annotations);
        return 0;
    }
    Py_DECREF(If_annotations);
    PyObject *With_annotations = PyDict_New();
    if (!With_annotations) return 0;
    {
        PyObject *type = state->withitem_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(With_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(With_annotations, "items", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(With_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(With_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(With_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(With_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(With_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(With_annotations, "type_comment", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(With_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->With_type, "_field_types",
                                  With_annotations) == 0;
    if (!cond) {
        Py_DECREF(With_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->With_type, "__annotations__",
                                  With_annotations) == 0;
    if (!cond) {
        Py_DECREF(With_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_With_type, "_field_types",
                                  With_annotations) == 0;
    if (!cond) {
        Py_DECREF(With_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_With_type, "__annotations__",
                                  With_annotations) == 0;
    if (!cond) {
        Py_DECREF(With_annotations);
        return 0;
    }
    Py_DECREF(With_annotations);
    PyObject *AsyncWith_annotations = PyDict_New();
    if (!AsyncWith_annotations) return 0;
    {
        PyObject *type = state->withitem_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(AsyncWith_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(AsyncWith_annotations, "items", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncWith_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(AsyncWith_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(AsyncWith_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncWith_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(AsyncWith_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(AsyncWith_annotations, "type_comment",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(AsyncWith_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->AsyncWith_type, "_field_types",
                                  AsyncWith_annotations) == 0;
    if (!cond) {
        Py_DECREF(AsyncWith_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->AsyncWith_type, "__annotations__",
                                  AsyncWith_annotations) == 0;
    if (!cond) {
        Py_DECREF(AsyncWith_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_AsyncWith_type, "_field_types",
                                  AsyncWith_annotations) == 0;
    if (!cond) {
        Py_DECREF(AsyncWith_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_AsyncWith_type, "__annotations__",
                                  AsyncWith_annotations) == 0;
    if (!cond) {
        Py_DECREF(AsyncWith_annotations);
        return 0;
    }
    Py_DECREF(AsyncWith_annotations);
    PyObject *Match_annotations = PyDict_New();
    if (!Match_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Match_annotations, "subject", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Match_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->match_case_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Match_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Match_annotations, "cases", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Match_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Match_type, "_field_types",
                                  Match_annotations) == 0;
    if (!cond) {
        Py_DECREF(Match_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Match_type, "__annotations__",
                                  Match_annotations) == 0;
    if (!cond) {
        Py_DECREF(Match_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Match_type, "_field_types",
                                  Match_annotations) == 0;
    if (!cond) {
        Py_DECREF(Match_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Match_type, "__annotations__",
                                  Match_annotations) == 0;
    if (!cond) {
        Py_DECREF(Match_annotations);
        return 0;
    }
    Py_DECREF(Match_annotations);
    PyObject *Raise_annotations = PyDict_New();
    if (!Raise_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Raise_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Raise_annotations, "exc", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Raise_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Raise_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Raise_annotations, "cause", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Raise_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Raise_type, "_field_types",
                                  Raise_annotations) == 0;
    if (!cond) {
        Py_DECREF(Raise_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Raise_type, "__annotations__",
                                  Raise_annotations) == 0;
    if (!cond) {
        Py_DECREF(Raise_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Raise_type, "_field_types",
                                  Raise_annotations) == 0;
    if (!cond) {
        Py_DECREF(Raise_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Raise_type, "__annotations__",
                                  Raise_annotations) == 0;
    if (!cond) {
        Py_DECREF(Raise_annotations);
        return 0;
    }
    Py_DECREF(Raise_annotations);
    PyObject *Try_annotations = PyDict_New();
    if (!Try_annotations) return 0;
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Try_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Try_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Try_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->excepthandler_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Try_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Try_annotations, "handlers", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Try_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Try_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Try_annotations, "orelse", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Try_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Try_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Try_annotations, "finalbody", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Try_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Try_type, "_field_types",
                                  Try_annotations) == 0;
    if (!cond) {
        Py_DECREF(Try_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Try_type, "__annotations__",
                                  Try_annotations) == 0;
    if (!cond) {
        Py_DECREF(Try_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Try_type, "_field_types",
                                  Try_annotations) == 0;
    if (!cond) {
        Py_DECREF(Try_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Try_type, "__annotations__",
                                  Try_annotations) == 0;
    if (!cond) {
        Py_DECREF(Try_annotations);
        return 0;
    }
    Py_DECREF(Try_annotations);
    PyObject *TryStar_annotations = PyDict_New();
    if (!TryStar_annotations) return 0;
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(TryStar_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(TryStar_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TryStar_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->excepthandler_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(TryStar_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(TryStar_annotations, "handlers", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TryStar_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(TryStar_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(TryStar_annotations, "orelse", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TryStar_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(TryStar_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(TryStar_annotations, "finalbody", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TryStar_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->TryStar_type, "_field_types",
                                  TryStar_annotations) == 0;
    if (!cond) {
        Py_DECREF(TryStar_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->TryStar_type, "__annotations__",
                                  TryStar_annotations) == 0;
    if (!cond) {
        Py_DECREF(TryStar_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_TryStar_type, "_field_types",
                                  TryStar_annotations) == 0;
    if (!cond) {
        Py_DECREF(TryStar_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_TryStar_type, "__annotations__",
                                  TryStar_annotations) == 0;
    if (!cond) {
        Py_DECREF(TryStar_annotations);
        return 0;
    }
    Py_DECREF(TryStar_annotations);
    PyObject *Assert_annotations = PyDict_New();
    if (!Assert_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Assert_annotations, "test", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Assert_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Assert_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Assert_annotations, "msg", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Assert_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Assert_type, "_field_types",
                                  Assert_annotations) == 0;
    if (!cond) {
        Py_DECREF(Assert_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Assert_type, "__annotations__",
                                  Assert_annotations) == 0;
    if (!cond) {
        Py_DECREF(Assert_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Assert_type, "_field_types",
                                  Assert_annotations) == 0;
    if (!cond) {
        Py_DECREF(Assert_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Assert_type, "__annotations__",
                                  Assert_annotations) == 0;
    if (!cond) {
        Py_DECREF(Assert_annotations);
        return 0;
    }
    Py_DECREF(Assert_annotations);
    PyObject *Import_annotations = PyDict_New();
    if (!Import_annotations) return 0;
    {
        PyObject *type = state->alias_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Import_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Import_annotations, "names", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Import_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Import_type, "_field_types",
                                  Import_annotations) == 0;
    if (!cond) {
        Py_DECREF(Import_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Import_type, "__annotations__",
                                  Import_annotations) == 0;
    if (!cond) {
        Py_DECREF(Import_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Import_type, "_field_types",
                                  Import_annotations) == 0;
    if (!cond) {
        Py_DECREF(Import_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Import_type, "__annotations__",
                                  Import_annotations) == 0;
    if (!cond) {
        Py_DECREF(Import_annotations);
        return 0;
    }
    Py_DECREF(Import_annotations);
    PyObject *ImportFrom_annotations = PyDict_New();
    if (!ImportFrom_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(ImportFrom_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(ImportFrom_annotations, "module", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ImportFrom_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->alias_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(ImportFrom_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(ImportFrom_annotations, "names", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ImportFrom_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyLong_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(ImportFrom_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(ImportFrom_annotations, "level", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ImportFrom_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->ImportFrom_type, "_field_types",
                                  ImportFrom_annotations) == 0;
    if (!cond) {
        Py_DECREF(ImportFrom_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->ImportFrom_type, "__annotations__",
                                  ImportFrom_annotations) == 0;
    if (!cond) {
        Py_DECREF(ImportFrom_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_ImportFrom_type, "_field_types",
                                  ImportFrom_annotations) == 0;
    if (!cond) {
        Py_DECREF(ImportFrom_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_ImportFrom_type, "__annotations__",
                                  ImportFrom_annotations) == 0;
    if (!cond) {
        Py_DECREF(ImportFrom_annotations);
        return 0;
    }
    Py_DECREF(ImportFrom_annotations);
    PyObject *Global_annotations = PyDict_New();
    if (!Global_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Global_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Global_annotations, "names", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Global_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Global_type, "_field_types",
                                  Global_annotations) == 0;
    if (!cond) {
        Py_DECREF(Global_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Global_type, "__annotations__",
                                  Global_annotations) == 0;
    if (!cond) {
        Py_DECREF(Global_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Global_type, "_field_types",
                                  Global_annotations) == 0;
    if (!cond) {
        Py_DECREF(Global_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Global_type, "__annotations__",
                                  Global_annotations) == 0;
    if (!cond) {
        Py_DECREF(Global_annotations);
        return 0;
    }
    Py_DECREF(Global_annotations);
    PyObject *Nonlocal_annotations = PyDict_New();
    if (!Nonlocal_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Nonlocal_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Nonlocal_annotations, "names", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Nonlocal_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Nonlocal_type, "_field_types",
                                  Nonlocal_annotations) == 0;
    if (!cond) {
        Py_DECREF(Nonlocal_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Nonlocal_type, "__annotations__",
                                  Nonlocal_annotations) == 0;
    if (!cond) {
        Py_DECREF(Nonlocal_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Nonlocal_type, "_field_types",
                                  Nonlocal_annotations) == 0;
    if (!cond) {
        Py_DECREF(Nonlocal_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Nonlocal_type, "__annotations__",
                                  Nonlocal_annotations) == 0;
    if (!cond) {
        Py_DECREF(Nonlocal_annotations);
        return 0;
    }
    Py_DECREF(Nonlocal_annotations);
    PyObject *Expr_annotations = PyDict_New();
    if (!Expr_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Expr_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Expr_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Expr_type, "_field_types",
                                  Expr_annotations) == 0;
    if (!cond) {
        Py_DECREF(Expr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Expr_type, "__annotations__",
                                  Expr_annotations) == 0;
    if (!cond) {
        Py_DECREF(Expr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Expr_type, "_field_types",
                                  Expr_annotations) == 0;
    if (!cond) {
        Py_DECREF(Expr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Expr_type, "__annotations__",
                                  Expr_annotations) == 0;
    if (!cond) {
        Py_DECREF(Expr_annotations);
        return 0;
    }
    Py_DECREF(Expr_annotations);
    PyObject *Pass_annotations = PyDict_New();
    if (!Pass_annotations) return 0;
    cond = PyObject_SetAttrString(state->Pass_type, "_field_types",
                                  Pass_annotations) == 0;
    if (!cond) {
        Py_DECREF(Pass_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Pass_type, "__annotations__",
                                  Pass_annotations) == 0;
    if (!cond) {
        Py_DECREF(Pass_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Pass_type, "_field_types",
                                  Pass_annotations) == 0;
    if (!cond) {
        Py_DECREF(Pass_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Pass_type, "__annotations__",
                                  Pass_annotations) == 0;
    if (!cond) {
        Py_DECREF(Pass_annotations);
        return 0;
    }
    Py_DECREF(Pass_annotations);
    PyObject *Break_annotations = PyDict_New();
    if (!Break_annotations) return 0;
    cond = PyObject_SetAttrString(state->Break_type, "_field_types",
                                  Break_annotations) == 0;
    if (!cond) {
        Py_DECREF(Break_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Break_type, "__annotations__",
                                  Break_annotations) == 0;
    if (!cond) {
        Py_DECREF(Break_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Break_type, "_field_types",
                                  Break_annotations) == 0;
    if (!cond) {
        Py_DECREF(Break_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Break_type, "__annotations__",
                                  Break_annotations) == 0;
    if (!cond) {
        Py_DECREF(Break_annotations);
        return 0;
    }
    Py_DECREF(Break_annotations);
    PyObject *Continue_annotations = PyDict_New();
    if (!Continue_annotations) return 0;
    cond = PyObject_SetAttrString(state->Continue_type, "_field_types",
                                  Continue_annotations) == 0;
    if (!cond) {
        Py_DECREF(Continue_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Continue_type, "__annotations__",
                                  Continue_annotations) == 0;
    if (!cond) {
        Py_DECREF(Continue_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Continue_type, "_field_types",
                                  Continue_annotations) == 0;
    if (!cond) {
        Py_DECREF(Continue_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Continue_type, "__annotations__",
                                  Continue_annotations) == 0;
    if (!cond) {
        Py_DECREF(Continue_annotations);
        return 0;
    }
    Py_DECREF(Continue_annotations);
    PyObject *BoolOp_annotations = PyDict_New();
    if (!BoolOp_annotations) return 0;
    {
        PyObject *type = state->boolop_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(BoolOp_annotations, "op", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(BoolOp_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(BoolOp_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(BoolOp_annotations, "values", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(BoolOp_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->BoolOp_type, "_field_types",
                                  BoolOp_annotations) == 0;
    if (!cond) {
        Py_DECREF(BoolOp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->BoolOp_type, "__annotations__",
                                  BoolOp_annotations) == 0;
    if (!cond) {
        Py_DECREF(BoolOp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_BoolOp_type, "_field_types",
                                  BoolOp_annotations) == 0;
    if (!cond) {
        Py_DECREF(BoolOp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_BoolOp_type, "__annotations__",
                                  BoolOp_annotations) == 0;
    if (!cond) {
        Py_DECREF(BoolOp_annotations);
        return 0;
    }
    Py_DECREF(BoolOp_annotations);
    PyObject *NamedExpr_annotations = PyDict_New();
    if (!NamedExpr_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(NamedExpr_annotations, "target", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(NamedExpr_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(NamedExpr_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(NamedExpr_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->NamedExpr_type, "_field_types",
                                  NamedExpr_annotations) == 0;
    if (!cond) {
        Py_DECREF(NamedExpr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->NamedExpr_type, "__annotations__",
                                  NamedExpr_annotations) == 0;
    if (!cond) {
        Py_DECREF(NamedExpr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_NamedExpr_type, "_field_types",
                                  NamedExpr_annotations) == 0;
    if (!cond) {
        Py_DECREF(NamedExpr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_NamedExpr_type, "__annotations__",
                                  NamedExpr_annotations) == 0;
    if (!cond) {
        Py_DECREF(NamedExpr_annotations);
        return 0;
    }
    Py_DECREF(NamedExpr_annotations);
    PyObject *BinOp_annotations = PyDict_New();
    if (!BinOp_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(BinOp_annotations, "left", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(BinOp_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->operator_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(BinOp_annotations, "op", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(BinOp_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(BinOp_annotations, "right", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(BinOp_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->BinOp_type, "_field_types",
                                  BinOp_annotations) == 0;
    if (!cond) {
        Py_DECREF(BinOp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->BinOp_type, "__annotations__",
                                  BinOp_annotations) == 0;
    if (!cond) {
        Py_DECREF(BinOp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_BinOp_type, "_field_types",
                                  BinOp_annotations) == 0;
    if (!cond) {
        Py_DECREF(BinOp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_BinOp_type, "__annotations__",
                                  BinOp_annotations) == 0;
    if (!cond) {
        Py_DECREF(BinOp_annotations);
        return 0;
    }
    Py_DECREF(BinOp_annotations);
    PyObject *UnaryOp_annotations = PyDict_New();
    if (!UnaryOp_annotations) return 0;
    {
        PyObject *type = state->unaryop_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(UnaryOp_annotations, "op", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(UnaryOp_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(UnaryOp_annotations, "operand", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(UnaryOp_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->UnaryOp_type, "_field_types",
                                  UnaryOp_annotations) == 0;
    if (!cond) {
        Py_DECREF(UnaryOp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->UnaryOp_type, "__annotations__",
                                  UnaryOp_annotations) == 0;
    if (!cond) {
        Py_DECREF(UnaryOp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_UnaryOp_type, "_field_types",
                                  UnaryOp_annotations) == 0;
    if (!cond) {
        Py_DECREF(UnaryOp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_UnaryOp_type, "__annotations__",
                                  UnaryOp_annotations) == 0;
    if (!cond) {
        Py_DECREF(UnaryOp_annotations);
        return 0;
    }
    Py_DECREF(UnaryOp_annotations);
    PyObject *Lambda_annotations = PyDict_New();
    if (!Lambda_annotations) return 0;
    {
        PyObject *type = state->arguments_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Lambda_annotations, "args", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Lambda_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Lambda_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Lambda_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Lambda_type, "_field_types",
                                  Lambda_annotations) == 0;
    if (!cond) {
        Py_DECREF(Lambda_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Lambda_type, "__annotations__",
                                  Lambda_annotations) == 0;
    if (!cond) {
        Py_DECREF(Lambda_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Lambda_type, "_field_types",
                                  Lambda_annotations) == 0;
    if (!cond) {
        Py_DECREF(Lambda_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Lambda_type, "__annotations__",
                                  Lambda_annotations) == 0;
    if (!cond) {
        Py_DECREF(Lambda_annotations);
        return 0;
    }
    Py_DECREF(Lambda_annotations);
    PyObject *IfExp_annotations = PyDict_New();
    if (!IfExp_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(IfExp_annotations, "test", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(IfExp_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(IfExp_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(IfExp_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(IfExp_annotations, "orelse", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(IfExp_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->IfExp_type, "_field_types",
                                  IfExp_annotations) == 0;
    if (!cond) {
        Py_DECREF(IfExp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->IfExp_type, "__annotations__",
                                  IfExp_annotations) == 0;
    if (!cond) {
        Py_DECREF(IfExp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_IfExp_type, "_field_types",
                                  IfExp_annotations) == 0;
    if (!cond) {
        Py_DECREF(IfExp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_IfExp_type, "__annotations__",
                                  IfExp_annotations) == 0;
    if (!cond) {
        Py_DECREF(IfExp_annotations);
        return 0;
    }
    Py_DECREF(IfExp_annotations);
    PyObject *Dict_annotations = PyDict_New();
    if (!Dict_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Dict_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Dict_annotations, "keys", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Dict_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Dict_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Dict_annotations, "values", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Dict_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Dict_type, "_field_types",
                                  Dict_annotations) == 0;
    if (!cond) {
        Py_DECREF(Dict_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Dict_type, "__annotations__",
                                  Dict_annotations) == 0;
    if (!cond) {
        Py_DECREF(Dict_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Dict_type, "_field_types",
                                  Dict_annotations) == 0;
    if (!cond) {
        Py_DECREF(Dict_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Dict_type, "__annotations__",
                                  Dict_annotations) == 0;
    if (!cond) {
        Py_DECREF(Dict_annotations);
        return 0;
    }
    Py_DECREF(Dict_annotations);
    PyObject *Set_annotations = PyDict_New();
    if (!Set_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Set_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Set_annotations, "elts", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Set_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Set_type, "_field_types",
                                  Set_annotations) == 0;
    if (!cond) {
        Py_DECREF(Set_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Set_type, "__annotations__",
                                  Set_annotations) == 0;
    if (!cond) {
        Py_DECREF(Set_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Set_type, "_field_types",
                                  Set_annotations) == 0;
    if (!cond) {
        Py_DECREF(Set_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Set_type, "__annotations__",
                                  Set_annotations) == 0;
    if (!cond) {
        Py_DECREF(Set_annotations);
        return 0;
    }
    Py_DECREF(Set_annotations);
    PyObject *ListComp_annotations = PyDict_New();
    if (!ListComp_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(ListComp_annotations, "elt", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ListComp_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->comprehension_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(ListComp_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(ListComp_annotations, "generators", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ListComp_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->ListComp_type, "_field_types",
                                  ListComp_annotations) == 0;
    if (!cond) {
        Py_DECREF(ListComp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->ListComp_type, "__annotations__",
                                  ListComp_annotations) == 0;
    if (!cond) {
        Py_DECREF(ListComp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_ListComp_type, "_field_types",
                                  ListComp_annotations) == 0;
    if (!cond) {
        Py_DECREF(ListComp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_ListComp_type, "__annotations__",
                                  ListComp_annotations) == 0;
    if (!cond) {
        Py_DECREF(ListComp_annotations);
        return 0;
    }
    Py_DECREF(ListComp_annotations);
    PyObject *SetComp_annotations = PyDict_New();
    if (!SetComp_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(SetComp_annotations, "elt", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(SetComp_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->comprehension_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(SetComp_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(SetComp_annotations, "generators", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(SetComp_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->SetComp_type, "_field_types",
                                  SetComp_annotations) == 0;
    if (!cond) {
        Py_DECREF(SetComp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->SetComp_type, "__annotations__",
                                  SetComp_annotations) == 0;
    if (!cond) {
        Py_DECREF(SetComp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_SetComp_type, "_field_types",
                                  SetComp_annotations) == 0;
    if (!cond) {
        Py_DECREF(SetComp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_SetComp_type, "__annotations__",
                                  SetComp_annotations) == 0;
    if (!cond) {
        Py_DECREF(SetComp_annotations);
        return 0;
    }
    Py_DECREF(SetComp_annotations);
    PyObject *DictComp_annotations = PyDict_New();
    if (!DictComp_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(DictComp_annotations, "key", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(DictComp_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(DictComp_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(DictComp_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->comprehension_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(DictComp_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(DictComp_annotations, "generators", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(DictComp_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->DictComp_type, "_field_types",
                                  DictComp_annotations) == 0;
    if (!cond) {
        Py_DECREF(DictComp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->DictComp_type, "__annotations__",
                                  DictComp_annotations) == 0;
    if (!cond) {
        Py_DECREF(DictComp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_DictComp_type, "_field_types",
                                  DictComp_annotations) == 0;
    if (!cond) {
        Py_DECREF(DictComp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_DictComp_type, "__annotations__",
                                  DictComp_annotations) == 0;
    if (!cond) {
        Py_DECREF(DictComp_annotations);
        return 0;
    }
    Py_DECREF(DictComp_annotations);
    PyObject *GeneratorExp_annotations = PyDict_New();
    if (!GeneratorExp_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(GeneratorExp_annotations, "elt", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(GeneratorExp_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->comprehension_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(GeneratorExp_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(GeneratorExp_annotations, "generators",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(GeneratorExp_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->GeneratorExp_type, "_field_types",
                                  GeneratorExp_annotations) == 0;
    if (!cond) {
        Py_DECREF(GeneratorExp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->GeneratorExp_type, "__annotations__",
                                  GeneratorExp_annotations) == 0;
    if (!cond) {
        Py_DECREF(GeneratorExp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_GeneratorExp_type, "_field_types",
                                  GeneratorExp_annotations) == 0;
    if (!cond) {
        Py_DECREF(GeneratorExp_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_GeneratorExp_type, "__annotations__",
                                  GeneratorExp_annotations) == 0;
    if (!cond) {
        Py_DECREF(GeneratorExp_annotations);
        return 0;
    }
    Py_DECREF(GeneratorExp_annotations);
    PyObject *Await_annotations = PyDict_New();
    if (!Await_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Await_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Await_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Await_type, "_field_types",
                                  Await_annotations) == 0;
    if (!cond) {
        Py_DECREF(Await_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Await_type, "__annotations__",
                                  Await_annotations) == 0;
    if (!cond) {
        Py_DECREF(Await_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Await_type, "_field_types",
                                  Await_annotations) == 0;
    if (!cond) {
        Py_DECREF(Await_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Await_type, "__annotations__",
                                  Await_annotations) == 0;
    if (!cond) {
        Py_DECREF(Await_annotations);
        return 0;
    }
    Py_DECREF(Await_annotations);
    PyObject *Yield_annotations = PyDict_New();
    if (!Yield_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Yield_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Yield_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Yield_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Yield_type, "_field_types",
                                  Yield_annotations) == 0;
    if (!cond) {
        Py_DECREF(Yield_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Yield_type, "__annotations__",
                                  Yield_annotations) == 0;
    if (!cond) {
        Py_DECREF(Yield_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Yield_type, "_field_types",
                                  Yield_annotations) == 0;
    if (!cond) {
        Py_DECREF(Yield_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Yield_type, "__annotations__",
                                  Yield_annotations) == 0;
    if (!cond) {
        Py_DECREF(Yield_annotations);
        return 0;
    }
    Py_DECREF(Yield_annotations);
    PyObject *YieldFrom_annotations = PyDict_New();
    if (!YieldFrom_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(YieldFrom_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(YieldFrom_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->YieldFrom_type, "_field_types",
                                  YieldFrom_annotations) == 0;
    if (!cond) {
        Py_DECREF(YieldFrom_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->YieldFrom_type, "__annotations__",
                                  YieldFrom_annotations) == 0;
    if (!cond) {
        Py_DECREF(YieldFrom_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_YieldFrom_type, "_field_types",
                                  YieldFrom_annotations) == 0;
    if (!cond) {
        Py_DECREF(YieldFrom_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_YieldFrom_type, "__annotations__",
                                  YieldFrom_annotations) == 0;
    if (!cond) {
        Py_DECREF(YieldFrom_annotations);
        return 0;
    }
    Py_DECREF(YieldFrom_annotations);
    PyObject *Compare_annotations = PyDict_New();
    if (!Compare_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Compare_annotations, "left", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Compare_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->cmpop_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Compare_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Compare_annotations, "ops", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Compare_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Compare_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Compare_annotations, "comparators", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Compare_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Compare_type, "_field_types",
                                  Compare_annotations) == 0;
    if (!cond) {
        Py_DECREF(Compare_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Compare_type, "__annotations__",
                                  Compare_annotations) == 0;
    if (!cond) {
        Py_DECREF(Compare_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Compare_type, "_field_types",
                                  Compare_annotations) == 0;
    if (!cond) {
        Py_DECREF(Compare_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Compare_type, "__annotations__",
                                  Compare_annotations) == 0;
    if (!cond) {
        Py_DECREF(Compare_annotations);
        return 0;
    }
    Py_DECREF(Compare_annotations);
    PyObject *Call_annotations = PyDict_New();
    if (!Call_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Call_annotations, "func", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Call_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Call_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Call_annotations, "args", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Call_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->keyword_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Call_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Call_annotations, "keywords", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Call_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Call_type, "_field_types",
                                  Call_annotations) == 0;
    if (!cond) {
        Py_DECREF(Call_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Call_type, "__annotations__",
                                  Call_annotations) == 0;
    if (!cond) {
        Py_DECREF(Call_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Call_type, "_field_types",
                                  Call_annotations) == 0;
    if (!cond) {
        Py_DECREF(Call_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Call_type, "__annotations__",
                                  Call_annotations) == 0;
    if (!cond) {
        Py_DECREF(Call_annotations);
        return 0;
    }
    Py_DECREF(Call_annotations);
    PyObject *FormattedValue_annotations = PyDict_New();
    if (!FormattedValue_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(FormattedValue_annotations, "value", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(FormattedValue_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyLong_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(FormattedValue_annotations, "conversion",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(FormattedValue_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(FormattedValue_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(FormattedValue_annotations, "format_spec",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(FormattedValue_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->FormattedValue_type, "_field_types",
                                  FormattedValue_annotations) == 0;
    if (!cond) {
        Py_DECREF(FormattedValue_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->FormattedValue_type,
                                  "__annotations__",
                                  FormattedValue_annotations) == 0;
    if (!cond) {
        Py_DECREF(FormattedValue_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_FormattedValue_type, "_field_types",
                                  FormattedValue_annotations) == 0;
    if (!cond) {
        Py_DECREF(FormattedValue_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_FormattedValue_type,
                                  "__annotations__",
                                  FormattedValue_annotations) == 0;
    if (!cond) {
        Py_DECREF(FormattedValue_annotations);
        return 0;
    }
    Py_DECREF(FormattedValue_annotations);
    PyObject *Interpolation_annotations = PyDict_New();
    if (!Interpolation_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Interpolation_annotations, "value", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Interpolation_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyBaseObject_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Interpolation_annotations, "str", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Interpolation_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyLong_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Interpolation_annotations, "conversion",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Interpolation_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Interpolation_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Interpolation_annotations, "format_spec",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Interpolation_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Interpolation_type, "_field_types",
                                  Interpolation_annotations) == 0;
    if (!cond) {
        Py_DECREF(Interpolation_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Interpolation_type, "__annotations__",
                                  Interpolation_annotations) == 0;
    if (!cond) {
        Py_DECREF(Interpolation_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Interpolation_type, "_field_types",
                                  Interpolation_annotations) == 0;
    if (!cond) {
        Py_DECREF(Interpolation_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Interpolation_type,
                                  "__annotations__", Interpolation_annotations)
                                  == 0;
    if (!cond) {
        Py_DECREF(Interpolation_annotations);
        return 0;
    }
    Py_DECREF(Interpolation_annotations);
    PyObject *JoinedStr_annotations = PyDict_New();
    if (!JoinedStr_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(JoinedStr_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(JoinedStr_annotations, "values", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(JoinedStr_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->JoinedStr_type, "_field_types",
                                  JoinedStr_annotations) == 0;
    if (!cond) {
        Py_DECREF(JoinedStr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->JoinedStr_type, "__annotations__",
                                  JoinedStr_annotations) == 0;
    if (!cond) {
        Py_DECREF(JoinedStr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_JoinedStr_type, "_field_types",
                                  JoinedStr_annotations) == 0;
    if (!cond) {
        Py_DECREF(JoinedStr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_JoinedStr_type, "__annotations__",
                                  JoinedStr_annotations) == 0;
    if (!cond) {
        Py_DECREF(JoinedStr_annotations);
        return 0;
    }
    Py_DECREF(JoinedStr_annotations);
    PyObject *TemplateStr_annotations = PyDict_New();
    if (!TemplateStr_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(TemplateStr_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(TemplateStr_annotations, "values", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TemplateStr_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->TemplateStr_type, "_field_types",
                                  TemplateStr_annotations) == 0;
    if (!cond) {
        Py_DECREF(TemplateStr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->TemplateStr_type, "__annotations__",
                                  TemplateStr_annotations) == 0;
    if (!cond) {
        Py_DECREF(TemplateStr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_TemplateStr_type, "_field_types",
                                  TemplateStr_annotations) == 0;
    if (!cond) {
        Py_DECREF(TemplateStr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_TemplateStr_type, "__annotations__",
                                  TemplateStr_annotations) == 0;
    if (!cond) {
        Py_DECREF(TemplateStr_annotations);
        return 0;
    }
    Py_DECREF(TemplateStr_annotations);
    PyObject *Constant_annotations = PyDict_New();
    if (!Constant_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyBaseObject_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Constant_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Constant_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Constant_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Constant_annotations, "kind", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Constant_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Constant_type, "_field_types",
                                  Constant_annotations) == 0;
    if (!cond) {
        Py_DECREF(Constant_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Constant_type, "__annotations__",
                                  Constant_annotations) == 0;
    if (!cond) {
        Py_DECREF(Constant_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Constant_type, "_field_types",
                                  Constant_annotations) == 0;
    if (!cond) {
        Py_DECREF(Constant_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Constant_type, "__annotations__",
                                  Constant_annotations) == 0;
    if (!cond) {
        Py_DECREF(Constant_annotations);
        return 0;
    }
    Py_DECREF(Constant_annotations);
    PyObject *Attribute_annotations = PyDict_New();
    if (!Attribute_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Attribute_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Attribute_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Attribute_annotations, "attr", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Attribute_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_context_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Attribute_annotations, "ctx", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Attribute_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Attribute_type, "_field_types",
                                  Attribute_annotations) == 0;
    if (!cond) {
        Py_DECREF(Attribute_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Attribute_type, "__annotations__",
                                  Attribute_annotations) == 0;
    if (!cond) {
        Py_DECREF(Attribute_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Attribute_type, "_field_types",
                                  Attribute_annotations) == 0;
    if (!cond) {
        Py_DECREF(Attribute_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Attribute_type, "__annotations__",
                                  Attribute_annotations) == 0;
    if (!cond) {
        Py_DECREF(Attribute_annotations);
        return 0;
    }
    Py_DECREF(Attribute_annotations);
    PyObject *Subscript_annotations = PyDict_New();
    if (!Subscript_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Subscript_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Subscript_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Subscript_annotations, "slice", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Subscript_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_context_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Subscript_annotations, "ctx", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Subscript_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Subscript_type, "_field_types",
                                  Subscript_annotations) == 0;
    if (!cond) {
        Py_DECREF(Subscript_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Subscript_type, "__annotations__",
                                  Subscript_annotations) == 0;
    if (!cond) {
        Py_DECREF(Subscript_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Subscript_type, "_field_types",
                                  Subscript_annotations) == 0;
    if (!cond) {
        Py_DECREF(Subscript_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Subscript_type, "__annotations__",
                                  Subscript_annotations) == 0;
    if (!cond) {
        Py_DECREF(Subscript_annotations);
        return 0;
    }
    Py_DECREF(Subscript_annotations);
    PyObject *Starred_annotations = PyDict_New();
    if (!Starred_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Starred_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Starred_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_context_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Starred_annotations, "ctx", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Starred_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Starred_type, "_field_types",
                                  Starred_annotations) == 0;
    if (!cond) {
        Py_DECREF(Starred_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Starred_type, "__annotations__",
                                  Starred_annotations) == 0;
    if (!cond) {
        Py_DECREF(Starred_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Starred_type, "_field_types",
                                  Starred_annotations) == 0;
    if (!cond) {
        Py_DECREF(Starred_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Starred_type, "__annotations__",
                                  Starred_annotations) == 0;
    if (!cond) {
        Py_DECREF(Starred_annotations);
        return 0;
    }
    Py_DECREF(Starred_annotations);
    PyObject *Name_annotations = PyDict_New();
    if (!Name_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Name_annotations, "id", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Name_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_context_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Name_annotations, "ctx", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Name_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Name_type, "_field_types",
                                  Name_annotations) == 0;
    if (!cond) {
        Py_DECREF(Name_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Name_type, "__annotations__",
                                  Name_annotations) == 0;
    if (!cond) {
        Py_DECREF(Name_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Name_type, "_field_types",
                                  Name_annotations) == 0;
    if (!cond) {
        Py_DECREF(Name_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Name_type, "__annotations__",
                                  Name_annotations) == 0;
    if (!cond) {
        Py_DECREF(Name_annotations);
        return 0;
    }
    Py_DECREF(Name_annotations);
    PyObject *List_annotations = PyDict_New();
    if (!List_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(List_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(List_annotations, "elts", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(List_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_context_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(List_annotations, "ctx", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(List_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->List_type, "_field_types",
                                  List_annotations) == 0;
    if (!cond) {
        Py_DECREF(List_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->List_type, "__annotations__",
                                  List_annotations) == 0;
    if (!cond) {
        Py_DECREF(List_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_List_type, "_field_types",
                                  List_annotations) == 0;
    if (!cond) {
        Py_DECREF(List_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_List_type, "__annotations__",
                                  List_annotations) == 0;
    if (!cond) {
        Py_DECREF(List_annotations);
        return 0;
    }
    Py_DECREF(List_annotations);
    PyObject *Tuple_annotations = PyDict_New();
    if (!Tuple_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Tuple_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Tuple_annotations, "elts", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Tuple_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_context_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(Tuple_annotations, "ctx", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Tuple_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Tuple_type, "_field_types",
                                  Tuple_annotations) == 0;
    if (!cond) {
        Py_DECREF(Tuple_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Tuple_type, "__annotations__",
                                  Tuple_annotations) == 0;
    if (!cond) {
        Py_DECREF(Tuple_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Tuple_type, "_field_types",
                                  Tuple_annotations) == 0;
    if (!cond) {
        Py_DECREF(Tuple_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Tuple_type, "__annotations__",
                                  Tuple_annotations) == 0;
    if (!cond) {
        Py_DECREF(Tuple_annotations);
        return 0;
    }
    Py_DECREF(Tuple_annotations);
    PyObject *Slice_annotations = PyDict_New();
    if (!Slice_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Slice_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Slice_annotations, "lower", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Slice_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Slice_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Slice_annotations, "upper", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Slice_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(Slice_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(Slice_annotations, "step", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(Slice_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->Slice_type, "_field_types",
                                  Slice_annotations) == 0;
    if (!cond) {
        Py_DECREF(Slice_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Slice_type, "__annotations__",
                                  Slice_annotations) == 0;
    if (!cond) {
        Py_DECREF(Slice_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Slice_type, "_field_types",
                                  Slice_annotations) == 0;
    if (!cond) {
        Py_DECREF(Slice_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Slice_type, "__annotations__",
                                  Slice_annotations) == 0;
    if (!cond) {
        Py_DECREF(Slice_annotations);
        return 0;
    }
    Py_DECREF(Slice_annotations);
    PyObject *Load_annotations = PyDict_New();
    if (!Load_annotations) return 0;
    cond = PyObject_SetAttrString(state->Load_type, "_field_types",
                                  Load_annotations) == 0;
    if (!cond) {
        Py_DECREF(Load_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Load_type, "__annotations__",
                                  Load_annotations) == 0;
    if (!cond) {
        Py_DECREF(Load_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Load_type, "_field_types",
                                  Load_annotations) == 0;
    if (!cond) {
        Py_DECREF(Load_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Load_type, "__annotations__",
                                  Load_annotations) == 0;
    if (!cond) {
        Py_DECREF(Load_annotations);
        return 0;
    }
    Py_DECREF(Load_annotations);
    PyObject *Store_annotations = PyDict_New();
    if (!Store_annotations) return 0;
    cond = PyObject_SetAttrString(state->Store_type, "_field_types",
                                  Store_annotations) == 0;
    if (!cond) {
        Py_DECREF(Store_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Store_type, "__annotations__",
                                  Store_annotations) == 0;
    if (!cond) {
        Py_DECREF(Store_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Store_type, "_field_types",
                                  Store_annotations) == 0;
    if (!cond) {
        Py_DECREF(Store_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Store_type, "__annotations__",
                                  Store_annotations) == 0;
    if (!cond) {
        Py_DECREF(Store_annotations);
        return 0;
    }
    Py_DECREF(Store_annotations);
    PyObject *Del_annotations = PyDict_New();
    if (!Del_annotations) return 0;
    cond = PyObject_SetAttrString(state->Del_type, "_field_types",
                                  Del_annotations) == 0;
    if (!cond) {
        Py_DECREF(Del_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Del_type, "__annotations__",
                                  Del_annotations) == 0;
    if (!cond) {
        Py_DECREF(Del_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Del_type, "_field_types",
                                  Del_annotations) == 0;
    if (!cond) {
        Py_DECREF(Del_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Del_type, "__annotations__",
                                  Del_annotations) == 0;
    if (!cond) {
        Py_DECREF(Del_annotations);
        return 0;
    }
    Py_DECREF(Del_annotations);
    PyObject *And_annotations = PyDict_New();
    if (!And_annotations) return 0;
    cond = PyObject_SetAttrString(state->And_type, "_field_types",
                                  And_annotations) == 0;
    if (!cond) {
        Py_DECREF(And_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->And_type, "__annotations__",
                                  And_annotations) == 0;
    if (!cond) {
        Py_DECREF(And_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_And_type, "_field_types",
                                  And_annotations) == 0;
    if (!cond) {
        Py_DECREF(And_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_And_type, "__annotations__",
                                  And_annotations) == 0;
    if (!cond) {
        Py_DECREF(And_annotations);
        return 0;
    }
    Py_DECREF(And_annotations);
    PyObject *Or_annotations = PyDict_New();
    if (!Or_annotations) return 0;
    cond = PyObject_SetAttrString(state->Or_type, "_field_types",
                                  Or_annotations) == 0;
    if (!cond) {
        Py_DECREF(Or_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Or_type, "__annotations__",
                                  Or_annotations) == 0;
    if (!cond) {
        Py_DECREF(Or_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Or_type, "_field_types",
                                  Or_annotations) == 0;
    if (!cond) {
        Py_DECREF(Or_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Or_type, "__annotations__",
                                  Or_annotations) == 0;
    if (!cond) {
        Py_DECREF(Or_annotations);
        return 0;
    }
    Py_DECREF(Or_annotations);
    PyObject *Add_annotations = PyDict_New();
    if (!Add_annotations) return 0;
    cond = PyObject_SetAttrString(state->Add_type, "_field_types",
                                  Add_annotations) == 0;
    if (!cond) {
        Py_DECREF(Add_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Add_type, "__annotations__",
                                  Add_annotations) == 0;
    if (!cond) {
        Py_DECREF(Add_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Add_type, "_field_types",
                                  Add_annotations) == 0;
    if (!cond) {
        Py_DECREF(Add_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Add_type, "__annotations__",
                                  Add_annotations) == 0;
    if (!cond) {
        Py_DECREF(Add_annotations);
        return 0;
    }
    Py_DECREF(Add_annotations);
    PyObject *Sub_annotations = PyDict_New();
    if (!Sub_annotations) return 0;
    cond = PyObject_SetAttrString(state->Sub_type, "_field_types",
                                  Sub_annotations) == 0;
    if (!cond) {
        Py_DECREF(Sub_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Sub_type, "__annotations__",
                                  Sub_annotations) == 0;
    if (!cond) {
        Py_DECREF(Sub_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Sub_type, "_field_types",
                                  Sub_annotations) == 0;
    if (!cond) {
        Py_DECREF(Sub_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Sub_type, "__annotations__",
                                  Sub_annotations) == 0;
    if (!cond) {
        Py_DECREF(Sub_annotations);
        return 0;
    }
    Py_DECREF(Sub_annotations);
    PyObject *Mult_annotations = PyDict_New();
    if (!Mult_annotations) return 0;
    cond = PyObject_SetAttrString(state->Mult_type, "_field_types",
                                  Mult_annotations) == 0;
    if (!cond) {
        Py_DECREF(Mult_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Mult_type, "__annotations__",
                                  Mult_annotations) == 0;
    if (!cond) {
        Py_DECREF(Mult_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Mult_type, "_field_types",
                                  Mult_annotations) == 0;
    if (!cond) {
        Py_DECREF(Mult_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Mult_type, "__annotations__",
                                  Mult_annotations) == 0;
    if (!cond) {
        Py_DECREF(Mult_annotations);
        return 0;
    }
    Py_DECREF(Mult_annotations);
    PyObject *MatMult_annotations = PyDict_New();
    if (!MatMult_annotations) return 0;
    cond = PyObject_SetAttrString(state->MatMult_type, "_field_types",
                                  MatMult_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatMult_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->MatMult_type, "__annotations__",
                                  MatMult_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatMult_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatMult_type, "_field_types",
                                  MatMult_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatMult_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatMult_type, "__annotations__",
                                  MatMult_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatMult_annotations);
        return 0;
    }
    Py_DECREF(MatMult_annotations);
    PyObject *Div_annotations = PyDict_New();
    if (!Div_annotations) return 0;
    cond = PyObject_SetAttrString(state->Div_type, "_field_types",
                                  Div_annotations) == 0;
    if (!cond) {
        Py_DECREF(Div_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Div_type, "__annotations__",
                                  Div_annotations) == 0;
    if (!cond) {
        Py_DECREF(Div_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Div_type, "_field_types",
                                  Div_annotations) == 0;
    if (!cond) {
        Py_DECREF(Div_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Div_type, "__annotations__",
                                  Div_annotations) == 0;
    if (!cond) {
        Py_DECREF(Div_annotations);
        return 0;
    }
    Py_DECREF(Div_annotations);
    PyObject *Mod_annotations = PyDict_New();
    if (!Mod_annotations) return 0;
    cond = PyObject_SetAttrString(state->Mod_type, "_field_types",
                                  Mod_annotations) == 0;
    if (!cond) {
        Py_DECREF(Mod_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Mod_type, "__annotations__",
                                  Mod_annotations) == 0;
    if (!cond) {
        Py_DECREF(Mod_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Mod_type, "_field_types",
                                  Mod_annotations) == 0;
    if (!cond) {
        Py_DECREF(Mod_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Mod_type, "__annotations__",
                                  Mod_annotations) == 0;
    if (!cond) {
        Py_DECREF(Mod_annotations);
        return 0;
    }
    Py_DECREF(Mod_annotations);
    PyObject *Pow_annotations = PyDict_New();
    if (!Pow_annotations) return 0;
    cond = PyObject_SetAttrString(state->Pow_type, "_field_types",
                                  Pow_annotations) == 0;
    if (!cond) {
        Py_DECREF(Pow_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Pow_type, "__annotations__",
                                  Pow_annotations) == 0;
    if (!cond) {
        Py_DECREF(Pow_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Pow_type, "_field_types",
                                  Pow_annotations) == 0;
    if (!cond) {
        Py_DECREF(Pow_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Pow_type, "__annotations__",
                                  Pow_annotations) == 0;
    if (!cond) {
        Py_DECREF(Pow_annotations);
        return 0;
    }
    Py_DECREF(Pow_annotations);
    PyObject *LShift_annotations = PyDict_New();
    if (!LShift_annotations) return 0;
    cond = PyObject_SetAttrString(state->LShift_type, "_field_types",
                                  LShift_annotations) == 0;
    if (!cond) {
        Py_DECREF(LShift_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->LShift_type, "__annotations__",
                                  LShift_annotations) == 0;
    if (!cond) {
        Py_DECREF(LShift_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_LShift_type, "_field_types",
                                  LShift_annotations) == 0;
    if (!cond) {
        Py_DECREF(LShift_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_LShift_type, "__annotations__",
                                  LShift_annotations) == 0;
    if (!cond) {
        Py_DECREF(LShift_annotations);
        return 0;
    }
    Py_DECREF(LShift_annotations);
    PyObject *RShift_annotations = PyDict_New();
    if (!RShift_annotations) return 0;
    cond = PyObject_SetAttrString(state->RShift_type, "_field_types",
                                  RShift_annotations) == 0;
    if (!cond) {
        Py_DECREF(RShift_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->RShift_type, "__annotations__",
                                  RShift_annotations) == 0;
    if (!cond) {
        Py_DECREF(RShift_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_RShift_type, "_field_types",
                                  RShift_annotations) == 0;
    if (!cond) {
        Py_DECREF(RShift_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_RShift_type, "__annotations__",
                                  RShift_annotations) == 0;
    if (!cond) {
        Py_DECREF(RShift_annotations);
        return 0;
    }
    Py_DECREF(RShift_annotations);
    PyObject *BitOr_annotations = PyDict_New();
    if (!BitOr_annotations) return 0;
    cond = PyObject_SetAttrString(state->BitOr_type, "_field_types",
                                  BitOr_annotations) == 0;
    if (!cond) {
        Py_DECREF(BitOr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->BitOr_type, "__annotations__",
                                  BitOr_annotations) == 0;
    if (!cond) {
        Py_DECREF(BitOr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_BitOr_type, "_field_types",
                                  BitOr_annotations) == 0;
    if (!cond) {
        Py_DECREF(BitOr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_BitOr_type, "__annotations__",
                                  BitOr_annotations) == 0;
    if (!cond) {
        Py_DECREF(BitOr_annotations);
        return 0;
    }
    Py_DECREF(BitOr_annotations);
    PyObject *BitXor_annotations = PyDict_New();
    if (!BitXor_annotations) return 0;
    cond = PyObject_SetAttrString(state->BitXor_type, "_field_types",
                                  BitXor_annotations) == 0;
    if (!cond) {
        Py_DECREF(BitXor_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->BitXor_type, "__annotations__",
                                  BitXor_annotations) == 0;
    if (!cond) {
        Py_DECREF(BitXor_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_BitXor_type, "_field_types",
                                  BitXor_annotations) == 0;
    if (!cond) {
        Py_DECREF(BitXor_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_BitXor_type, "__annotations__",
                                  BitXor_annotations) == 0;
    if (!cond) {
        Py_DECREF(BitXor_annotations);
        return 0;
    }
    Py_DECREF(BitXor_annotations);
    PyObject *BitAnd_annotations = PyDict_New();
    if (!BitAnd_annotations) return 0;
    cond = PyObject_SetAttrString(state->BitAnd_type, "_field_types",
                                  BitAnd_annotations) == 0;
    if (!cond) {
        Py_DECREF(BitAnd_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->BitAnd_type, "__annotations__",
                                  BitAnd_annotations) == 0;
    if (!cond) {
        Py_DECREF(BitAnd_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_BitAnd_type, "_field_types",
                                  BitAnd_annotations) == 0;
    if (!cond) {
        Py_DECREF(BitAnd_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_BitAnd_type, "__annotations__",
                                  BitAnd_annotations) == 0;
    if (!cond) {
        Py_DECREF(BitAnd_annotations);
        return 0;
    }
    Py_DECREF(BitAnd_annotations);
    PyObject *FloorDiv_annotations = PyDict_New();
    if (!FloorDiv_annotations) return 0;
    cond = PyObject_SetAttrString(state->FloorDiv_type, "_field_types",
                                  FloorDiv_annotations) == 0;
    if (!cond) {
        Py_DECREF(FloorDiv_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->FloorDiv_type, "__annotations__",
                                  FloorDiv_annotations) == 0;
    if (!cond) {
        Py_DECREF(FloorDiv_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_FloorDiv_type, "_field_types",
                                  FloorDiv_annotations) == 0;
    if (!cond) {
        Py_DECREF(FloorDiv_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_FloorDiv_type, "__annotations__",
                                  FloorDiv_annotations) == 0;
    if (!cond) {
        Py_DECREF(FloorDiv_annotations);
        return 0;
    }
    Py_DECREF(FloorDiv_annotations);
    PyObject *Invert_annotations = PyDict_New();
    if (!Invert_annotations) return 0;
    cond = PyObject_SetAttrString(state->Invert_type, "_field_types",
                                  Invert_annotations) == 0;
    if (!cond) {
        Py_DECREF(Invert_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Invert_type, "__annotations__",
                                  Invert_annotations) == 0;
    if (!cond) {
        Py_DECREF(Invert_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Invert_type, "_field_types",
                                  Invert_annotations) == 0;
    if (!cond) {
        Py_DECREF(Invert_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Invert_type, "__annotations__",
                                  Invert_annotations) == 0;
    if (!cond) {
        Py_DECREF(Invert_annotations);
        return 0;
    }
    Py_DECREF(Invert_annotations);
    PyObject *Not_annotations = PyDict_New();
    if (!Not_annotations) return 0;
    cond = PyObject_SetAttrString(state->Not_type, "_field_types",
                                  Not_annotations) == 0;
    if (!cond) {
        Py_DECREF(Not_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Not_type, "__annotations__",
                                  Not_annotations) == 0;
    if (!cond) {
        Py_DECREF(Not_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Not_type, "_field_types",
                                  Not_annotations) == 0;
    if (!cond) {
        Py_DECREF(Not_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Not_type, "__annotations__",
                                  Not_annotations) == 0;
    if (!cond) {
        Py_DECREF(Not_annotations);
        return 0;
    }
    Py_DECREF(Not_annotations);
    PyObject *UAdd_annotations = PyDict_New();
    if (!UAdd_annotations) return 0;
    cond = PyObject_SetAttrString(state->UAdd_type, "_field_types",
                                  UAdd_annotations) == 0;
    if (!cond) {
        Py_DECREF(UAdd_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->UAdd_type, "__annotations__",
                                  UAdd_annotations) == 0;
    if (!cond) {
        Py_DECREF(UAdd_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_UAdd_type, "_field_types",
                                  UAdd_annotations) == 0;
    if (!cond) {
        Py_DECREF(UAdd_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_UAdd_type, "__annotations__",
                                  UAdd_annotations) == 0;
    if (!cond) {
        Py_DECREF(UAdd_annotations);
        return 0;
    }
    Py_DECREF(UAdd_annotations);
    PyObject *USub_annotations = PyDict_New();
    if (!USub_annotations) return 0;
    cond = PyObject_SetAttrString(state->USub_type, "_field_types",
                                  USub_annotations) == 0;
    if (!cond) {
        Py_DECREF(USub_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->USub_type, "__annotations__",
                                  USub_annotations) == 0;
    if (!cond) {
        Py_DECREF(USub_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_USub_type, "_field_types",
                                  USub_annotations) == 0;
    if (!cond) {
        Py_DECREF(USub_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_USub_type, "__annotations__",
                                  USub_annotations) == 0;
    if (!cond) {
        Py_DECREF(USub_annotations);
        return 0;
    }
    Py_DECREF(USub_annotations);
    PyObject *Eq_annotations = PyDict_New();
    if (!Eq_annotations) return 0;
    cond = PyObject_SetAttrString(state->Eq_type, "_field_types",
                                  Eq_annotations) == 0;
    if (!cond) {
        Py_DECREF(Eq_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Eq_type, "__annotations__",
                                  Eq_annotations) == 0;
    if (!cond) {
        Py_DECREF(Eq_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Eq_type, "_field_types",
                                  Eq_annotations) == 0;
    if (!cond) {
        Py_DECREF(Eq_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Eq_type, "__annotations__",
                                  Eq_annotations) == 0;
    if (!cond) {
        Py_DECREF(Eq_annotations);
        return 0;
    }
    Py_DECREF(Eq_annotations);
    PyObject *NotEq_annotations = PyDict_New();
    if (!NotEq_annotations) return 0;
    cond = PyObject_SetAttrString(state->NotEq_type, "_field_types",
                                  NotEq_annotations) == 0;
    if (!cond) {
        Py_DECREF(NotEq_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->NotEq_type, "__annotations__",
                                  NotEq_annotations) == 0;
    if (!cond) {
        Py_DECREF(NotEq_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_NotEq_type, "_field_types",
                                  NotEq_annotations) == 0;
    if (!cond) {
        Py_DECREF(NotEq_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_NotEq_type, "__annotations__",
                                  NotEq_annotations) == 0;
    if (!cond) {
        Py_DECREF(NotEq_annotations);
        return 0;
    }
    Py_DECREF(NotEq_annotations);
    PyObject *Lt_annotations = PyDict_New();
    if (!Lt_annotations) return 0;
    cond = PyObject_SetAttrString(state->Lt_type, "_field_types",
                                  Lt_annotations) == 0;
    if (!cond) {
        Py_DECREF(Lt_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Lt_type, "__annotations__",
                                  Lt_annotations) == 0;
    if (!cond) {
        Py_DECREF(Lt_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Lt_type, "_field_types",
                                  Lt_annotations) == 0;
    if (!cond) {
        Py_DECREF(Lt_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Lt_type, "__annotations__",
                                  Lt_annotations) == 0;
    if (!cond) {
        Py_DECREF(Lt_annotations);
        return 0;
    }
    Py_DECREF(Lt_annotations);
    PyObject *LtE_annotations = PyDict_New();
    if (!LtE_annotations) return 0;
    cond = PyObject_SetAttrString(state->LtE_type, "_field_types",
                                  LtE_annotations) == 0;
    if (!cond) {
        Py_DECREF(LtE_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->LtE_type, "__annotations__",
                                  LtE_annotations) == 0;
    if (!cond) {
        Py_DECREF(LtE_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_LtE_type, "_field_types",
                                  LtE_annotations) == 0;
    if (!cond) {
        Py_DECREF(LtE_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_LtE_type, "__annotations__",
                                  LtE_annotations) == 0;
    if (!cond) {
        Py_DECREF(LtE_annotations);
        return 0;
    }
    Py_DECREF(LtE_annotations);
    PyObject *Gt_annotations = PyDict_New();
    if (!Gt_annotations) return 0;
    cond = PyObject_SetAttrString(state->Gt_type, "_field_types",
                                  Gt_annotations) == 0;
    if (!cond) {
        Py_DECREF(Gt_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Gt_type, "__annotations__",
                                  Gt_annotations) == 0;
    if (!cond) {
        Py_DECREF(Gt_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Gt_type, "_field_types",
                                  Gt_annotations) == 0;
    if (!cond) {
        Py_DECREF(Gt_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Gt_type, "__annotations__",
                                  Gt_annotations) == 0;
    if (!cond) {
        Py_DECREF(Gt_annotations);
        return 0;
    }
    Py_DECREF(Gt_annotations);
    PyObject *GtE_annotations = PyDict_New();
    if (!GtE_annotations) return 0;
    cond = PyObject_SetAttrString(state->GtE_type, "_field_types",
                                  GtE_annotations) == 0;
    if (!cond) {
        Py_DECREF(GtE_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->GtE_type, "__annotations__",
                                  GtE_annotations) == 0;
    if (!cond) {
        Py_DECREF(GtE_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_GtE_type, "_field_types",
                                  GtE_annotations) == 0;
    if (!cond) {
        Py_DECREF(GtE_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_GtE_type, "__annotations__",
                                  GtE_annotations) == 0;
    if (!cond) {
        Py_DECREF(GtE_annotations);
        return 0;
    }
    Py_DECREF(GtE_annotations);
    PyObject *Is_annotations = PyDict_New();
    if (!Is_annotations) return 0;
    cond = PyObject_SetAttrString(state->Is_type, "_field_types",
                                  Is_annotations) == 0;
    if (!cond) {
        Py_DECREF(Is_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->Is_type, "__annotations__",
                                  Is_annotations) == 0;
    if (!cond) {
        Py_DECREF(Is_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Is_type, "_field_types",
                                  Is_annotations) == 0;
    if (!cond) {
        Py_DECREF(Is_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_Is_type, "__annotations__",
                                  Is_annotations) == 0;
    if (!cond) {
        Py_DECREF(Is_annotations);
        return 0;
    }
    Py_DECREF(Is_annotations);
    PyObject *IsNot_annotations = PyDict_New();
    if (!IsNot_annotations) return 0;
    cond = PyObject_SetAttrString(state->IsNot_type, "_field_types",
                                  IsNot_annotations) == 0;
    if (!cond) {
        Py_DECREF(IsNot_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->IsNot_type, "__annotations__",
                                  IsNot_annotations) == 0;
    if (!cond) {
        Py_DECREF(IsNot_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_IsNot_type, "_field_types",
                                  IsNot_annotations) == 0;
    if (!cond) {
        Py_DECREF(IsNot_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_IsNot_type, "__annotations__",
                                  IsNot_annotations) == 0;
    if (!cond) {
        Py_DECREF(IsNot_annotations);
        return 0;
    }
    Py_DECREF(IsNot_annotations);
    PyObject *In_annotations = PyDict_New();
    if (!In_annotations) return 0;
    cond = PyObject_SetAttrString(state->In_type, "_field_types",
                                  In_annotations) == 0;
    if (!cond) {
        Py_DECREF(In_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->In_type, "__annotations__",
                                  In_annotations) == 0;
    if (!cond) {
        Py_DECREF(In_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_In_type, "_field_types",
                                  In_annotations) == 0;
    if (!cond) {
        Py_DECREF(In_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_In_type, "__annotations__",
                                  In_annotations) == 0;
    if (!cond) {
        Py_DECREF(In_annotations);
        return 0;
    }
    Py_DECREF(In_annotations);
    PyObject *NotIn_annotations = PyDict_New();
    if (!NotIn_annotations) return 0;
    cond = PyObject_SetAttrString(state->NotIn_type, "_field_types",
                                  NotIn_annotations) == 0;
    if (!cond) {
        Py_DECREF(NotIn_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->NotIn_type, "__annotations__",
                                  NotIn_annotations) == 0;
    if (!cond) {
        Py_DECREF(NotIn_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_NotIn_type, "_field_types",
                                  NotIn_annotations) == 0;
    if (!cond) {
        Py_DECREF(NotIn_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_NotIn_type, "__annotations__",
                                  NotIn_annotations) == 0;
    if (!cond) {
        Py_DECREF(NotIn_annotations);
        return 0;
    }
    Py_DECREF(NotIn_annotations);
    PyObject *comprehension_annotations = PyDict_New();
    if (!comprehension_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(comprehension_annotations, "target", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(comprehension_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(comprehension_annotations, "iter", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(comprehension_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(comprehension_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(comprehension_annotations, "ifs", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(comprehension_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyLong_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(comprehension_annotations, "is_async",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(comprehension_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->comprehension_type, "_field_types",
                                  comprehension_annotations) == 0;
    if (!cond) {
        Py_DECREF(comprehension_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->comprehension_type, "__annotations__",
                                  comprehension_annotations) == 0;
    if (!cond) {
        Py_DECREF(comprehension_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_comprehension_type, "_field_types",
                                  comprehension_annotations) == 0;
    if (!cond) {
        Py_DECREF(comprehension_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_comprehension_type,
                                  "__annotations__", comprehension_annotations)
                                  == 0;
    if (!cond) {
        Py_DECREF(comprehension_annotations);
        return 0;
    }
    Py_DECREF(comprehension_annotations);
    PyObject *ExceptHandler_annotations = PyDict_New();
    if (!ExceptHandler_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(ExceptHandler_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(ExceptHandler_annotations, "type", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ExceptHandler_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(ExceptHandler_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(ExceptHandler_annotations, "name", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ExceptHandler_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(ExceptHandler_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(ExceptHandler_annotations, "body", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ExceptHandler_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->ExceptHandler_type, "_field_types",
                                  ExceptHandler_annotations) == 0;
    if (!cond) {
        Py_DECREF(ExceptHandler_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->ExceptHandler_type, "__annotations__",
                                  ExceptHandler_annotations) == 0;
    if (!cond) {
        Py_DECREF(ExceptHandler_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_ExceptHandler_type, "_field_types",
                                  ExceptHandler_annotations) == 0;
    if (!cond) {
        Py_DECREF(ExceptHandler_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_ExceptHandler_type,
                                  "__annotations__", ExceptHandler_annotations)
                                  == 0;
    if (!cond) {
        Py_DECREF(ExceptHandler_annotations);
        return 0;
    }
    Py_DECREF(ExceptHandler_annotations);
    PyObject *arguments_annotations = PyDict_New();
    if (!arguments_annotations) return 0;
    {
        PyObject *type = state->arg_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(arguments_annotations, "posonlyargs", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->arg_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(arguments_annotations, "args", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->arg_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(arguments_annotations, "vararg", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->arg_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(arguments_annotations, "kwonlyargs", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(arguments_annotations, "kw_defaults", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->arg_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(arguments_annotations, "kwarg", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(arguments_annotations, "defaults", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(arguments_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->arguments_type, "_field_types",
                                  arguments_annotations) == 0;
    if (!cond) {
        Py_DECREF(arguments_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->arguments_type, "__annotations__",
                                  arguments_annotations) == 0;
    if (!cond) {
        Py_DECREF(arguments_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_arguments_type, "_field_types",
                                  arguments_annotations) == 0;
    if (!cond) {
        Py_DECREF(arguments_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_arguments_type, "__annotations__",
                                  arguments_annotations) == 0;
    if (!cond) {
        Py_DECREF(arguments_annotations);
        return 0;
    }
    Py_DECREF(arguments_annotations);
    PyObject *arg_annotations = PyDict_New();
    if (!arg_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(arg_annotations, "arg", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(arg_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(arg_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(arg_annotations, "annotation", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(arg_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(arg_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(arg_annotations, "type_comment", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(arg_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->arg_type, "_field_types",
                                  arg_annotations) == 0;
    if (!cond) {
        Py_DECREF(arg_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->arg_type, "__annotations__",
                                  arg_annotations) == 0;
    if (!cond) {
        Py_DECREF(arg_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_arg_type, "_field_types",
                                  arg_annotations) == 0;
    if (!cond) {
        Py_DECREF(arg_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_arg_type, "__annotations__",
                                  arg_annotations) == 0;
    if (!cond) {
        Py_DECREF(arg_annotations);
        return 0;
    }
    Py_DECREF(arg_annotations);
    PyObject *keyword_annotations = PyDict_New();
    if (!keyword_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(keyword_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(keyword_annotations, "arg", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(keyword_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(keyword_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(keyword_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->keyword_type, "_field_types",
                                  keyword_annotations) == 0;
    if (!cond) {
        Py_DECREF(keyword_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->keyword_type, "__annotations__",
                                  keyword_annotations) == 0;
    if (!cond) {
        Py_DECREF(keyword_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_keyword_type, "_field_types",
                                  keyword_annotations) == 0;
    if (!cond) {
        Py_DECREF(keyword_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_keyword_type, "__annotations__",
                                  keyword_annotations) == 0;
    if (!cond) {
        Py_DECREF(keyword_annotations);
        return 0;
    }
    Py_DECREF(keyword_annotations);
    PyObject *alias_annotations = PyDict_New();
    if (!alias_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(alias_annotations, "name", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(alias_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(alias_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(alias_annotations, "asname", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(alias_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->alias_type, "_field_types",
                                  alias_annotations) == 0;
    if (!cond) {
        Py_DECREF(alias_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->alias_type, "__annotations__",
                                  alias_annotations) == 0;
    if (!cond) {
        Py_DECREF(alias_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_alias_type, "_field_types",
                                  alias_annotations) == 0;
    if (!cond) {
        Py_DECREF(alias_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_alias_type, "__annotations__",
                                  alias_annotations) == 0;
    if (!cond) {
        Py_DECREF(alias_annotations);
        return 0;
    }
    Py_DECREF(alias_annotations);
    PyObject *withitem_annotations = PyDict_New();
    if (!withitem_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(withitem_annotations, "context_expr", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(withitem_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(withitem_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(withitem_annotations, "optional_vars",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(withitem_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->withitem_type, "_field_types",
                                  withitem_annotations) == 0;
    if (!cond) {
        Py_DECREF(withitem_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->withitem_type, "__annotations__",
                                  withitem_annotations) == 0;
    if (!cond) {
        Py_DECREF(withitem_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_withitem_type, "_field_types",
                                  withitem_annotations) == 0;
    if (!cond) {
        Py_DECREF(withitem_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_withitem_type, "__annotations__",
                                  withitem_annotations) == 0;
    if (!cond) {
        Py_DECREF(withitem_annotations);
        return 0;
    }
    Py_DECREF(withitem_annotations);
    PyObject *match_case_annotations = PyDict_New();
    if (!match_case_annotations) return 0;
    {
        PyObject *type = state->pattern_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(match_case_annotations, "pattern", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(match_case_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(match_case_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(match_case_annotations, "guard", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(match_case_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->stmt_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(match_case_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(match_case_annotations, "body", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(match_case_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->match_case_type, "_field_types",
                                  match_case_annotations) == 0;
    if (!cond) {
        Py_DECREF(match_case_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->match_case_type, "__annotations__",
                                  match_case_annotations) == 0;
    if (!cond) {
        Py_DECREF(match_case_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_match_case_type, "_field_types",
                                  match_case_annotations) == 0;
    if (!cond) {
        Py_DECREF(match_case_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_match_case_type, "__annotations__",
                                  match_case_annotations) == 0;
    if (!cond) {
        Py_DECREF(match_case_annotations);
        return 0;
    }
    Py_DECREF(match_case_annotations);
    PyObject *MatchValue_annotations = PyDict_New();
    if (!MatchValue_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(MatchValue_annotations, "value", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchValue_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->MatchValue_type, "_field_types",
                                  MatchValue_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchValue_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->MatchValue_type, "__annotations__",
                                  MatchValue_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchValue_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchValue_type, "_field_types",
                                  MatchValue_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchValue_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchValue_type, "__annotations__",
                                  MatchValue_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchValue_annotations);
        return 0;
    }
    Py_DECREF(MatchValue_annotations);
    PyObject *MatchSingleton_annotations = PyDict_New();
    if (!MatchSingleton_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyBaseObject_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(MatchSingleton_annotations, "value", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchSingleton_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->MatchSingleton_type, "_field_types",
                                  MatchSingleton_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchSingleton_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->MatchSingleton_type,
                                  "__annotations__",
                                  MatchSingleton_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchSingleton_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchSingleton_type, "_field_types",
                                  MatchSingleton_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchSingleton_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchSingleton_type,
                                  "__annotations__",
                                  MatchSingleton_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchSingleton_annotations);
        return 0;
    }
    Py_DECREF(MatchSingleton_annotations);
    PyObject *MatchSequence_annotations = PyDict_New();
    if (!MatchSequence_annotations) return 0;
    {
        PyObject *type = state->pattern_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(MatchSequence_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(MatchSequence_annotations, "patterns",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchSequence_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->MatchSequence_type, "_field_types",
                                  MatchSequence_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchSequence_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->MatchSequence_type, "__annotations__",
                                  MatchSequence_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchSequence_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchSequence_type, "_field_types",
                                  MatchSequence_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchSequence_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchSequence_type,
                                  "__annotations__", MatchSequence_annotations)
                                  == 0;
    if (!cond) {
        Py_DECREF(MatchSequence_annotations);
        return 0;
    }
    Py_DECREF(MatchSequence_annotations);
    PyObject *MatchMapping_annotations = PyDict_New();
    if (!MatchMapping_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(MatchMapping_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(MatchMapping_annotations, "keys", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchMapping_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->pattern_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(MatchMapping_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(MatchMapping_annotations, "patterns", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchMapping_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(MatchMapping_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(MatchMapping_annotations, "rest", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchMapping_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->MatchMapping_type, "_field_types",
                                  MatchMapping_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchMapping_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->MatchMapping_type, "__annotations__",
                                  MatchMapping_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchMapping_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchMapping_type, "_field_types",
                                  MatchMapping_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchMapping_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchMapping_type, "__annotations__",
                                  MatchMapping_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchMapping_annotations);
        return 0;
    }
    Py_DECREF(MatchMapping_annotations);
    PyObject *MatchClass_annotations = PyDict_New();
    if (!MatchClass_annotations) return 0;
    {
        PyObject *type = state->expr_type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(MatchClass_annotations, "cls", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchClass_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->pattern_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(MatchClass_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(MatchClass_annotations, "patterns", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchClass_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(MatchClass_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(MatchClass_annotations, "kwd_attrs", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchClass_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->pattern_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(MatchClass_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(MatchClass_annotations, "kwd_patterns",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchClass_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->MatchClass_type, "_field_types",
                                  MatchClass_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchClass_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->MatchClass_type, "__annotations__",
                                  MatchClass_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchClass_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchClass_type, "_field_types",
                                  MatchClass_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchClass_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchClass_type, "__annotations__",
                                  MatchClass_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchClass_annotations);
        return 0;
    }
    Py_DECREF(MatchClass_annotations);
    PyObject *MatchStar_annotations = PyDict_New();
    if (!MatchStar_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(MatchStar_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(MatchStar_annotations, "name", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchStar_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->MatchStar_type, "_field_types",
                                  MatchStar_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchStar_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->MatchStar_type, "__annotations__",
                                  MatchStar_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchStar_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchStar_type, "_field_types",
                                  MatchStar_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchStar_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchStar_type, "__annotations__",
                                  MatchStar_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchStar_annotations);
        return 0;
    }
    Py_DECREF(MatchStar_annotations);
    PyObject *MatchAs_annotations = PyDict_New();
    if (!MatchAs_annotations) return 0;
    {
        PyObject *type = state->pattern_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(MatchAs_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(MatchAs_annotations, "pattern", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchAs_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(MatchAs_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(MatchAs_annotations, "name", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchAs_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->MatchAs_type, "_field_types",
                                  MatchAs_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchAs_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->MatchAs_type, "__annotations__",
                                  MatchAs_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchAs_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchAs_type, "_field_types",
                                  MatchAs_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchAs_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchAs_type, "__annotations__",
                                  MatchAs_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchAs_annotations);
        return 0;
    }
    Py_DECREF(MatchAs_annotations);
    PyObject *MatchOr_annotations = PyDict_New();
    if (!MatchOr_annotations) return 0;
    {
        PyObject *type = state->pattern_type;
        type = Py_GenericAlias((PyObject *)&PyList_Type, type);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(MatchOr_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(MatchOr_annotations, "patterns", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(MatchOr_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->MatchOr_type, "_field_types",
                                  MatchOr_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchOr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->MatchOr_type, "__annotations__",
                                  MatchOr_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchOr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchOr_type, "_field_types",
                                  MatchOr_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchOr_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_MatchOr_type, "__annotations__",
                                  MatchOr_annotations) == 0;
    if (!cond) {
        Py_DECREF(MatchOr_annotations);
        return 0;
    }
    Py_DECREF(MatchOr_annotations);
    PyObject *TypeIgnore_annotations = PyDict_New();
    if (!TypeIgnore_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyLong_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(TypeIgnore_annotations, "lineno", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TypeIgnore_annotations);
            return 0;
        }
    }
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(TypeIgnore_annotations, "tag", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TypeIgnore_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->TypeIgnore_type, "_field_types",
                                  TypeIgnore_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeIgnore_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->TypeIgnore_type, "__annotations__",
                                  TypeIgnore_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeIgnore_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_TypeIgnore_type, "_field_types",
                                  TypeIgnore_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeIgnore_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_TypeIgnore_type, "__annotations__",
                                  TypeIgnore_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeIgnore_annotations);
        return 0;
    }
    Py_DECREF(TypeIgnore_annotations);
    PyObject *TypeVar_annotations = PyDict_New();
    if (!TypeVar_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(TypeVar_annotations, "name", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TypeVar_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(TypeVar_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(TypeVar_annotations, "bound", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TypeVar_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(TypeVar_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(TypeVar_annotations, "default_value", type)
                                    == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TypeVar_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->TypeVar_type, "_field_types",
                                  TypeVar_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeVar_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->TypeVar_type, "__annotations__",
                                  TypeVar_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeVar_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_TypeVar_type, "_field_types",
                                  TypeVar_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeVar_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_TypeVar_type, "__annotations__",
                                  TypeVar_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeVar_annotations);
        return 0;
    }
    Py_DECREF(TypeVar_annotations);
    PyObject *ParamSpec_annotations = PyDict_New();
    if (!ParamSpec_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(ParamSpec_annotations, "name", type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ParamSpec_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(ParamSpec_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(ParamSpec_annotations, "default_value",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(ParamSpec_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->ParamSpec_type, "_field_types",
                                  ParamSpec_annotations) == 0;
    if (!cond) {
        Py_DECREF(ParamSpec_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->ParamSpec_type, "__annotations__",
                                  ParamSpec_annotations) == 0;
    if (!cond) {
        Py_DECREF(ParamSpec_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_ParamSpec_type, "_field_types",
                                  ParamSpec_annotations) == 0;
    if (!cond) {
        Py_DECREF(ParamSpec_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_ParamSpec_type, "__annotations__",
                                  ParamSpec_annotations) == 0;
    if (!cond) {
        Py_DECREF(ParamSpec_annotations);
        return 0;
    }
    Py_DECREF(ParamSpec_annotations);
    PyObject *TypeVarTuple_annotations = PyDict_New();
    if (!TypeVarTuple_annotations) return 0;
    {
        PyObject *type = (PyObject *)&PyUnicode_Type;
        Py_INCREF(type);
        cond = PyDict_SetItemString(TypeVarTuple_annotations, "name", type) ==
                                    0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TypeVarTuple_annotations);
            return 0;
        }
    }
    {
        PyObject *type = state->expr_type;
        type = _Py_union_type_or(type, Py_None);
        cond = type != NULL;
        if (!cond) {
            Py_DECREF(TypeVarTuple_annotations);
            return 0;
        }
        cond = PyDict_SetItemString(TypeVarTuple_annotations, "default_value",
                                    type) == 0;
        Py_DECREF(type);
        if (!cond) {
            Py_DECREF(TypeVarTuple_annotations);
            return 0;
        }
    }
    cond = PyObject_SetAttrString(state->TypeVarTuple_type, "_field_types",
                                  TypeVarTuple_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeVarTuple_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->TypeVarTuple_type, "__annotations__",
                                  TypeVarTuple_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeVarTuple_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_TypeVarTuple_type, "_field_types",
                                  TypeVarTuple_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeVarTuple_annotations);
        return 0;
    }
    cond = PyObject_SetAttrString(state->_TypeVarTuple_type, "__annotations__",
                                  TypeVarTuple_annotations) == 0;
    if (!cond) {
        Py_DECREF(TypeVarTuple_annotations);
        return 0;
    }
    Py_DECREF(TypeVarTuple_annotations);

    return 1;
}

static int obj2imm_int_seq(struct ast_state *state, PyObject* obj, const char
                           *container, const char *field, asdl_int_seq** out);
static int obj2imm_identifier_seq(struct ast_state *state, PyObject* obj, const
                                  char *container, const char *field,
                                  asdl_identifier_seq** out);
static int obj2imm_mod_seq(struct ast_state *state, PyObject* obj, const char
                           *container, const char *field, asdl_mod_seq** out);
static int obj2ast_mod(struct ast_state *state, PyObject* obj, mod_ty* out,
                       PyArena* arena);
static int obj2imm_mod(struct ast_state *state, PyObject* obj, mod_ty* out);
static int obj2imm_stmt_seq(struct ast_state *state, PyObject* obj, const char
                            *container, const char *field, asdl_stmt_seq** out);
static int obj2ast_stmt(struct ast_state *state, PyObject* obj, stmt_ty* out,
                        PyArena* arena);
static int obj2imm_stmt(struct ast_state *state, PyObject* obj, stmt_ty* out);
static int obj2imm_expr_seq(struct ast_state *state, PyObject* obj, const char
                            *container, const char *field, asdl_expr_seq** out);
static int obj2ast_expr(struct ast_state *state, PyObject* obj, expr_ty* out,
                        PyArena* arena);
static int obj2imm_expr(struct ast_state *state, PyObject* obj, expr_ty* out);
static int obj2imm_expr_context_seq(struct ast_state *state, PyObject* obj,
                                    const char *container, const char *field,
                                    asdl_int_seq** out);
static int obj2ast_expr_context(struct ast_state *state, PyObject* obj,
                                expr_context_ty* out, PyArena* arena);
static int obj2imm_expr_context(struct ast_state *state, PyObject* obj,
                                expr_context_ty* out);
static int obj2imm_boolop_seq(struct ast_state *state, PyObject* obj, const
                              char *container, const char *field,
                              asdl_int_seq** out);
static int obj2ast_boolop(struct ast_state *state, PyObject* obj, boolop_ty*
                          out, PyArena* arena);
static int obj2imm_boolop(struct ast_state *state, PyObject* obj, boolop_ty*
                          out);
static int obj2imm_operator_seq(struct ast_state *state, PyObject* obj, const
                                char *container, const char *field,
                                asdl_int_seq** out);
static int obj2ast_operator(struct ast_state *state, PyObject* obj,
                            operator_ty* out, PyArena* arena);
static int obj2imm_operator(struct ast_state *state, PyObject* obj,
                            operator_ty* out);
static int obj2imm_unaryop_seq(struct ast_state *state, PyObject* obj, const
                               char *container, const char *field,
                               asdl_int_seq** out);
static int obj2ast_unaryop(struct ast_state *state, PyObject* obj, unaryop_ty*
                           out, PyArena* arena);
static int obj2imm_unaryop(struct ast_state *state, PyObject* obj, unaryop_ty*
                           out);
static int obj2imm_cmpop_seq(struct ast_state *state, PyObject* obj, const char
                             *container, const char *field, asdl_int_seq** out);
static int obj2ast_cmpop(struct ast_state *state, PyObject* obj, cmpop_ty* out,
                         PyArena* arena);
static int obj2imm_cmpop(struct ast_state *state, PyObject* obj, cmpop_ty* out);
static int obj2imm_comprehension_seq(struct ast_state *state, PyObject* obj,
                                     const char *container, const char *field,
                                     asdl_comprehension_seq** out);
static int obj2ast_comprehension(struct ast_state *state, PyObject* obj,
                                 comprehension_ty* out, PyArena* arena);
static int obj2imm_comprehension(struct ast_state *state, PyObject* obj,
                                 comprehension_ty* out);
static int obj2imm_excepthandler_seq(struct ast_state *state, PyObject* obj,
                                     const char *container, const char *field,
                                     asdl_excepthandler_seq** out);
static int obj2ast_excepthandler(struct ast_state *state, PyObject* obj,
                                 excepthandler_ty* out, PyArena* arena);
static int obj2imm_excepthandler(struct ast_state *state, PyObject* obj,
                                 excepthandler_ty* out);
static int obj2imm_arguments_seq(struct ast_state *state, PyObject* obj, const
                                 char *container, const char *field,
                                 asdl_arguments_seq** out);
static int obj2ast_arguments(struct ast_state *state, PyObject* obj,
                             arguments_ty* out, PyArena* arena);
static int obj2imm_arguments(struct ast_state *state, PyObject* obj,
                             arguments_ty* out);
static int obj2imm_arg_seq(struct ast_state *state, PyObject* obj, const char
                           *container, const char *field, asdl_arg_seq** out);
static int obj2ast_arg(struct ast_state *state, PyObject* obj, arg_ty* out,
                       PyArena* arena);
static int obj2imm_arg(struct ast_state *state, PyObject* obj, arg_ty* out);
static int obj2imm_keyword_seq(struct ast_state *state, PyObject* obj, const
                               char *container, const char *field,
                               asdl_keyword_seq** out);
static int obj2ast_keyword(struct ast_state *state, PyObject* obj, keyword_ty*
                           out, PyArena* arena);
static int obj2imm_keyword(struct ast_state *state, PyObject* obj, keyword_ty*
                           out);
static int obj2imm_alias_seq(struct ast_state *state, PyObject* obj, const char
                             *container, const char *field, asdl_alias_seq**
                             out);
static int obj2ast_alias(struct ast_state *state, PyObject* obj, alias_ty* out,
                         PyArena* arena);
static int obj2imm_alias(struct ast_state *state, PyObject* obj, alias_ty* out);
static int obj2imm_withitem_seq(struct ast_state *state, PyObject* obj, const
                                char *container, const char *field,
                                asdl_withitem_seq** out);
static int obj2ast_withitem(struct ast_state *state, PyObject* obj,
                            withitem_ty* out, PyArena* arena);
static int obj2imm_withitem(struct ast_state *state, PyObject* obj,
                            withitem_ty* out);
static int obj2imm_match_case_seq(struct ast_state *state, PyObject* obj, const
                                  char *container, const char *field,
                                  asdl_match_case_seq** out);
static int obj2ast_match_case(struct ast_state *state, PyObject* obj,
                              match_case_ty* out, PyArena* arena);
static int obj2imm_match_case(struct ast_state *state, PyObject* obj,
                              match_case_ty* out);
static int obj2imm_pattern_seq(struct ast_state *state, PyObject* obj, const
                               char *container, const char *field,
                               asdl_pattern_seq** out);
static int obj2ast_pattern(struct ast_state *state, PyObject* obj, pattern_ty*
                           out, PyArena* arena);
static int obj2imm_pattern(struct ast_state *state, PyObject* obj, pattern_ty*
                           out);
static int obj2imm_type_ignore_seq(struct ast_state *state, PyObject* obj,
                                   const char *container, const char *field,
                                   asdl_type_ignore_seq** out);
static int obj2ast_type_ignore(struct ast_state *state, PyObject* obj,
                               type_ignore_ty* out, PyArena* arena);
static int obj2imm_type_ignore(struct ast_state *state, PyObject* obj,
                               type_ignore_ty* out);
static int obj2imm_type_param_seq(struct ast_state *state, PyObject* obj, const
                                  char *container, const char *field,
                                  asdl_type_param_seq** out);
static int obj2ast_type_param(struct ast_state *state, PyObject* obj,
                              type_param_ty* out, PyArena* arena);
static int obj2imm_type_param(struct ast_state *state, PyObject* obj,
                              type_param_ty* out);


static PyObject *ast_repr(PyObject *self);

static int
obj2imm_constant(struct ast_state *Py_UNUSED(state), PyObject* obj, PyObject **out)
{
    *out = Py_NewRef(obj);
    return 0;
}

static int
obj2imm_identifier(struct ast_state *Py_UNUSED(state), PyObject* obj, PyObject **out)
{
    *out = Py_NewRef(obj);
    return 0;
}

static int
obj2imm_string(struct ast_state *Py_UNUSED(state), PyObject* obj, PyObject **out)
{
    *out = Py_NewRef(obj);
    return 0;
}

static int
obj2imm_int(struct ast_state *Py_UNUSED(state), PyObject* obj, int *i)
{
    *i = PyLong_AsLong(obj);
    if (*i == -1 && PyErr_Occurred()) {
        return -1;
    }
    return 0;
}

#define ERROR_IF_NULL(x) if (x == NULL) goto error

static Py_ssize_t
ast_seq_len(asdl_seq *seq)
{
    return asdl_seq_LEN(seq);
}

static PyObject *
ast_seq_get(asdl_seq *seq, Py_ssize_t i)
{
    if (i >= asdl_seq_LEN(seq) || i < 0) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return NULL;
    }

    return Py_NewRef((PyObject *)asdl_seq_GET_UNTYPED(seq, i));
}

static int ast_seq_contains(asdl_seq *seq, PyObject *el)
{
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        PyObject *item = asdl_seq_GET_UNTYPED(seq, i);
        if (item == el) {
            return 1;
        }
        int cmp = PyObject_RichCompareBool(item, el, Py_EQ);
        if (cmp != 0) {
            return cmp;
        }
    }

    return 0;
}

static PyObject *
ast_class(PyObject *self, void* Py_UNUSED(unused))
{
    PyObject *res = PyObject_GetAttrString(self, "_mut_type");
    if (res != NULL) {
        return res;
    }
    return (PyObject *)Py_NewRef(Py_TYPE(self));
}

static PyGetSetDef ast_getsets[] = {
    {"__class__", ast_class, NULL, "Proxy for mutable __class__."}
};

static void int_seq_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_int_seq_type_slots[] = {
    {Py_tp_dealloc, &int_seq_dealloc},
    //{Py_tp_members, int_seq_members},
    {Py_tp_free, PyObject_Free},
    {0},
};

static PyType_Spec _int_seq_type_spec = {
    "ast._int_seq",
    sizeof(asdl_int_seq) - sizeof(int),
    sizeof(int),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_int_seq_type_slots
};

asdl_int_seq *_PyAst_int_seq_Copy(asdl_int_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_int_seq *res = PyObject_NewVar(asdl_int_seq, (PyTypeObject *)state->_int_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        res->typed_elements[i] = seq->typed_elements[i];
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static void identifier_seq_dealloc(PyObject *self) {
    asdl_identifier_seq *obj = (asdl_identifier_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_identifier_seq_type_slots[] = {
    {Py_tp_dealloc, &identifier_seq_dealloc},
    //{Py_tp_members, identifier_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _identifier_seq_type_spec = {
    "ast._identifier_seq",
    sizeof(asdl_identifier_seq) - sizeof(identifier),
    sizeof(identifier),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_identifier_seq_type_slots
};

asdl_identifier_seq *_PyAst_identifier_seq_Copy(asdl_identifier_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_identifier_seq *res = PyObject_NewVar(asdl_identifier_seq, (PyTypeObject *)state->_identifier_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] = Py_NewRef(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static void AST_dealloc(PyObject *self) {
    Py_TYPE(self)->tp_free(self);
}
static PyObject *
AST_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "AST takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _object *res = (struct _object*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    return (PyObject *)res;
fail:
    return NULL;
}

static PyMemberDef AST_members[] = {
    {0}
};

static PyType_Slot _AST_type_slots[] = {
    {Py_tp_dealloc, &AST_dealloc},
    {Py_tp_repr, ast_repr},
    {Py_tp_getset, ast_getsets},
    {Py_tp_members, AST_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, ""},
    {Py_tp_new, AST_new},
    {0, 0},
};

static PyType_Spec _AST_type_spec = {
    "ast._AST",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _AST_type_slots
};



static PyObject *
Module_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Module takes at most 2 positional arguments");
        return NULL;
    }
    asdl_stmt_seq* body = NULL;
    asdl_type_ignore_seq* type_ignores = NULL;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_type_ignore_seq(state, tmp, "Module", "type_ignores",
                &type_ignores) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_stmt_seq(state, tmp, "Module", "body", &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "Module", "body", &body) < 0) {
                    goto fail;
                }
            }
        }
        if (type_ignores != NULL) {
            err = PyDict_PopString(kwargs, "type_ignores", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_type_ignore_seq(state, tmp, "Module",
                    "type_ignores", &type_ignores) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _mod *res = (struct _mod*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Module.body = body;
    res->v.Module.type_ignores = type_ignores;
    return (PyObject *)res;
fail:
    Py_XDECREF(body);
    Py_XDECREF(type_ignores);
    return NULL;
}

static void Module_dealloc(PyObject *self) {
    mod_ty obj = (mod_ty)self;
    Py_XDECREF(obj->v.Module.body);
    Py_XDECREF(obj->v.Module.type_ignores);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Module_members[] = {
    {"body", _Py_T_OBJECT, offsetof(struct _mod, v.Module.body), Py_READONLY,
      NULL},
    {"type_ignores", _Py_T_OBJECT, offsetof(struct _mod,
      v.Module.type_ignores), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Module_type_slots[] = {
    {Py_tp_dealloc, &Module_dealloc},
    {Py_tp_members, Module_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Module(stmt* body, type_ignore* type_ignores)"},
    {Py_tp_new, Module_new},
    {0, 0},
};

static PyType_Spec _Module_type_spec = {
    "ast._Module",
    sizeof(struct _mod),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Module_type_slots
};



mod_ty _PyAst_Module_Copy(mod_ty self) {
    struct ast_state *state = get_ast_state();
    mod_ty res = PyObject_New(struct _mod, (PyTypeObject *)state->_Module_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Module.body != NULL) {
        res->v.Module.body = _PyAst_stmt_seq_Copy(self->v.Module.body);
        ERROR_IF_NULL(res->v.Module.body);
    } else {
        res->v.Module.body = NULL;
    }
    if (self->v.Module.type_ignores != NULL) {
        res->v.Module.type_ignores =
        _PyAst_type_ignore_seq_Copy(self->v.Module.type_ignores);
        ERROR_IF_NULL(res->v.Module.type_ignores);
    } else {
        res->v.Module.type_ignores = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Interactive_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "Interactive takes at most 1 positional argument");
        return NULL;
    }
    asdl_stmt_seq* body = NULL;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_stmt_seq(state, tmp, "Interactive", "body", &body) < 0)
                {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "Interactive", "body", &body)
                    < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _mod *res = (struct _mod*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Interactive.body = body;
    return (PyObject *)res;
fail:
    Py_XDECREF(body);
    return NULL;
}

static void Interactive_dealloc(PyObject *self) {
    mod_ty obj = (mod_ty)self;
    Py_XDECREF(obj->v.Interactive.body);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Interactive_members[] = {
    {"body", _Py_T_OBJECT, offsetof(struct _mod, v.Interactive.body),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Interactive_type_slots[] = {
    {Py_tp_dealloc, &Interactive_dealloc},
    {Py_tp_members, Interactive_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Interactive(stmt* body)"},
    {Py_tp_new, Interactive_new},
    {0, 0},
};

static PyType_Spec _Interactive_type_spec = {
    "ast._Interactive",
    sizeof(struct _mod),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Interactive_type_slots
};



mod_ty _PyAst_Interactive_Copy(mod_ty self) {
    struct ast_state *state = get_ast_state();
    mod_ty res = PyObject_New(struct _mod, (PyTypeObject
                              *)state->_Interactive_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Interactive.body != NULL) {
        res->v.Interactive.body =
        _PyAst_stmt_seq_Copy(self->v.Interactive.body);
        ERROR_IF_NULL(res->v.Interactive.body);
    } else {
        res->v.Interactive.body = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Expression_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "Expression takes at most 1 positional argument");
        return NULL;
    }
    expr_ty body = NULL;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &body) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _mod *res = (struct _mod*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Expression.body = body;
    return (PyObject *)res;
fail:
    Py_XDECREF(body);
    return NULL;
}

static void Expression_dealloc(PyObject *self) {
    mod_ty obj = (mod_ty)self;
    Py_XDECREF(obj->v.Expression.body);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Expression_members[] = {
    {"body", _Py_T_OBJECT, offsetof(struct _mod, v.Expression.body),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Expression_type_slots[] = {
    {Py_tp_dealloc, &Expression_dealloc},
    {Py_tp_members, Expression_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Expression(expr body)"},
    {Py_tp_new, Expression_new},
    {0, 0},
};

static PyType_Spec _Expression_type_spec = {
    "ast._Expression",
    sizeof(struct _mod),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Expression_type_slots
};



mod_ty _PyAst_Expression_Copy(mod_ty self) {
    struct ast_state *state = get_ast_state();
    mod_ty res = PyObject_New(struct _mod, (PyTypeObject
                              *)state->_Expression_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Expression.body != NULL) {
        res->v.Expression.body = _PyAst_expr_Copy(self->v.Expression.body);
        ERROR_IF_NULL(res->v.Expression.body);
    } else {
        res->v.Expression.body = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
FunctionType_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "FunctionType takes at most 2 positional arguments");
        return NULL;
    }
    asdl_expr_seq* argtypes = NULL;
    expr_ty returns = NULL;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &returns) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr_seq(state, tmp, "FunctionType", "argtypes",
                &argtypes) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (argtypes != NULL) {
            err = PyDict_PopString(kwargs, "argtypes", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "FunctionType", "argtypes",
                    &argtypes) < 0) {
                    goto fail;
                }
            }
        }
        if (returns != NULL) {
            err = PyDict_PopString(kwargs, "returns", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &returns) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _mod *res = (struct _mod*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.FunctionType.argtypes = argtypes;
    res->v.FunctionType.returns = returns;
    return (PyObject *)res;
fail:
    Py_XDECREF(argtypes);
    Py_XDECREF(returns);
    return NULL;
}

static void FunctionType_dealloc(PyObject *self) {
    mod_ty obj = (mod_ty)self;
    Py_XDECREF(obj->v.FunctionType.argtypes);
    Py_XDECREF(obj->v.FunctionType.returns);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef FunctionType_members[] = {
    {"argtypes", _Py_T_OBJECT, offsetof(struct _mod, v.FunctionType.argtypes),
      Py_READONLY, NULL},
    {"returns", _Py_T_OBJECT, offsetof(struct _mod, v.FunctionType.returns),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _FunctionType_type_slots[] = {
    {Py_tp_dealloc, &FunctionType_dealloc},
    {Py_tp_members, FunctionType_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "FunctionType(expr* argtypes, expr returns)"},
    {Py_tp_new, FunctionType_new},
    {0, 0},
};

static PyType_Spec _FunctionType_type_spec = {
    "ast._FunctionType",
    sizeof(struct _mod),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _FunctionType_type_slots
};



mod_ty _PyAst_FunctionType_Copy(mod_ty self) {
    struct ast_state *state = get_ast_state();
    mod_ty res = PyObject_New(struct _mod, (PyTypeObject
                              *)state->_FunctionType_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.FunctionType.argtypes != NULL) {
        res->v.FunctionType.argtypes =
        _PyAst_expr_seq_Copy(self->v.FunctionType.argtypes);
        ERROR_IF_NULL(res->v.FunctionType.argtypes);
    } else {
        res->v.FunctionType.argtypes = NULL;
    }
    if (self->v.FunctionType.returns != NULL) {
        res->v.FunctionType.returns =
        _PyAst_expr_Copy(self->v.FunctionType.returns);
        ERROR_IF_NULL(res->v.FunctionType.returns);
    } else {
        res->v.FunctionType.returns = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}


mod_ty _PyAst_mod_Copy(mod_ty node) {
    switch (node->kind) {
        case Module_kind:
            return _PyAst_Module_Copy(node);
        case Interactive_kind:
            return _PyAst_Interactive_Copy(node);
        case Expression_kind:
            return _PyAst_Expression_Copy(node);
        case FunctionType_kind:
            return _PyAst_FunctionType_Copy(node);
    }
    return NULL;
}

static PyObject *
mod_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "mod takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _mod *res = (struct _mod*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    return (PyObject *)res;
fail:
    return NULL;
}

static void mod_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef mod_members[] = {
    {0}
};

static PyType_Slot _mod_type_slots[] = {
    {Py_tp_dealloc, &mod_dealloc},
    {Py_tp_members, mod_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "mod = Module(stmt* body, type_ignore* type_ignores)\n"
        "    | Interactive(stmt* body)\n"
        "    | Expression(expr body)\n"
        "    | FunctionType(expr* argtypes, expr returns)"},
    {Py_tp_new, mod_new},
    {0, 0},
};

static PyType_Spec _mod_type_spec = {
    "ast._mod",
    sizeof(struct _mod),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _mod_type_slots
};



static void mod_seq_dealloc(PyObject *self) {
    asdl_mod_seq *obj = (asdl_mod_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_mod_seq_type_slots[] = {
    {Py_tp_dealloc, &mod_seq_dealloc},
    //{Py_tp_members, mod_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _mod_seq_type_spec = {
    "ast._mod_seq",
    sizeof(asdl_mod_seq) - sizeof(mod_ty),
    sizeof(mod_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_mod_seq_type_slots
};

asdl_mod_seq *_PyAst_mod_seq_Copy(asdl_mod_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_mod_seq *res = PyObject_NewVar(asdl_mod_seq, (PyTypeObject *)state->_mod_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] = _PyAst_mod_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
FunctionDef_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 7) {
        PyErr_SetString(PyExc_TypeError,
                        "FunctionDef takes at most 7 positional arguments");
        return NULL;
    }
    identifier name = NULL;
    arguments_ty args = NULL;
    asdl_stmt_seq* body = NULL;
    asdl_expr_seq* decorator_list = NULL;
    expr_ty returns = NULL;
    string type_comment = 0;
    asdl_type_param_seq* type_params = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 11: {
            tmp = PyTuple_GET_ITEM(pargs, 10);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 10: {
            tmp = PyTuple_GET_ITEM(pargs, 9);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 9: {
            tmp = PyTuple_GET_ITEM(pargs, 8);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 8: {
            tmp = PyTuple_GET_ITEM(pargs, 7);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_type_param_seq(state, tmp, "FunctionDef",
                "type_params", &type_params) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_string(state, tmp, &type_comment) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_expr(state, tmp, &returns) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_expr_seq(state, tmp, "FunctionDef", "decorator_list",
                &decorator_list) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_stmt_seq(state, tmp, "FunctionDef", "body", &body) < 0)
                {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_arguments(state, tmp, &args) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier(state, tmp, &name) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (name != NULL) {
            err = PyDict_PopString(kwargs, "name", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &name) < 0) {
                    goto fail;
                }
            }
        }
        if (args != NULL) {
            err = PyDict_PopString(kwargs, "args", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_arguments(state, tmp, &args) < 0) {
                    goto fail;
                }
            }
        }
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "FunctionDef", "body", &body)
                    < 0) {
                    goto fail;
                }
            }
        }
        if (decorator_list != NULL) {
            err = PyDict_PopString(kwargs, "decorator_list", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "FunctionDef",
                    "decorator_list", &decorator_list) < 0) {
                    goto fail;
                }
            }
        }
        if (returns != NULL) {
            err = PyDict_PopString(kwargs, "returns", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &returns) < 0) {
                    goto fail;
                }
            }
        }
        if (type_comment != NULL) {
            err = PyDict_PopString(kwargs, "type_comment", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_string(state, tmp, &type_comment) < 0) {
                    goto fail;
                }
            }
        }
        if (type_params != NULL) {
            err = PyDict_PopString(kwargs, "type_params", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_type_param_seq(state, tmp, "FunctionDef",
                    "type_params", &type_params) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.FunctionDef.name = name;
    res->v.FunctionDef.args = args;
    res->v.FunctionDef.body = body;
    res->v.FunctionDef.decorator_list = decorator_list;
    res->v.FunctionDef.returns = returns;
    res->v.FunctionDef.type_comment = type_comment;
    res->v.FunctionDef.type_params = type_params;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(name);
    Py_XDECREF(args);
    Py_XDECREF(body);
    Py_XDECREF(decorator_list);
    Py_XDECREF(returns);
    Py_XDECREF(type_comment);
    Py_XDECREF(type_params);
    return NULL;
}

static void FunctionDef_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.FunctionDef.name);
    Py_XDECREF(obj->v.FunctionDef.args);
    Py_XDECREF(obj->v.FunctionDef.body);
    Py_XDECREF(obj->v.FunctionDef.decorator_list);
    Py_XDECREF(obj->v.FunctionDef.returns);
    Py_XDECREF(obj->v.FunctionDef.type_comment);
    Py_XDECREF(obj->v.FunctionDef.type_params);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef FunctionDef_members[] = {
    {"name", _Py_T_OBJECT, offsetof(struct _stmt, v.FunctionDef.name),
      Py_READONLY, NULL},
    {"args", _Py_T_OBJECT, offsetof(struct _stmt, v.FunctionDef.args),
      Py_READONLY, NULL},
    {"body", _Py_T_OBJECT, offsetof(struct _stmt, v.FunctionDef.body),
      Py_READONLY, NULL},
    {"decorator_list", _Py_T_OBJECT, offsetof(struct _stmt,
      v.FunctionDef.decorator_list), Py_READONLY, NULL},
    {"returns", _Py_T_OBJECT, offsetof(struct _stmt, v.FunctionDef.returns),
      Py_READONLY, NULL},
    {"type_comment", _Py_T_OBJECT, offsetof(struct _stmt,
      v.FunctionDef.type_comment), Py_READONLY, NULL},
    {"type_params", _Py_T_OBJECT, offsetof(struct _stmt,
      v.FunctionDef.type_params), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _FunctionDef_type_slots[] = {
    {Py_tp_dealloc, &FunctionDef_dealloc},
    {Py_tp_members, FunctionDef_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment, type_param* type_params)"},
    {Py_tp_new, FunctionDef_new},
    {0, 0},
};

static PyType_Spec _FunctionDef_type_spec = {
    "ast._FunctionDef",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _FunctionDef_type_slots
};



stmt_ty _PyAst_FunctionDef_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_FunctionDef_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.FunctionDef.name != NULL) {
        res->v.FunctionDef.name = Py_NewRef(self->v.FunctionDef.name);
        ERROR_IF_NULL(res->v.FunctionDef.name);
    } else {
        res->v.FunctionDef.name = NULL;
    }
    if (self->v.FunctionDef.args != NULL) {
        res->v.FunctionDef.args =
        _PyAst_arguments_Copy(self->v.FunctionDef.args);
        ERROR_IF_NULL(res->v.FunctionDef.args);
    } else {
        res->v.FunctionDef.args = NULL;
    }
    if (self->v.FunctionDef.body != NULL) {
        res->v.FunctionDef.body =
        _PyAst_stmt_seq_Copy(self->v.FunctionDef.body);
        ERROR_IF_NULL(res->v.FunctionDef.body);
    } else {
        res->v.FunctionDef.body = NULL;
    }
    if (self->v.FunctionDef.decorator_list != NULL) {
        res->v.FunctionDef.decorator_list =
        _PyAst_expr_seq_Copy(self->v.FunctionDef.decorator_list);
        ERROR_IF_NULL(res->v.FunctionDef.decorator_list);
    } else {
        res->v.FunctionDef.decorator_list = NULL;
    }
    if (self->v.FunctionDef.returns != NULL) {
        res->v.FunctionDef.returns =
        _PyAst_expr_Copy(self->v.FunctionDef.returns);
        ERROR_IF_NULL(res->v.FunctionDef.returns);
    } else {
        res->v.FunctionDef.returns = NULL;
    }
    if (self->v.FunctionDef.type_comment != NULL) {
        res->v.FunctionDef.type_comment =
        Py_NewRef(self->v.FunctionDef.type_comment);
        ERROR_IF_NULL(res->v.FunctionDef.type_comment);
    } else {
        res->v.FunctionDef.type_comment = NULL;
    }
    if (self->v.FunctionDef.type_params != NULL) {
        res->v.FunctionDef.type_params =
        _PyAst_type_param_seq_Copy(self->v.FunctionDef.type_params);
        ERROR_IF_NULL(res->v.FunctionDef.type_params);
    } else {
        res->v.FunctionDef.type_params = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
AsyncFunctionDef_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 7) {
        PyErr_SetString(PyExc_TypeError,
                        "AsyncFunctionDef takes at most 7 positional arguments");
        return NULL;
    }
    identifier name = NULL;
    arguments_ty args = NULL;
    asdl_stmt_seq* body = NULL;
    asdl_expr_seq* decorator_list = NULL;
    expr_ty returns = NULL;
    string type_comment = 0;
    asdl_type_param_seq* type_params = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 11: {
            tmp = PyTuple_GET_ITEM(pargs, 10);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 10: {
            tmp = PyTuple_GET_ITEM(pargs, 9);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 9: {
            tmp = PyTuple_GET_ITEM(pargs, 8);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 8: {
            tmp = PyTuple_GET_ITEM(pargs, 7);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_type_param_seq(state, tmp, "AsyncFunctionDef",
                "type_params", &type_params) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_string(state, tmp, &type_comment) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_expr(state, tmp, &returns) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_expr_seq(state, tmp, "AsyncFunctionDef",
                "decorator_list", &decorator_list) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_stmt_seq(state, tmp, "AsyncFunctionDef", "body", &body)
                < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_arguments(state, tmp, &args) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier(state, tmp, &name) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (name != NULL) {
            err = PyDict_PopString(kwargs, "name", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &name) < 0) {
                    goto fail;
                }
            }
        }
        if (args != NULL) {
            err = PyDict_PopString(kwargs, "args", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_arguments(state, tmp, &args) < 0) {
                    goto fail;
                }
            }
        }
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "AsyncFunctionDef", "body",
                    &body) < 0) {
                    goto fail;
                }
            }
        }
        if (decorator_list != NULL) {
            err = PyDict_PopString(kwargs, "decorator_list", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "AsyncFunctionDef",
                    "decorator_list", &decorator_list) < 0) {
                    goto fail;
                }
            }
        }
        if (returns != NULL) {
            err = PyDict_PopString(kwargs, "returns", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &returns) < 0) {
                    goto fail;
                }
            }
        }
        if (type_comment != NULL) {
            err = PyDict_PopString(kwargs, "type_comment", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_string(state, tmp, &type_comment) < 0) {
                    goto fail;
                }
            }
        }
        if (type_params != NULL) {
            err = PyDict_PopString(kwargs, "type_params", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_type_param_seq(state, tmp, "AsyncFunctionDef",
                    "type_params", &type_params) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.AsyncFunctionDef.name = name;
    res->v.AsyncFunctionDef.args = args;
    res->v.AsyncFunctionDef.body = body;
    res->v.AsyncFunctionDef.decorator_list = decorator_list;
    res->v.AsyncFunctionDef.returns = returns;
    res->v.AsyncFunctionDef.type_comment = type_comment;
    res->v.AsyncFunctionDef.type_params = type_params;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(name);
    Py_XDECREF(args);
    Py_XDECREF(body);
    Py_XDECREF(decorator_list);
    Py_XDECREF(returns);
    Py_XDECREF(type_comment);
    Py_XDECREF(type_params);
    return NULL;
}

static void AsyncFunctionDef_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.AsyncFunctionDef.name);
    Py_XDECREF(obj->v.AsyncFunctionDef.args);
    Py_XDECREF(obj->v.AsyncFunctionDef.body);
    Py_XDECREF(obj->v.AsyncFunctionDef.decorator_list);
    Py_XDECREF(obj->v.AsyncFunctionDef.returns);
    Py_XDECREF(obj->v.AsyncFunctionDef.type_comment);
    Py_XDECREF(obj->v.AsyncFunctionDef.type_params);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef AsyncFunctionDef_members[] = {
    {"name", _Py_T_OBJECT, offsetof(struct _stmt, v.AsyncFunctionDef.name),
      Py_READONLY, NULL},
    {"args", _Py_T_OBJECT, offsetof(struct _stmt, v.AsyncFunctionDef.args),
      Py_READONLY, NULL},
    {"body", _Py_T_OBJECT, offsetof(struct _stmt, v.AsyncFunctionDef.body),
      Py_READONLY, NULL},
    {"decorator_list", _Py_T_OBJECT, offsetof(struct _stmt,
      v.AsyncFunctionDef.decorator_list), Py_READONLY, NULL},
    {"returns", _Py_T_OBJECT, offsetof(struct _stmt,
      v.AsyncFunctionDef.returns), Py_READONLY, NULL},
    {"type_comment", _Py_T_OBJECT, offsetof(struct _stmt,
      v.AsyncFunctionDef.type_comment), Py_READONLY, NULL},
    {"type_params", _Py_T_OBJECT, offsetof(struct _stmt,
      v.AsyncFunctionDef.type_params), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _AsyncFunctionDef_type_slots[] = {
    {Py_tp_dealloc, &AsyncFunctionDef_dealloc},
    {Py_tp_members, AsyncFunctionDef_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment, type_param* type_params)"},
    {Py_tp_new, AsyncFunctionDef_new},
    {0, 0},
};

static PyType_Spec _AsyncFunctionDef_type_spec = {
    "ast._AsyncFunctionDef",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _AsyncFunctionDef_type_slots
};



stmt_ty _PyAst_AsyncFunctionDef_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_AsyncFunctionDef_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.AsyncFunctionDef.name != NULL) {
        res->v.AsyncFunctionDef.name = Py_NewRef(self->v.AsyncFunctionDef.name);
        ERROR_IF_NULL(res->v.AsyncFunctionDef.name);
    } else {
        res->v.AsyncFunctionDef.name = NULL;
    }
    if (self->v.AsyncFunctionDef.args != NULL) {
        res->v.AsyncFunctionDef.args =
        _PyAst_arguments_Copy(self->v.AsyncFunctionDef.args);
        ERROR_IF_NULL(res->v.AsyncFunctionDef.args);
    } else {
        res->v.AsyncFunctionDef.args = NULL;
    }
    if (self->v.AsyncFunctionDef.body != NULL) {
        res->v.AsyncFunctionDef.body =
        _PyAst_stmt_seq_Copy(self->v.AsyncFunctionDef.body);
        ERROR_IF_NULL(res->v.AsyncFunctionDef.body);
    } else {
        res->v.AsyncFunctionDef.body = NULL;
    }
    if (self->v.AsyncFunctionDef.decorator_list != NULL) {
        res->v.AsyncFunctionDef.decorator_list =
        _PyAst_expr_seq_Copy(self->v.AsyncFunctionDef.decorator_list);
        ERROR_IF_NULL(res->v.AsyncFunctionDef.decorator_list);
    } else {
        res->v.AsyncFunctionDef.decorator_list = NULL;
    }
    if (self->v.AsyncFunctionDef.returns != NULL) {
        res->v.AsyncFunctionDef.returns =
        _PyAst_expr_Copy(self->v.AsyncFunctionDef.returns);
        ERROR_IF_NULL(res->v.AsyncFunctionDef.returns);
    } else {
        res->v.AsyncFunctionDef.returns = NULL;
    }
    if (self->v.AsyncFunctionDef.type_comment != NULL) {
        res->v.AsyncFunctionDef.type_comment =
        Py_NewRef(self->v.AsyncFunctionDef.type_comment);
        ERROR_IF_NULL(res->v.AsyncFunctionDef.type_comment);
    } else {
        res->v.AsyncFunctionDef.type_comment = NULL;
    }
    if (self->v.AsyncFunctionDef.type_params != NULL) {
        res->v.AsyncFunctionDef.type_params =
        _PyAst_type_param_seq_Copy(self->v.AsyncFunctionDef.type_params);
        ERROR_IF_NULL(res->v.AsyncFunctionDef.type_params);
    } else {
        res->v.AsyncFunctionDef.type_params = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
ClassDef_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 6) {
        PyErr_SetString(PyExc_TypeError,
                        "ClassDef takes at most 6 positional arguments");
        return NULL;
    }
    identifier name = NULL;
    asdl_expr_seq* bases = NULL;
    asdl_keyword_seq* keywords = NULL;
    asdl_stmt_seq* body = NULL;
    asdl_expr_seq* decorator_list = NULL;
    asdl_type_param_seq* type_params = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 10: {
            tmp = PyTuple_GET_ITEM(pargs, 9);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 9: {
            tmp = PyTuple_GET_ITEM(pargs, 8);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 8: {
            tmp = PyTuple_GET_ITEM(pargs, 7);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_type_param_seq(state, tmp, "ClassDef", "type_params",
                &type_params) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_expr_seq(state, tmp, "ClassDef", "decorator_list",
                &decorator_list) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_stmt_seq(state, tmp, "ClassDef", "body", &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_keyword_seq(state, tmp, "ClassDef", "keywords",
                &keywords) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr_seq(state, tmp, "ClassDef", "bases", &bases) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier(state, tmp, &name) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (name != NULL) {
            err = PyDict_PopString(kwargs, "name", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &name) < 0) {
                    goto fail;
                }
            }
        }
        if (bases != NULL) {
            err = PyDict_PopString(kwargs, "bases", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "ClassDef", "bases", &bases) <
                    0) {
                    goto fail;
                }
            }
        }
        if (keywords != NULL) {
            err = PyDict_PopString(kwargs, "keywords", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_keyword_seq(state, tmp, "ClassDef", "keywords",
                    &keywords) < 0) {
                    goto fail;
                }
            }
        }
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "ClassDef", "body", &body) <
                    0) {
                    goto fail;
                }
            }
        }
        if (decorator_list != NULL) {
            err = PyDict_PopString(kwargs, "decorator_list", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "ClassDef", "decorator_list",
                    &decorator_list) < 0) {
                    goto fail;
                }
            }
        }
        if (type_params != NULL) {
            err = PyDict_PopString(kwargs, "type_params", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_type_param_seq(state, tmp, "ClassDef",
                    "type_params", &type_params) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.ClassDef.name = name;
    res->v.ClassDef.bases = bases;
    res->v.ClassDef.keywords = keywords;
    res->v.ClassDef.body = body;
    res->v.ClassDef.decorator_list = decorator_list;
    res->v.ClassDef.type_params = type_params;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(name);
    Py_XDECREF(bases);
    Py_XDECREF(keywords);
    Py_XDECREF(body);
    Py_XDECREF(decorator_list);
    Py_XDECREF(type_params);
    return NULL;
}

static void ClassDef_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.ClassDef.name);
    Py_XDECREF(obj->v.ClassDef.bases);
    Py_XDECREF(obj->v.ClassDef.keywords);
    Py_XDECREF(obj->v.ClassDef.body);
    Py_XDECREF(obj->v.ClassDef.decorator_list);
    Py_XDECREF(obj->v.ClassDef.type_params);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef ClassDef_members[] = {
    {"name", _Py_T_OBJECT, offsetof(struct _stmt, v.ClassDef.name),
      Py_READONLY, NULL},
    {"bases", _Py_T_OBJECT, offsetof(struct _stmt, v.ClassDef.bases),
      Py_READONLY, NULL},
    {"keywords", _Py_T_OBJECT, offsetof(struct _stmt, v.ClassDef.keywords),
      Py_READONLY, NULL},
    {"body", _Py_T_OBJECT, offsetof(struct _stmt, v.ClassDef.body),
      Py_READONLY, NULL},
    {"decorator_list", _Py_T_OBJECT, offsetof(struct _stmt,
      v.ClassDef.decorator_list), Py_READONLY, NULL},
    {"type_params", _Py_T_OBJECT, offsetof(struct _stmt,
      v.ClassDef.type_params), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _ClassDef_type_slots[] = {
    {Py_tp_dealloc, &ClassDef_dealloc},
    {Py_tp_members, ClassDef_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list, type_param* type_params)"},
    {Py_tp_new, ClassDef_new},
    {0, 0},
};

static PyType_Spec _ClassDef_type_spec = {
    "ast._ClassDef",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _ClassDef_type_slots
};



stmt_ty _PyAst_ClassDef_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_ClassDef_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.ClassDef.name != NULL) {
        res->v.ClassDef.name = Py_NewRef(self->v.ClassDef.name);
        ERROR_IF_NULL(res->v.ClassDef.name);
    } else {
        res->v.ClassDef.name = NULL;
    }
    if (self->v.ClassDef.bases != NULL) {
        res->v.ClassDef.bases = _PyAst_expr_seq_Copy(self->v.ClassDef.bases);
        ERROR_IF_NULL(res->v.ClassDef.bases);
    } else {
        res->v.ClassDef.bases = NULL;
    }
    if (self->v.ClassDef.keywords != NULL) {
        res->v.ClassDef.keywords =
        _PyAst_keyword_seq_Copy(self->v.ClassDef.keywords);
        ERROR_IF_NULL(res->v.ClassDef.keywords);
    } else {
        res->v.ClassDef.keywords = NULL;
    }
    if (self->v.ClassDef.body != NULL) {
        res->v.ClassDef.body = _PyAst_stmt_seq_Copy(self->v.ClassDef.body);
        ERROR_IF_NULL(res->v.ClassDef.body);
    } else {
        res->v.ClassDef.body = NULL;
    }
    if (self->v.ClassDef.decorator_list != NULL) {
        res->v.ClassDef.decorator_list =
        _PyAst_expr_seq_Copy(self->v.ClassDef.decorator_list);
        ERROR_IF_NULL(res->v.ClassDef.decorator_list);
    } else {
        res->v.ClassDef.decorator_list = NULL;
    }
    if (self->v.ClassDef.type_params != NULL) {
        res->v.ClassDef.type_params =
        _PyAst_type_param_seq_Copy(self->v.ClassDef.type_params);
        ERROR_IF_NULL(res->v.ClassDef.type_params);
    } else {
        res->v.ClassDef.type_params = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Return_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "Return takes at most 1 positional argument");
        return NULL;
    }
    expr_ty value = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Return.value = value;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(value);
    return NULL;
}

static void Return_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.Return.value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Return_members[] = {
    {"value", _Py_T_OBJECT, offsetof(struct _stmt, v.Return.value),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Return_type_slots[] = {
    {Py_tp_dealloc, &Return_dealloc},
    {Py_tp_members, Return_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Return(expr? value)"},
    {Py_tp_new, Return_new},
    {0, 0},
};

static PyType_Spec _Return_type_spec = {
    "ast._Return",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Return_type_slots
};



stmt_ty _PyAst_Return_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_Return_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Return.value != NULL) {
        res->v.Return.value = _PyAst_expr_Copy(self->v.Return.value);
        ERROR_IF_NULL(res->v.Return.value);
    } else {
        res->v.Return.value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Delete_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "Delete takes at most 1 positional argument");
        return NULL;
    }
    asdl_expr_seq* targets = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr_seq(state, tmp, "Delete", "targets", &targets) <
                0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (targets != NULL) {
            err = PyDict_PopString(kwargs, "targets", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "Delete", "targets", &targets)
                    < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Delete.targets = targets;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(targets);
    return NULL;
}

static void Delete_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.Delete.targets);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Delete_members[] = {
    {"targets", _Py_T_OBJECT, offsetof(struct _stmt, v.Delete.targets),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Delete_type_slots[] = {
    {Py_tp_dealloc, &Delete_dealloc},
    {Py_tp_members, Delete_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Delete(expr* targets)"},
    {Py_tp_new, Delete_new},
    {0, 0},
};

static PyType_Spec _Delete_type_spec = {
    "ast._Delete",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Delete_type_slots
};



stmt_ty _PyAst_Delete_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_Delete_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Delete.targets != NULL) {
        res->v.Delete.targets = _PyAst_expr_seq_Copy(self->v.Delete.targets);
        ERROR_IF_NULL(res->v.Delete.targets);
    } else {
        res->v.Delete.targets = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Assign_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "Assign takes at most 3 positional arguments");
        return NULL;
    }
    asdl_expr_seq* targets = NULL;
    expr_ty value = NULL;
    string type_comment = 0;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_string(state, tmp, &type_comment) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr_seq(state, tmp, "Assign", "targets", &targets) <
                0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (targets != NULL) {
            err = PyDict_PopString(kwargs, "targets", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "Assign", "targets", &targets)
                    < 0) {
                    goto fail;
                }
            }
        }
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (type_comment != NULL) {
            err = PyDict_PopString(kwargs, "type_comment", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_string(state, tmp, &type_comment) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Assign.targets = targets;
    res->v.Assign.value = value;
    res->v.Assign.type_comment = type_comment;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(targets);
    Py_XDECREF(value);
    Py_XDECREF(type_comment);
    return NULL;
}

static void Assign_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.Assign.targets);
    Py_XDECREF(obj->v.Assign.value);
    Py_XDECREF(obj->v.Assign.type_comment);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Assign_members[] = {
    {"targets", _Py_T_OBJECT, offsetof(struct _stmt, v.Assign.targets),
      Py_READONLY, NULL},
    {"value", _Py_T_OBJECT, offsetof(struct _stmt, v.Assign.value),
      Py_READONLY, NULL},
    {"type_comment", _Py_T_OBJECT, offsetof(struct _stmt,
      v.Assign.type_comment), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Assign_type_slots[] = {
    {Py_tp_dealloc, &Assign_dealloc},
    {Py_tp_members, Assign_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Assign(expr* targets, expr value, string? type_comment)"},
    {Py_tp_new, Assign_new},
    {0, 0},
};

static PyType_Spec _Assign_type_spec = {
    "ast._Assign",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Assign_type_slots
};



stmt_ty _PyAst_Assign_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_Assign_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Assign.targets != NULL) {
        res->v.Assign.targets = _PyAst_expr_seq_Copy(self->v.Assign.targets);
        ERROR_IF_NULL(res->v.Assign.targets);
    } else {
        res->v.Assign.targets = NULL;
    }
    if (self->v.Assign.value != NULL) {
        res->v.Assign.value = _PyAst_expr_Copy(self->v.Assign.value);
        ERROR_IF_NULL(res->v.Assign.value);
    } else {
        res->v.Assign.value = NULL;
    }
    if (self->v.Assign.type_comment != NULL) {
        res->v.Assign.type_comment = Py_NewRef(self->v.Assign.type_comment);
        ERROR_IF_NULL(res->v.Assign.type_comment);
    } else {
        res->v.Assign.type_comment = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
TypeAlias_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "TypeAlias takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty name = NULL;
    asdl_type_param_seq* type_params = NULL;
    expr_ty value = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_type_param_seq(state, tmp, "TypeAlias", "type_params",
                &type_params) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &name) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (name != NULL) {
            err = PyDict_PopString(kwargs, "name", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &name) < 0) {
                    goto fail;
                }
            }
        }
        if (type_params != NULL) {
            err = PyDict_PopString(kwargs, "type_params", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_type_param_seq(state, tmp, "TypeAlias",
                    "type_params", &type_params) < 0) {
                    goto fail;
                }
            }
        }
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.TypeAlias.name = name;
    res->v.TypeAlias.type_params = type_params;
    res->v.TypeAlias.value = value;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(name);
    Py_XDECREF(type_params);
    Py_XDECREF(value);
    return NULL;
}

static void TypeAlias_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.TypeAlias.name);
    Py_XDECREF(obj->v.TypeAlias.type_params);
    Py_XDECREF(obj->v.TypeAlias.value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef TypeAlias_members[] = {
    {"name", _Py_T_OBJECT, offsetof(struct _stmt, v.TypeAlias.name),
      Py_READONLY, NULL},
    {"type_params", _Py_T_OBJECT, offsetof(struct _stmt,
      v.TypeAlias.type_params), Py_READONLY, NULL},
    {"value", _Py_T_OBJECT, offsetof(struct _stmt, v.TypeAlias.value),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _TypeAlias_type_slots[] = {
    {Py_tp_dealloc, &TypeAlias_dealloc},
    {Py_tp_members, TypeAlias_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "TypeAlias(expr name, type_param* type_params, expr value)"},
    {Py_tp_new, TypeAlias_new},
    {0, 0},
};

static PyType_Spec _TypeAlias_type_spec = {
    "ast._TypeAlias",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _TypeAlias_type_slots
};



stmt_ty _PyAst_TypeAlias_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_TypeAlias_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.TypeAlias.name != NULL) {
        res->v.TypeAlias.name = _PyAst_expr_Copy(self->v.TypeAlias.name);
        ERROR_IF_NULL(res->v.TypeAlias.name);
    } else {
        res->v.TypeAlias.name = NULL;
    }
    if (self->v.TypeAlias.type_params != NULL) {
        res->v.TypeAlias.type_params =
        _PyAst_type_param_seq_Copy(self->v.TypeAlias.type_params);
        ERROR_IF_NULL(res->v.TypeAlias.type_params);
    } else {
        res->v.TypeAlias.type_params = NULL;
    }
    if (self->v.TypeAlias.value != NULL) {
        res->v.TypeAlias.value = _PyAst_expr_Copy(self->v.TypeAlias.value);
        ERROR_IF_NULL(res->v.TypeAlias.value);
    } else {
        res->v.TypeAlias.value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
AugAssign_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "AugAssign takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty target = NULL;
    operator_ty op = 0;
    bool got_op = false;
    expr_ty value = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_operator(state, tmp, &op) < 0) {
                goto fail;
            }
            got_op = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &target) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (target != NULL) {
            err = PyDict_PopString(kwargs, "target", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &target) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_op) {
            err = PyDict_PopString(kwargs, "op", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_operator(state, tmp, &op) < 0) {
                    goto fail;
                }
            }
        }
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.AugAssign.target = target;
    res->v.AugAssign.op = op;
    res->v.AugAssign.value = value;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(target);
    Py_XDECREF(value);
    return NULL;
}

static void AugAssign_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.AugAssign.target);
    Py_XDECREF(obj->v.AugAssign.value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef AugAssign_members[] = {
    {"target", _Py_T_OBJECT, offsetof(struct _stmt, v.AugAssign.target),
      Py_READONLY, NULL},
    {"op", Py_T_INT, offsetof(struct _stmt, v.AugAssign.op), Py_READONLY, NULL},
    {"value", _Py_T_OBJECT, offsetof(struct _stmt, v.AugAssign.value),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _AugAssign_type_slots[] = {
    {Py_tp_dealloc, &AugAssign_dealloc},
    {Py_tp_members, AugAssign_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "AugAssign(expr target, operator op, expr value)"},
    {Py_tp_new, AugAssign_new},
    {0, 0},
};

static PyType_Spec _AugAssign_type_spec = {
    "ast._AugAssign",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _AugAssign_type_slots
};



stmt_ty _PyAst_AugAssign_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_AugAssign_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.AugAssign.target != NULL) {
        res->v.AugAssign.target = _PyAst_expr_Copy(self->v.AugAssign.target);
        ERROR_IF_NULL(res->v.AugAssign.target);
    } else {
        res->v.AugAssign.target = NULL;
    }
    res->v.AugAssign.op = self->v.AugAssign.op;
    if (self->v.AugAssign.value != NULL) {
        res->v.AugAssign.value = _PyAst_expr_Copy(self->v.AugAssign.value);
        ERROR_IF_NULL(res->v.AugAssign.value);
    } else {
        res->v.AugAssign.value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
AnnAssign_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 4) {
        PyErr_SetString(PyExc_TypeError,
                        "AnnAssign takes at most 4 positional arguments");
        return NULL;
    }
    expr_ty target = NULL;
    expr_ty annotation = NULL;
    expr_ty value = NULL;
    int simple = 0;
    bool got_simple = false;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 8: {
            tmp = PyTuple_GET_ITEM(pargs, 7);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &simple) < 0) {
                goto fail;
            }
            got_simple = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &annotation) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &target) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (target != NULL) {
            err = PyDict_PopString(kwargs, "target", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &target) < 0) {
                    goto fail;
                }
            }
        }
        if (annotation != NULL) {
            err = PyDict_PopString(kwargs, "annotation", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &annotation) < 0) {
                    goto fail;
                }
            }
        }
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_simple) {
            err = PyDict_PopString(kwargs, "simple", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &simple) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.AnnAssign.target = target;
    res->v.AnnAssign.annotation = annotation;
    res->v.AnnAssign.value = value;
    res->v.AnnAssign.simple = simple;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(target);
    Py_XDECREF(annotation);
    Py_XDECREF(value);
    return NULL;
}

static void AnnAssign_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.AnnAssign.target);
    Py_XDECREF(obj->v.AnnAssign.annotation);
    Py_XDECREF(obj->v.AnnAssign.value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef AnnAssign_members[] = {
    {"target", _Py_T_OBJECT, offsetof(struct _stmt, v.AnnAssign.target),
      Py_READONLY, NULL},
    {"annotation", _Py_T_OBJECT, offsetof(struct _stmt,
      v.AnnAssign.annotation), Py_READONLY, NULL},
    {"value", _Py_T_OBJECT, offsetof(struct _stmt, v.AnnAssign.value),
      Py_READONLY, NULL},
    {"simple", Py_T_INT, offsetof(struct _stmt, v.AnnAssign.simple),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _AnnAssign_type_slots[] = {
    {Py_tp_dealloc, &AnnAssign_dealloc},
    {Py_tp_members, AnnAssign_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "AnnAssign(expr target, expr annotation, expr? value, int simple)"},
    {Py_tp_new, AnnAssign_new},
    {0, 0},
};

static PyType_Spec _AnnAssign_type_spec = {
    "ast._AnnAssign",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _AnnAssign_type_slots
};



stmt_ty _PyAst_AnnAssign_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_AnnAssign_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.AnnAssign.target != NULL) {
        res->v.AnnAssign.target = _PyAst_expr_Copy(self->v.AnnAssign.target);
        ERROR_IF_NULL(res->v.AnnAssign.target);
    } else {
        res->v.AnnAssign.target = NULL;
    }
    if (self->v.AnnAssign.annotation != NULL) {
        res->v.AnnAssign.annotation =
        _PyAst_expr_Copy(self->v.AnnAssign.annotation);
        ERROR_IF_NULL(res->v.AnnAssign.annotation);
    } else {
        res->v.AnnAssign.annotation = NULL;
    }
    if (self->v.AnnAssign.value != NULL) {
        res->v.AnnAssign.value = _PyAst_expr_Copy(self->v.AnnAssign.value);
        ERROR_IF_NULL(res->v.AnnAssign.value);
    } else {
        res->v.AnnAssign.value = NULL;
    }
    res->v.AnnAssign.simple = self->v.AnnAssign.simple;
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
For_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 5) {
        PyErr_SetString(PyExc_TypeError,
                        "For takes at most 5 positional arguments");
        return NULL;
    }
    expr_ty target = NULL;
    expr_ty iter = NULL;
    asdl_stmt_seq* body = NULL;
    asdl_stmt_seq* orelse = NULL;
    string type_comment = 0;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 9: {
            tmp = PyTuple_GET_ITEM(pargs, 8);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 8: {
            tmp = PyTuple_GET_ITEM(pargs, 7);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_string(state, tmp, &type_comment) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_stmt_seq(state, tmp, "For", "orelse", &orelse) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_stmt_seq(state, tmp, "For", "body", &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &iter) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &target) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (target != NULL) {
            err = PyDict_PopString(kwargs, "target", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &target) < 0) {
                    goto fail;
                }
            }
        }
        if (iter != NULL) {
            err = PyDict_PopString(kwargs, "iter", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &iter) < 0) {
                    goto fail;
                }
            }
        }
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "For", "body", &body) < 0) {
                    goto fail;
                }
            }
        }
        if (orelse != NULL) {
            err = PyDict_PopString(kwargs, "orelse", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "For", "orelse", &orelse) < 0)
                    {
                    goto fail;
                }
            }
        }
        if (type_comment != NULL) {
            err = PyDict_PopString(kwargs, "type_comment", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_string(state, tmp, &type_comment) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.For.target = target;
    res->v.For.iter = iter;
    res->v.For.body = body;
    res->v.For.orelse = orelse;
    res->v.For.type_comment = type_comment;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(target);
    Py_XDECREF(iter);
    Py_XDECREF(body);
    Py_XDECREF(orelse);
    Py_XDECREF(type_comment);
    return NULL;
}

static void For_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.For.target);
    Py_XDECREF(obj->v.For.iter);
    Py_XDECREF(obj->v.For.body);
    Py_XDECREF(obj->v.For.orelse);
    Py_XDECREF(obj->v.For.type_comment);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef For_members[] = {
    {"target", _Py_T_OBJECT, offsetof(struct _stmt, v.For.target), Py_READONLY,
      NULL},
    {"iter", _Py_T_OBJECT, offsetof(struct _stmt, v.For.iter), Py_READONLY,
      NULL},
    {"body", _Py_T_OBJECT, offsetof(struct _stmt, v.For.body), Py_READONLY,
      NULL},
    {"orelse", _Py_T_OBJECT, offsetof(struct _stmt, v.For.orelse), Py_READONLY,
      NULL},
    {"type_comment", _Py_T_OBJECT, offsetof(struct _stmt, v.For.type_comment),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _For_type_slots[] = {
    {Py_tp_dealloc, &For_dealloc},
    {Py_tp_members, For_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)"},
    {Py_tp_new, For_new},
    {0, 0},
};

static PyType_Spec _For_type_spec = {
    "ast._For",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _For_type_slots
};



stmt_ty _PyAst_For_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject *)state->_For_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.For.target != NULL) {
        res->v.For.target = _PyAst_expr_Copy(self->v.For.target);
        ERROR_IF_NULL(res->v.For.target);
    } else {
        res->v.For.target = NULL;
    }
    if (self->v.For.iter != NULL) {
        res->v.For.iter = _PyAst_expr_Copy(self->v.For.iter);
        ERROR_IF_NULL(res->v.For.iter);
    } else {
        res->v.For.iter = NULL;
    }
    if (self->v.For.body != NULL) {
        res->v.For.body = _PyAst_stmt_seq_Copy(self->v.For.body);
        ERROR_IF_NULL(res->v.For.body);
    } else {
        res->v.For.body = NULL;
    }
    if (self->v.For.orelse != NULL) {
        res->v.For.orelse = _PyAst_stmt_seq_Copy(self->v.For.orelse);
        ERROR_IF_NULL(res->v.For.orelse);
    } else {
        res->v.For.orelse = NULL;
    }
    if (self->v.For.type_comment != NULL) {
        res->v.For.type_comment = Py_NewRef(self->v.For.type_comment);
        ERROR_IF_NULL(res->v.For.type_comment);
    } else {
        res->v.For.type_comment = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
AsyncFor_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 5) {
        PyErr_SetString(PyExc_TypeError,
                        "AsyncFor takes at most 5 positional arguments");
        return NULL;
    }
    expr_ty target = NULL;
    expr_ty iter = NULL;
    asdl_stmt_seq* body = NULL;
    asdl_stmt_seq* orelse = NULL;
    string type_comment = 0;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 9: {
            tmp = PyTuple_GET_ITEM(pargs, 8);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 8: {
            tmp = PyTuple_GET_ITEM(pargs, 7);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_string(state, tmp, &type_comment) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_stmt_seq(state, tmp, "AsyncFor", "orelse", &orelse) <
                0) {
                goto fail;
            }
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_stmt_seq(state, tmp, "AsyncFor", "body", &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &iter) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &target) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (target != NULL) {
            err = PyDict_PopString(kwargs, "target", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &target) < 0) {
                    goto fail;
                }
            }
        }
        if (iter != NULL) {
            err = PyDict_PopString(kwargs, "iter", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &iter) < 0) {
                    goto fail;
                }
            }
        }
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "AsyncFor", "body", &body) <
                    0) {
                    goto fail;
                }
            }
        }
        if (orelse != NULL) {
            err = PyDict_PopString(kwargs, "orelse", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "AsyncFor", "orelse", &orelse)
                    < 0) {
                    goto fail;
                }
            }
        }
        if (type_comment != NULL) {
            err = PyDict_PopString(kwargs, "type_comment", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_string(state, tmp, &type_comment) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.AsyncFor.target = target;
    res->v.AsyncFor.iter = iter;
    res->v.AsyncFor.body = body;
    res->v.AsyncFor.orelse = orelse;
    res->v.AsyncFor.type_comment = type_comment;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(target);
    Py_XDECREF(iter);
    Py_XDECREF(body);
    Py_XDECREF(orelse);
    Py_XDECREF(type_comment);
    return NULL;
}

static void AsyncFor_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.AsyncFor.target);
    Py_XDECREF(obj->v.AsyncFor.iter);
    Py_XDECREF(obj->v.AsyncFor.body);
    Py_XDECREF(obj->v.AsyncFor.orelse);
    Py_XDECREF(obj->v.AsyncFor.type_comment);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef AsyncFor_members[] = {
    {"target", _Py_T_OBJECT, offsetof(struct _stmt, v.AsyncFor.target),
      Py_READONLY, NULL},
    {"iter", _Py_T_OBJECT, offsetof(struct _stmt, v.AsyncFor.iter),
      Py_READONLY, NULL},
    {"body", _Py_T_OBJECT, offsetof(struct _stmt, v.AsyncFor.body),
      Py_READONLY, NULL},
    {"orelse", _Py_T_OBJECT, offsetof(struct _stmt, v.AsyncFor.orelse),
      Py_READONLY, NULL},
    {"type_comment", _Py_T_OBJECT, offsetof(struct _stmt,
      v.AsyncFor.type_comment), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _AsyncFor_type_slots[] = {
    {Py_tp_dealloc, &AsyncFor_dealloc},
    {Py_tp_members, AsyncFor_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)"},
    {Py_tp_new, AsyncFor_new},
    {0, 0},
};

static PyType_Spec _AsyncFor_type_spec = {
    "ast._AsyncFor",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _AsyncFor_type_slots
};



stmt_ty _PyAst_AsyncFor_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_AsyncFor_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.AsyncFor.target != NULL) {
        res->v.AsyncFor.target = _PyAst_expr_Copy(self->v.AsyncFor.target);
        ERROR_IF_NULL(res->v.AsyncFor.target);
    } else {
        res->v.AsyncFor.target = NULL;
    }
    if (self->v.AsyncFor.iter != NULL) {
        res->v.AsyncFor.iter = _PyAst_expr_Copy(self->v.AsyncFor.iter);
        ERROR_IF_NULL(res->v.AsyncFor.iter);
    } else {
        res->v.AsyncFor.iter = NULL;
    }
    if (self->v.AsyncFor.body != NULL) {
        res->v.AsyncFor.body = _PyAst_stmt_seq_Copy(self->v.AsyncFor.body);
        ERROR_IF_NULL(res->v.AsyncFor.body);
    } else {
        res->v.AsyncFor.body = NULL;
    }
    if (self->v.AsyncFor.orelse != NULL) {
        res->v.AsyncFor.orelse = _PyAst_stmt_seq_Copy(self->v.AsyncFor.orelse);
        ERROR_IF_NULL(res->v.AsyncFor.orelse);
    } else {
        res->v.AsyncFor.orelse = NULL;
    }
    if (self->v.AsyncFor.type_comment != NULL) {
        res->v.AsyncFor.type_comment = Py_NewRef(self->v.AsyncFor.type_comment);
        ERROR_IF_NULL(res->v.AsyncFor.type_comment);
    } else {
        res->v.AsyncFor.type_comment = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
While_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "While takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty test = NULL;
    asdl_stmt_seq* body = NULL;
    asdl_stmt_seq* orelse = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_stmt_seq(state, tmp, "While", "orelse", &orelse) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_stmt_seq(state, tmp, "While", "body", &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &test) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (test != NULL) {
            err = PyDict_PopString(kwargs, "test", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &test) < 0) {
                    goto fail;
                }
            }
        }
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "While", "body", &body) < 0) {
                    goto fail;
                }
            }
        }
        if (orelse != NULL) {
            err = PyDict_PopString(kwargs, "orelse", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "While", "orelse", &orelse) <
                    0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.While.test = test;
    res->v.While.body = body;
    res->v.While.orelse = orelse;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(test);
    Py_XDECREF(body);
    Py_XDECREF(orelse);
    return NULL;
}

static void While_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.While.test);
    Py_XDECREF(obj->v.While.body);
    Py_XDECREF(obj->v.While.orelse);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef While_members[] = {
    {"test", _Py_T_OBJECT, offsetof(struct _stmt, v.While.test), Py_READONLY,
      NULL},
    {"body", _Py_T_OBJECT, offsetof(struct _stmt, v.While.body), Py_READONLY,
      NULL},
    {"orelse", _Py_T_OBJECT, offsetof(struct _stmt, v.While.orelse),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _While_type_slots[] = {
    {Py_tp_dealloc, &While_dealloc},
    {Py_tp_members, While_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "While(expr test, stmt* body, stmt* orelse)"},
    {Py_tp_new, While_new},
    {0, 0},
};

static PyType_Spec _While_type_spec = {
    "ast._While",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _While_type_slots
};



stmt_ty _PyAst_While_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_While_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.While.test != NULL) {
        res->v.While.test = _PyAst_expr_Copy(self->v.While.test);
        ERROR_IF_NULL(res->v.While.test);
    } else {
        res->v.While.test = NULL;
    }
    if (self->v.While.body != NULL) {
        res->v.While.body = _PyAst_stmt_seq_Copy(self->v.While.body);
        ERROR_IF_NULL(res->v.While.body);
    } else {
        res->v.While.body = NULL;
    }
    if (self->v.While.orelse != NULL) {
        res->v.While.orelse = _PyAst_stmt_seq_Copy(self->v.While.orelse);
        ERROR_IF_NULL(res->v.While.orelse);
    } else {
        res->v.While.orelse = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
If_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "If takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty test = NULL;
    asdl_stmt_seq* body = NULL;
    asdl_stmt_seq* orelse = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_stmt_seq(state, tmp, "If", "orelse", &orelse) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_stmt_seq(state, tmp, "If", "body", &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &test) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (test != NULL) {
            err = PyDict_PopString(kwargs, "test", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &test) < 0) {
                    goto fail;
                }
            }
        }
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "If", "body", &body) < 0) {
                    goto fail;
                }
            }
        }
        if (orelse != NULL) {
            err = PyDict_PopString(kwargs, "orelse", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "If", "orelse", &orelse) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.If.test = test;
    res->v.If.body = body;
    res->v.If.orelse = orelse;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(test);
    Py_XDECREF(body);
    Py_XDECREF(orelse);
    return NULL;
}

static void If_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.If.test);
    Py_XDECREF(obj->v.If.body);
    Py_XDECREF(obj->v.If.orelse);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef If_members[] = {
    {"test", _Py_T_OBJECT, offsetof(struct _stmt, v.If.test), Py_READONLY,
      NULL},
    {"body", _Py_T_OBJECT, offsetof(struct _stmt, v.If.body), Py_READONLY,
      NULL},
    {"orelse", _Py_T_OBJECT, offsetof(struct _stmt, v.If.orelse), Py_READONLY,
      NULL},
    {0}
};

static PyType_Slot _If_type_slots[] = {
    {Py_tp_dealloc, &If_dealloc},
    {Py_tp_members, If_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "If(expr test, stmt* body, stmt* orelse)"},
    {Py_tp_new, If_new},
    {0, 0},
};

static PyType_Spec _If_type_spec = {
    "ast._If",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _If_type_slots
};



stmt_ty _PyAst_If_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject *)state->_If_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.If.test != NULL) {
        res->v.If.test = _PyAst_expr_Copy(self->v.If.test);
        ERROR_IF_NULL(res->v.If.test);
    } else {
        res->v.If.test = NULL;
    }
    if (self->v.If.body != NULL) {
        res->v.If.body = _PyAst_stmt_seq_Copy(self->v.If.body);
        ERROR_IF_NULL(res->v.If.body);
    } else {
        res->v.If.body = NULL;
    }
    if (self->v.If.orelse != NULL) {
        res->v.If.orelse = _PyAst_stmt_seq_Copy(self->v.If.orelse);
        ERROR_IF_NULL(res->v.If.orelse);
    } else {
        res->v.If.orelse = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
With_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "With takes at most 3 positional arguments");
        return NULL;
    }
    asdl_withitem_seq* items = NULL;
    asdl_stmt_seq* body = NULL;
    string type_comment = 0;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_string(state, tmp, &type_comment) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_stmt_seq(state, tmp, "With", "body", &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_withitem_seq(state, tmp, "With", "items", &items) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (items != NULL) {
            err = PyDict_PopString(kwargs, "items", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_withitem_seq(state, tmp, "With", "items", &items) <
                    0) {
                    goto fail;
                }
            }
        }
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "With", "body", &body) < 0) {
                    goto fail;
                }
            }
        }
        if (type_comment != NULL) {
            err = PyDict_PopString(kwargs, "type_comment", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_string(state, tmp, &type_comment) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.With.items = items;
    res->v.With.body = body;
    res->v.With.type_comment = type_comment;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(items);
    Py_XDECREF(body);
    Py_XDECREF(type_comment);
    return NULL;
}

static void With_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.With.items);
    Py_XDECREF(obj->v.With.body);
    Py_XDECREF(obj->v.With.type_comment);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef With_members[] = {
    {"items", _Py_T_OBJECT, offsetof(struct _stmt, v.With.items), Py_READONLY,
      NULL},
    {"body", _Py_T_OBJECT, offsetof(struct _stmt, v.With.body), Py_READONLY,
      NULL},
    {"type_comment", _Py_T_OBJECT, offsetof(struct _stmt, v.With.type_comment),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _With_type_slots[] = {
    {Py_tp_dealloc, &With_dealloc},
    {Py_tp_members, With_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "With(withitem* items, stmt* body, string? type_comment)"},
    {Py_tp_new, With_new},
    {0, 0},
};

static PyType_Spec _With_type_spec = {
    "ast._With",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _With_type_slots
};



stmt_ty _PyAst_With_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject *)state->_With_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.With.items != NULL) {
        res->v.With.items = _PyAst_withitem_seq_Copy(self->v.With.items);
        ERROR_IF_NULL(res->v.With.items);
    } else {
        res->v.With.items = NULL;
    }
    if (self->v.With.body != NULL) {
        res->v.With.body = _PyAst_stmt_seq_Copy(self->v.With.body);
        ERROR_IF_NULL(res->v.With.body);
    } else {
        res->v.With.body = NULL;
    }
    if (self->v.With.type_comment != NULL) {
        res->v.With.type_comment = Py_NewRef(self->v.With.type_comment);
        ERROR_IF_NULL(res->v.With.type_comment);
    } else {
        res->v.With.type_comment = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
AsyncWith_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "AsyncWith takes at most 3 positional arguments");
        return NULL;
    }
    asdl_withitem_seq* items = NULL;
    asdl_stmt_seq* body = NULL;
    string type_comment = 0;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_string(state, tmp, &type_comment) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_stmt_seq(state, tmp, "AsyncWith", "body", &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_withitem_seq(state, tmp, "AsyncWith", "items", &items)
                < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (items != NULL) {
            err = PyDict_PopString(kwargs, "items", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_withitem_seq(state, tmp, "AsyncWith", "items",
                    &items) < 0) {
                    goto fail;
                }
            }
        }
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "AsyncWith", "body", &body) <
                    0) {
                    goto fail;
                }
            }
        }
        if (type_comment != NULL) {
            err = PyDict_PopString(kwargs, "type_comment", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_string(state, tmp, &type_comment) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.AsyncWith.items = items;
    res->v.AsyncWith.body = body;
    res->v.AsyncWith.type_comment = type_comment;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(items);
    Py_XDECREF(body);
    Py_XDECREF(type_comment);
    return NULL;
}

static void AsyncWith_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.AsyncWith.items);
    Py_XDECREF(obj->v.AsyncWith.body);
    Py_XDECREF(obj->v.AsyncWith.type_comment);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef AsyncWith_members[] = {
    {"items", _Py_T_OBJECT, offsetof(struct _stmt, v.AsyncWith.items),
      Py_READONLY, NULL},
    {"body", _Py_T_OBJECT, offsetof(struct _stmt, v.AsyncWith.body),
      Py_READONLY, NULL},
    {"type_comment", _Py_T_OBJECT, offsetof(struct _stmt,
      v.AsyncWith.type_comment), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _AsyncWith_type_slots[] = {
    {Py_tp_dealloc, &AsyncWith_dealloc},
    {Py_tp_members, AsyncWith_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "AsyncWith(withitem* items, stmt* body, string? type_comment)"},
    {Py_tp_new, AsyncWith_new},
    {0, 0},
};

static PyType_Spec _AsyncWith_type_spec = {
    "ast._AsyncWith",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _AsyncWith_type_slots
};



stmt_ty _PyAst_AsyncWith_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_AsyncWith_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.AsyncWith.items != NULL) {
        res->v.AsyncWith.items =
        _PyAst_withitem_seq_Copy(self->v.AsyncWith.items);
        ERROR_IF_NULL(res->v.AsyncWith.items);
    } else {
        res->v.AsyncWith.items = NULL;
    }
    if (self->v.AsyncWith.body != NULL) {
        res->v.AsyncWith.body = _PyAst_stmt_seq_Copy(self->v.AsyncWith.body);
        ERROR_IF_NULL(res->v.AsyncWith.body);
    } else {
        res->v.AsyncWith.body = NULL;
    }
    if (self->v.AsyncWith.type_comment != NULL) {
        res->v.AsyncWith.type_comment =
        Py_NewRef(self->v.AsyncWith.type_comment);
        ERROR_IF_NULL(res->v.AsyncWith.type_comment);
    } else {
        res->v.AsyncWith.type_comment = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Match_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Match takes at most 2 positional arguments");
        return NULL;
    }
    expr_ty subject = NULL;
    asdl_match_case_seq* cases = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_match_case_seq(state, tmp, "Match", "cases", &cases) <
                0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &subject) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (subject != NULL) {
            err = PyDict_PopString(kwargs, "subject", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &subject) < 0) {
                    goto fail;
                }
            }
        }
        if (cases != NULL) {
            err = PyDict_PopString(kwargs, "cases", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_match_case_seq(state, tmp, "Match", "cases",
                    &cases) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Match.subject = subject;
    res->v.Match.cases = cases;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(subject);
    Py_XDECREF(cases);
    return NULL;
}

static void Match_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.Match.subject);
    Py_XDECREF(obj->v.Match.cases);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Match_members[] = {
    {"subject", _Py_T_OBJECT, offsetof(struct _stmt, v.Match.subject),
      Py_READONLY, NULL},
    {"cases", _Py_T_OBJECT, offsetof(struct _stmt, v.Match.cases), Py_READONLY,
      NULL},
    {0}
};

static PyType_Slot _Match_type_slots[] = {
    {Py_tp_dealloc, &Match_dealloc},
    {Py_tp_members, Match_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Match(expr subject, match_case* cases)"},
    {Py_tp_new, Match_new},
    {0, 0},
};

static PyType_Spec _Match_type_spec = {
    "ast._Match",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Match_type_slots
};



stmt_ty _PyAst_Match_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_Match_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Match.subject != NULL) {
        res->v.Match.subject = _PyAst_expr_Copy(self->v.Match.subject);
        ERROR_IF_NULL(res->v.Match.subject);
    } else {
        res->v.Match.subject = NULL;
    }
    if (self->v.Match.cases != NULL) {
        res->v.Match.cases = _PyAst_match_case_seq_Copy(self->v.Match.cases);
        ERROR_IF_NULL(res->v.Match.cases);
    } else {
        res->v.Match.cases = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Raise_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Raise takes at most 2 positional arguments");
        return NULL;
    }
    expr_ty exc = NULL;
    expr_ty cause = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &cause) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &exc) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (exc != NULL) {
            err = PyDict_PopString(kwargs, "exc", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &exc) < 0) {
                    goto fail;
                }
            }
        }
        if (cause != NULL) {
            err = PyDict_PopString(kwargs, "cause", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &cause) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Raise.exc = exc;
    res->v.Raise.cause = cause;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(exc);
    Py_XDECREF(cause);
    return NULL;
}

static void Raise_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.Raise.exc);
    Py_XDECREF(obj->v.Raise.cause);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Raise_members[] = {
    {"exc", _Py_T_OBJECT, offsetof(struct _stmt, v.Raise.exc), Py_READONLY,
      NULL},
    {"cause", _Py_T_OBJECT, offsetof(struct _stmt, v.Raise.cause), Py_READONLY,
      NULL},
    {0}
};

static PyType_Slot _Raise_type_slots[] = {
    {Py_tp_dealloc, &Raise_dealloc},
    {Py_tp_members, Raise_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Raise(expr? exc, expr? cause)"},
    {Py_tp_new, Raise_new},
    {0, 0},
};

static PyType_Spec _Raise_type_spec = {
    "ast._Raise",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Raise_type_slots
};



stmt_ty _PyAst_Raise_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_Raise_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Raise.exc != NULL) {
        res->v.Raise.exc = _PyAst_expr_Copy(self->v.Raise.exc);
        ERROR_IF_NULL(res->v.Raise.exc);
    } else {
        res->v.Raise.exc = NULL;
    }
    if (self->v.Raise.cause != NULL) {
        res->v.Raise.cause = _PyAst_expr_Copy(self->v.Raise.cause);
        ERROR_IF_NULL(res->v.Raise.cause);
    } else {
        res->v.Raise.cause = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Try_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 4) {
        PyErr_SetString(PyExc_TypeError,
                        "Try takes at most 4 positional arguments");
        return NULL;
    }
    asdl_stmt_seq* body = NULL;
    asdl_excepthandler_seq* handlers = NULL;
    asdl_stmt_seq* orelse = NULL;
    asdl_stmt_seq* finalbody = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 8: {
            tmp = PyTuple_GET_ITEM(pargs, 7);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_stmt_seq(state, tmp, "Try", "finalbody", &finalbody) <
                0) {
                goto fail;
            }
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_stmt_seq(state, tmp, "Try", "orelse", &orelse) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_excepthandler_seq(state, tmp, "Try", "handlers",
                &handlers) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_stmt_seq(state, tmp, "Try", "body", &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "Try", "body", &body) < 0) {
                    goto fail;
                }
            }
        }
        if (handlers != NULL) {
            err = PyDict_PopString(kwargs, "handlers", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_excepthandler_seq(state, tmp, "Try", "handlers",
                    &handlers) < 0) {
                    goto fail;
                }
            }
        }
        if (orelse != NULL) {
            err = PyDict_PopString(kwargs, "orelse", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "Try", "orelse", &orelse) < 0)
                    {
                    goto fail;
                }
            }
        }
        if (finalbody != NULL) {
            err = PyDict_PopString(kwargs, "finalbody", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "Try", "finalbody",
                    &finalbody) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Try.body = body;
    res->v.Try.handlers = handlers;
    res->v.Try.orelse = orelse;
    res->v.Try.finalbody = finalbody;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(body);
    Py_XDECREF(handlers);
    Py_XDECREF(orelse);
    Py_XDECREF(finalbody);
    return NULL;
}

static void Try_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.Try.body);
    Py_XDECREF(obj->v.Try.handlers);
    Py_XDECREF(obj->v.Try.orelse);
    Py_XDECREF(obj->v.Try.finalbody);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Try_members[] = {
    {"body", _Py_T_OBJECT, offsetof(struct _stmt, v.Try.body), Py_READONLY,
      NULL},
    {"handlers", _Py_T_OBJECT, offsetof(struct _stmt, v.Try.handlers),
      Py_READONLY, NULL},
    {"orelse", _Py_T_OBJECT, offsetof(struct _stmt, v.Try.orelse), Py_READONLY,
      NULL},
    {"finalbody", _Py_T_OBJECT, offsetof(struct _stmt, v.Try.finalbody),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Try_type_slots[] = {
    {Py_tp_dealloc, &Try_dealloc},
    {Py_tp_members, Try_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)"},
    {Py_tp_new, Try_new},
    {0, 0},
};

static PyType_Spec _Try_type_spec = {
    "ast._Try",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Try_type_slots
};



stmt_ty _PyAst_Try_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject *)state->_Try_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Try.body != NULL) {
        res->v.Try.body = _PyAst_stmt_seq_Copy(self->v.Try.body);
        ERROR_IF_NULL(res->v.Try.body);
    } else {
        res->v.Try.body = NULL;
    }
    if (self->v.Try.handlers != NULL) {
        res->v.Try.handlers =
        _PyAst_excepthandler_seq_Copy(self->v.Try.handlers);
        ERROR_IF_NULL(res->v.Try.handlers);
    } else {
        res->v.Try.handlers = NULL;
    }
    if (self->v.Try.orelse != NULL) {
        res->v.Try.orelse = _PyAst_stmt_seq_Copy(self->v.Try.orelse);
        ERROR_IF_NULL(res->v.Try.orelse);
    } else {
        res->v.Try.orelse = NULL;
    }
    if (self->v.Try.finalbody != NULL) {
        res->v.Try.finalbody = _PyAst_stmt_seq_Copy(self->v.Try.finalbody);
        ERROR_IF_NULL(res->v.Try.finalbody);
    } else {
        res->v.Try.finalbody = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
TryStar_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 4) {
        PyErr_SetString(PyExc_TypeError,
                        "TryStar takes at most 4 positional arguments");
        return NULL;
    }
    asdl_stmt_seq* body = NULL;
    asdl_excepthandler_seq* handlers = NULL;
    asdl_stmt_seq* orelse = NULL;
    asdl_stmt_seq* finalbody = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 8: {
            tmp = PyTuple_GET_ITEM(pargs, 7);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_stmt_seq(state, tmp, "TryStar", "finalbody",
                &finalbody) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_stmt_seq(state, tmp, "TryStar", "orelse", &orelse) < 0)
                {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_excepthandler_seq(state, tmp, "TryStar", "handlers",
                &handlers) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_stmt_seq(state, tmp, "TryStar", "body", &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "TryStar", "body", &body) < 0)
                    {
                    goto fail;
                }
            }
        }
        if (handlers != NULL) {
            err = PyDict_PopString(kwargs, "handlers", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_excepthandler_seq(state, tmp, "TryStar",
                    "handlers", &handlers) < 0) {
                    goto fail;
                }
            }
        }
        if (orelse != NULL) {
            err = PyDict_PopString(kwargs, "orelse", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "TryStar", "orelse", &orelse)
                    < 0) {
                    goto fail;
                }
            }
        }
        if (finalbody != NULL) {
            err = PyDict_PopString(kwargs, "finalbody", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "TryStar", "finalbody",
                    &finalbody) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.TryStar.body = body;
    res->v.TryStar.handlers = handlers;
    res->v.TryStar.orelse = orelse;
    res->v.TryStar.finalbody = finalbody;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(body);
    Py_XDECREF(handlers);
    Py_XDECREF(orelse);
    Py_XDECREF(finalbody);
    return NULL;
}

static void TryStar_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.TryStar.body);
    Py_XDECREF(obj->v.TryStar.handlers);
    Py_XDECREF(obj->v.TryStar.orelse);
    Py_XDECREF(obj->v.TryStar.finalbody);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef TryStar_members[] = {
    {"body", _Py_T_OBJECT, offsetof(struct _stmt, v.TryStar.body), Py_READONLY,
      NULL},
    {"handlers", _Py_T_OBJECT, offsetof(struct _stmt, v.TryStar.handlers),
      Py_READONLY, NULL},
    {"orelse", _Py_T_OBJECT, offsetof(struct _stmt, v.TryStar.orelse),
      Py_READONLY, NULL},
    {"finalbody", _Py_T_OBJECT, offsetof(struct _stmt, v.TryStar.finalbody),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _TryStar_type_slots[] = {
    {Py_tp_dealloc, &TryStar_dealloc},
    {Py_tp_members, TryStar_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)"},
    {Py_tp_new, TryStar_new},
    {0, 0},
};

static PyType_Spec _TryStar_type_spec = {
    "ast._TryStar",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _TryStar_type_slots
};



stmt_ty _PyAst_TryStar_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_TryStar_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.TryStar.body != NULL) {
        res->v.TryStar.body = _PyAst_stmt_seq_Copy(self->v.TryStar.body);
        ERROR_IF_NULL(res->v.TryStar.body);
    } else {
        res->v.TryStar.body = NULL;
    }
    if (self->v.TryStar.handlers != NULL) {
        res->v.TryStar.handlers =
        _PyAst_excepthandler_seq_Copy(self->v.TryStar.handlers);
        ERROR_IF_NULL(res->v.TryStar.handlers);
    } else {
        res->v.TryStar.handlers = NULL;
    }
    if (self->v.TryStar.orelse != NULL) {
        res->v.TryStar.orelse = _PyAst_stmt_seq_Copy(self->v.TryStar.orelse);
        ERROR_IF_NULL(res->v.TryStar.orelse);
    } else {
        res->v.TryStar.orelse = NULL;
    }
    if (self->v.TryStar.finalbody != NULL) {
        res->v.TryStar.finalbody =
        _PyAst_stmt_seq_Copy(self->v.TryStar.finalbody);
        ERROR_IF_NULL(res->v.TryStar.finalbody);
    } else {
        res->v.TryStar.finalbody = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Assert_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Assert takes at most 2 positional arguments");
        return NULL;
    }
    expr_ty test = NULL;
    expr_ty msg = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &msg) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &test) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (test != NULL) {
            err = PyDict_PopString(kwargs, "test", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &test) < 0) {
                    goto fail;
                }
            }
        }
        if (msg != NULL) {
            err = PyDict_PopString(kwargs, "msg", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &msg) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Assert.test = test;
    res->v.Assert.msg = msg;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(test);
    Py_XDECREF(msg);
    return NULL;
}

static void Assert_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.Assert.test);
    Py_XDECREF(obj->v.Assert.msg);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Assert_members[] = {
    {"test", _Py_T_OBJECT, offsetof(struct _stmt, v.Assert.test), Py_READONLY,
      NULL},
    {"msg", _Py_T_OBJECT, offsetof(struct _stmt, v.Assert.msg), Py_READONLY,
      NULL},
    {0}
};

static PyType_Slot _Assert_type_slots[] = {
    {Py_tp_dealloc, &Assert_dealloc},
    {Py_tp_members, Assert_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Assert(expr test, expr? msg)"},
    {Py_tp_new, Assert_new},
    {0, 0},
};

static PyType_Spec _Assert_type_spec = {
    "ast._Assert",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Assert_type_slots
};



stmt_ty _PyAst_Assert_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_Assert_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Assert.test != NULL) {
        res->v.Assert.test = _PyAst_expr_Copy(self->v.Assert.test);
        ERROR_IF_NULL(res->v.Assert.test);
    } else {
        res->v.Assert.test = NULL;
    }
    if (self->v.Assert.msg != NULL) {
        res->v.Assert.msg = _PyAst_expr_Copy(self->v.Assert.msg);
        ERROR_IF_NULL(res->v.Assert.msg);
    } else {
        res->v.Assert.msg = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Import_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "Import takes at most 1 positional argument");
        return NULL;
    }
    asdl_alias_seq* names = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_alias_seq(state, tmp, "Import", "names", &names) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (names != NULL) {
            err = PyDict_PopString(kwargs, "names", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_alias_seq(state, tmp, "Import", "names", &names) <
                    0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Import.names = names;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(names);
    return NULL;
}

static void Import_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.Import.names);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Import_members[] = {
    {"names", _Py_T_OBJECT, offsetof(struct _stmt, v.Import.names),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Import_type_slots[] = {
    {Py_tp_dealloc, &Import_dealloc},
    {Py_tp_members, Import_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Import(alias* names)"},
    {Py_tp_new, Import_new},
    {0, 0},
};

static PyType_Spec _Import_type_spec = {
    "ast._Import",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Import_type_slots
};



stmt_ty _PyAst_Import_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_Import_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Import.names != NULL) {
        res->v.Import.names = _PyAst_alias_seq_Copy(self->v.Import.names);
        ERROR_IF_NULL(res->v.Import.names);
    } else {
        res->v.Import.names = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
ImportFrom_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "ImportFrom takes at most 3 positional arguments");
        return NULL;
    }
    identifier module = NULL;
    asdl_alias_seq* names = NULL;
    int level = 0;
    bool got_level = false;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &level) < 0) {
                goto fail;
            }
            got_level = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_alias_seq(state, tmp, "ImportFrom", "names", &names) <
                0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier(state, tmp, &module) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (module != NULL) {
            err = PyDict_PopString(kwargs, "module", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &module) < 0) {
                    goto fail;
                }
            }
        }
        if (names != NULL) {
            err = PyDict_PopString(kwargs, "names", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_alias_seq(state, tmp, "ImportFrom", "names",
                    &names) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_level) {
            err = PyDict_PopString(kwargs, "level", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &level) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.ImportFrom.module = module;
    res->v.ImportFrom.names = names;
    res->v.ImportFrom.level = level;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(module);
    Py_XDECREF(names);
    return NULL;
}

static void ImportFrom_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.ImportFrom.module);
    Py_XDECREF(obj->v.ImportFrom.names);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef ImportFrom_members[] = {
    {"module", _Py_T_OBJECT, offsetof(struct _stmt, v.ImportFrom.module),
      Py_READONLY, NULL},
    {"names", _Py_T_OBJECT, offsetof(struct _stmt, v.ImportFrom.names),
      Py_READONLY, NULL},
    {"level", Py_T_INT, offsetof(struct _stmt, v.ImportFrom.level),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _ImportFrom_type_slots[] = {
    {Py_tp_dealloc, &ImportFrom_dealloc},
    {Py_tp_members, ImportFrom_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "ImportFrom(identifier? module, alias* names, int? level)"},
    {Py_tp_new, ImportFrom_new},
    {0, 0},
};

static PyType_Spec _ImportFrom_type_spec = {
    "ast._ImportFrom",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _ImportFrom_type_slots
};



stmt_ty _PyAst_ImportFrom_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_ImportFrom_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.ImportFrom.module != NULL) {
        res->v.ImportFrom.module = Py_NewRef(self->v.ImportFrom.module);
        ERROR_IF_NULL(res->v.ImportFrom.module);
    } else {
        res->v.ImportFrom.module = NULL;
    }
    if (self->v.ImportFrom.names != NULL) {
        res->v.ImportFrom.names =
        _PyAst_alias_seq_Copy(self->v.ImportFrom.names);
        ERROR_IF_NULL(res->v.ImportFrom.names);
    } else {
        res->v.ImportFrom.names = NULL;
    }
    res->v.ImportFrom.level = self->v.ImportFrom.level;
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Global_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "Global takes at most 1 positional argument");
        return NULL;
    }
    asdl_identifier_seq* names = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier_seq(state, tmp, "Global", "names", &names) <
                0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (names != NULL) {
            err = PyDict_PopString(kwargs, "names", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier_seq(state, tmp, "Global", "names",
                    &names) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Global.names = names;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(names);
    return NULL;
}

static void Global_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.Global.names);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Global_members[] = {
    {"names", _Py_T_OBJECT, offsetof(struct _stmt, v.Global.names),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Global_type_slots[] = {
    {Py_tp_dealloc, &Global_dealloc},
    {Py_tp_members, Global_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Global(identifier* names)"},
    {Py_tp_new, Global_new},
    {0, 0},
};

static PyType_Spec _Global_type_spec = {
    "ast._Global",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Global_type_slots
};



stmt_ty _PyAst_Global_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_Global_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Global.names != NULL) {
        res->v.Global.names = _PyAst_identifier_seq_Copy(self->v.Global.names);
        ERROR_IF_NULL(res->v.Global.names);
    } else {
        res->v.Global.names = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Nonlocal_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "Nonlocal takes at most 1 positional argument");
        return NULL;
    }
    asdl_identifier_seq* names = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier_seq(state, tmp, "Nonlocal", "names", &names)
                < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (names != NULL) {
            err = PyDict_PopString(kwargs, "names", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier_seq(state, tmp, "Nonlocal", "names",
                    &names) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Nonlocal.names = names;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(names);
    return NULL;
}

static void Nonlocal_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.Nonlocal.names);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Nonlocal_members[] = {
    {"names", _Py_T_OBJECT, offsetof(struct _stmt, v.Nonlocal.names),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Nonlocal_type_slots[] = {
    {Py_tp_dealloc, &Nonlocal_dealloc},
    {Py_tp_members, Nonlocal_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Nonlocal(identifier* names)"},
    {Py_tp_new, Nonlocal_new},
    {0, 0},
};

static PyType_Spec _Nonlocal_type_spec = {
    "ast._Nonlocal",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Nonlocal_type_slots
};



stmt_ty _PyAst_Nonlocal_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_Nonlocal_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Nonlocal.names != NULL) {
        res->v.Nonlocal.names =
        _PyAst_identifier_seq_Copy(self->v.Nonlocal.names);
        ERROR_IF_NULL(res->v.Nonlocal.names);
    } else {
        res->v.Nonlocal.names = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Expr_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "Expr takes at most 1 positional argument");
        return NULL;
    }
    expr_ty value = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Expr.value = value;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(value);
    return NULL;
}

static void Expr_dealloc(PyObject *self) {
    stmt_ty obj = (stmt_ty)self;
    Py_XDECREF(obj->v.Expr.value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Expr_members[] = {
    {"value", _Py_T_OBJECT, offsetof(struct _stmt, v.Expr.value), Py_READONLY,
      NULL},
    {0}
};

static PyType_Slot _Expr_type_slots[] = {
    {Py_tp_dealloc, &Expr_dealloc},
    {Py_tp_members, Expr_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Expr(expr value)"},
    {Py_tp_new, Expr_new},
    {0, 0},
};

static PyType_Spec _Expr_type_spec = {
    "ast._Expr",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Expr_type_slots
};



stmt_ty _PyAst_Expr_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject *)state->_Expr_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Expr.value != NULL) {
        res->v.Expr.value = _PyAst_expr_Copy(self->v.Expr.value);
        ERROR_IF_NULL(res->v.Expr.value);
    } else {
        res->v.Expr.value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Pass_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Pass takes at most 0 positional arguments");
        return NULL;
    }
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    return NULL;
}

static void Pass_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Pass_members[] = {
    {0}
};

static PyType_Slot _Pass_type_slots[] = {
    {Py_tp_dealloc, &Pass_dealloc},
    {Py_tp_members, Pass_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Pass"},
    {Py_tp_new, Pass_new},
    {0, 0},
};

static PyType_Spec _Pass_type_spec = {
    "ast._Pass",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Pass_type_slots
};



stmt_ty _PyAst_Pass_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject *)state->_Pass_type);
    if (res == NULL) {
        goto error;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Break_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Break takes at most 0 positional arguments");
        return NULL;
    }
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    return NULL;
}

static void Break_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Break_members[] = {
    {0}
};

static PyType_Slot _Break_type_slots[] = {
    {Py_tp_dealloc, &Break_dealloc},
    {Py_tp_members, Break_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Break"},
    {Py_tp_new, Break_new},
    {0, 0},
};

static PyType_Spec _Break_type_spec = {
    "ast._Break",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Break_type_slots
};



stmt_ty _PyAst_Break_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_Break_type);
    if (res == NULL) {
        goto error;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Continue_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Continue takes at most 0 positional arguments");
        return NULL;
    }
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    return NULL;
}

static void Continue_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Continue_members[] = {
    {0}
};

static PyType_Slot _Continue_type_slots[] = {
    {Py_tp_dealloc, &Continue_dealloc},
    {Py_tp_members, Continue_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Continue"},
    {Py_tp_new, Continue_new},
    {0, 0},
};

static PyType_Spec _Continue_type_spec = {
    "ast._Continue",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Continue_type_slots
};



stmt_ty _PyAst_Continue_Copy(stmt_ty self) {
    struct ast_state *state = get_ast_state();
    stmt_ty res = PyObject_New(struct _stmt, (PyTypeObject
                               *)state->_Continue_type);
    if (res == NULL) {
        goto error;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}


stmt_ty _PyAst_stmt_Copy(stmt_ty node) {
    switch (node->kind) {
        case FunctionDef_kind:
            return _PyAst_FunctionDef_Copy(node);
        case AsyncFunctionDef_kind:
            return _PyAst_AsyncFunctionDef_Copy(node);
        case ClassDef_kind:
            return _PyAst_ClassDef_Copy(node);
        case Return_kind:
            return _PyAst_Return_Copy(node);
        case Delete_kind:
            return _PyAst_Delete_Copy(node);
        case Assign_kind:
            return _PyAst_Assign_Copy(node);
        case TypeAlias_kind:
            return _PyAst_TypeAlias_Copy(node);
        case AugAssign_kind:
            return _PyAst_AugAssign_Copy(node);
        case AnnAssign_kind:
            return _PyAst_AnnAssign_Copy(node);
        case For_kind:
            return _PyAst_For_Copy(node);
        case AsyncFor_kind:
            return _PyAst_AsyncFor_Copy(node);
        case While_kind:
            return _PyAst_While_Copy(node);
        case If_kind:
            return _PyAst_If_Copy(node);
        case With_kind:
            return _PyAst_With_Copy(node);
        case AsyncWith_kind:
            return _PyAst_AsyncWith_Copy(node);
        case Match_kind:
            return _PyAst_Match_Copy(node);
        case Raise_kind:
            return _PyAst_Raise_Copy(node);
        case Try_kind:
            return _PyAst_Try_Copy(node);
        case TryStar_kind:
            return _PyAst_TryStar_Copy(node);
        case Assert_kind:
            return _PyAst_Assert_Copy(node);
        case Import_kind:
            return _PyAst_Import_Copy(node);
        case ImportFrom_kind:
            return _PyAst_ImportFrom_Copy(node);
        case Global_kind:
            return _PyAst_Global_Copy(node);
        case Nonlocal_kind:
            return _PyAst_Nonlocal_Copy(node);
        case Expr_kind:
            return _PyAst_Expr_Copy(node);
        case Pass_kind:
            return _PyAst_Pass_Copy(node);
        case Break_kind:
            return _PyAst_Break_Copy(node);
        case Continue_kind:
            return _PyAst_Continue_Copy(node);
    }
    return NULL;
}

static PyObject *
stmt_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "stmt takes at most 0 positional arguments");
        return NULL;
    }
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _stmt *res = (struct _stmt*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    return NULL;
}

static void stmt_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef stmt_members[] = {
    {0}
};

static PyType_Slot _stmt_type_slots[] = {
    {Py_tp_dealloc, &stmt_dealloc},
    {Py_tp_members, stmt_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "stmt = FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment, type_param* type_params)\n"
        "     | AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment, type_param* type_params)\n"
        "     | ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list, type_param* type_params)\n"
        "     | Return(expr? value)\n"
        "     | Delete(expr* targets)\n"
        "     | Assign(expr* targets, expr value, string? type_comment)\n"
        "     | TypeAlias(expr name, type_param* type_params, expr value)\n"
        "     | AugAssign(expr target, operator op, expr value)\n"
        "     | AnnAssign(expr target, expr annotation, expr? value, int simple)\n"
        "     | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)\n"
        "     | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)\n"
        "     | While(expr test, stmt* body, stmt* orelse)\n"
        "     | If(expr test, stmt* body, stmt* orelse)\n"
        "     | With(withitem* items, stmt* body, string? type_comment)\n"
        "     | AsyncWith(withitem* items, stmt* body, string? type_comment)\n"
        "     | Match(expr subject, match_case* cases)\n"
        "     | Raise(expr? exc, expr? cause)\n"
        "     | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)\n"
        "     | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)\n"
        "     | Assert(expr test, expr? msg)\n"
        "     | Import(alias* names)\n"
        "     | ImportFrom(identifier? module, alias* names, int? level)\n"
        "     | Global(identifier* names)\n"
        "     | Nonlocal(identifier* names)\n"
        "     | Expr(expr value)\n"
        "     | Pass\n"
        "     | Break\n"
        "     | Continue"},
    {Py_tp_new, stmt_new},
    {0, 0},
};

static PyType_Spec _stmt_type_spec = {
    "ast._stmt",
    sizeof(struct _stmt),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _stmt_type_slots
};



static void stmt_seq_dealloc(PyObject *self) {
    asdl_stmt_seq *obj = (asdl_stmt_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_stmt_seq_type_slots[] = {
    {Py_tp_dealloc, &stmt_seq_dealloc},
    //{Py_tp_members, stmt_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _stmt_seq_type_spec = {
    "ast._stmt_seq",
    sizeof(asdl_stmt_seq) - sizeof(stmt_ty),
    sizeof(stmt_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_stmt_seq_type_slots
};

asdl_stmt_seq *_PyAst_stmt_seq_Copy(asdl_stmt_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_stmt_seq *res = PyObject_NewVar(asdl_stmt_seq, (PyTypeObject *)state->_stmt_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] = _PyAst_stmt_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
BoolOp_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "BoolOp takes at most 2 positional arguments");
        return NULL;
    }
    boolop_ty op = 0;
    bool got_op = false;
    asdl_expr_seq* values = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr_seq(state, tmp, "BoolOp", "values", &values) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_boolop(state, tmp, &op) < 0) {
                goto fail;
            }
            got_op = true;
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (!got_op) {
            err = PyDict_PopString(kwargs, "op", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_boolop(state, tmp, &op) < 0) {
                    goto fail;
                }
            }
        }
        if (values != NULL) {
            err = PyDict_PopString(kwargs, "values", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "BoolOp", "values", &values) <
                    0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.BoolOp.op = op;
    res->v.BoolOp.values = values;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(values);
    return NULL;
}

static void BoolOp_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.BoolOp.values);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef BoolOp_members[] = {
    {"op", Py_T_INT, offsetof(struct _expr, v.BoolOp.op), Py_READONLY, NULL},
    {"values", _Py_T_OBJECT, offsetof(struct _expr, v.BoolOp.values),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _BoolOp_type_slots[] = {
    {Py_tp_dealloc, &BoolOp_dealloc},
    {Py_tp_members, BoolOp_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "BoolOp(boolop op, expr* values)"},
    {Py_tp_new, BoolOp_new},
    {0, 0},
};

static PyType_Spec _BoolOp_type_spec = {
    "ast._BoolOp",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _BoolOp_type_slots
};



expr_ty _PyAst_BoolOp_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_BoolOp_type);
    if (res == NULL) {
        goto error;
    }
    res->v.BoolOp.op = self->v.BoolOp.op;
    if (self->v.BoolOp.values != NULL) {
        res->v.BoolOp.values = _PyAst_expr_seq_Copy(self->v.BoolOp.values);
        ERROR_IF_NULL(res->v.BoolOp.values);
    } else {
        res->v.BoolOp.values = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
NamedExpr_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "NamedExpr takes at most 2 positional arguments");
        return NULL;
    }
    expr_ty target = NULL;
    expr_ty value = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &target) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (target != NULL) {
            err = PyDict_PopString(kwargs, "target", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &target) < 0) {
                    goto fail;
                }
            }
        }
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.NamedExpr.target = target;
    res->v.NamedExpr.value = value;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(target);
    Py_XDECREF(value);
    return NULL;
}

static void NamedExpr_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.NamedExpr.target);
    Py_XDECREF(obj->v.NamedExpr.value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef NamedExpr_members[] = {
    {"target", _Py_T_OBJECT, offsetof(struct _expr, v.NamedExpr.target),
      Py_READONLY, NULL},
    {"value", _Py_T_OBJECT, offsetof(struct _expr, v.NamedExpr.value),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _NamedExpr_type_slots[] = {
    {Py_tp_dealloc, &NamedExpr_dealloc},
    {Py_tp_members, NamedExpr_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "NamedExpr(expr target, expr value)"},
    {Py_tp_new, NamedExpr_new},
    {0, 0},
};

static PyType_Spec _NamedExpr_type_spec = {
    "ast._NamedExpr",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _NamedExpr_type_slots
};



expr_ty _PyAst_NamedExpr_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_NamedExpr_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.NamedExpr.target != NULL) {
        res->v.NamedExpr.target = _PyAst_expr_Copy(self->v.NamedExpr.target);
        ERROR_IF_NULL(res->v.NamedExpr.target);
    } else {
        res->v.NamedExpr.target = NULL;
    }
    if (self->v.NamedExpr.value != NULL) {
        res->v.NamedExpr.value = _PyAst_expr_Copy(self->v.NamedExpr.value);
        ERROR_IF_NULL(res->v.NamedExpr.value);
    } else {
        res->v.NamedExpr.value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
BinOp_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "BinOp takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty left = NULL;
    operator_ty op = 0;
    bool got_op = false;
    expr_ty right = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_expr(state, tmp, &right) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_operator(state, tmp, &op) < 0) {
                goto fail;
            }
            got_op = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &left) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (left != NULL) {
            err = PyDict_PopString(kwargs, "left", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &left) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_op) {
            err = PyDict_PopString(kwargs, "op", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_operator(state, tmp, &op) < 0) {
                    goto fail;
                }
            }
        }
        if (right != NULL) {
            err = PyDict_PopString(kwargs, "right", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &right) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.BinOp.left = left;
    res->v.BinOp.op = op;
    res->v.BinOp.right = right;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(left);
    Py_XDECREF(right);
    return NULL;
}

static void BinOp_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.BinOp.left);
    Py_XDECREF(obj->v.BinOp.right);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef BinOp_members[] = {
    {"left", _Py_T_OBJECT, offsetof(struct _expr, v.BinOp.left), Py_READONLY,
      NULL},
    {"op", Py_T_INT, offsetof(struct _expr, v.BinOp.op), Py_READONLY, NULL},
    {"right", _Py_T_OBJECT, offsetof(struct _expr, v.BinOp.right), Py_READONLY,
      NULL},
    {0}
};

static PyType_Slot _BinOp_type_slots[] = {
    {Py_tp_dealloc, &BinOp_dealloc},
    {Py_tp_members, BinOp_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "BinOp(expr left, operator op, expr right)"},
    {Py_tp_new, BinOp_new},
    {0, 0},
};

static PyType_Spec _BinOp_type_spec = {
    "ast._BinOp",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _BinOp_type_slots
};



expr_ty _PyAst_BinOp_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_BinOp_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.BinOp.left != NULL) {
        res->v.BinOp.left = _PyAst_expr_Copy(self->v.BinOp.left);
        ERROR_IF_NULL(res->v.BinOp.left);
    } else {
        res->v.BinOp.left = NULL;
    }
    res->v.BinOp.op = self->v.BinOp.op;
    if (self->v.BinOp.right != NULL) {
        res->v.BinOp.right = _PyAst_expr_Copy(self->v.BinOp.right);
        ERROR_IF_NULL(res->v.BinOp.right);
    } else {
        res->v.BinOp.right = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
UnaryOp_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "UnaryOp takes at most 2 positional arguments");
        return NULL;
    }
    unaryop_ty op = 0;
    bool got_op = false;
    expr_ty operand = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &operand) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_unaryop(state, tmp, &op) < 0) {
                goto fail;
            }
            got_op = true;
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (!got_op) {
            err = PyDict_PopString(kwargs, "op", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_unaryop(state, tmp, &op) < 0) {
                    goto fail;
                }
            }
        }
        if (operand != NULL) {
            err = PyDict_PopString(kwargs, "operand", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &operand) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.UnaryOp.op = op;
    res->v.UnaryOp.operand = operand;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(operand);
    return NULL;
}

static void UnaryOp_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.UnaryOp.operand);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef UnaryOp_members[] = {
    {"op", Py_T_INT, offsetof(struct _expr, v.UnaryOp.op), Py_READONLY, NULL},
    {"operand", _Py_T_OBJECT, offsetof(struct _expr, v.UnaryOp.operand),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _UnaryOp_type_slots[] = {
    {Py_tp_dealloc, &UnaryOp_dealloc},
    {Py_tp_members, UnaryOp_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "UnaryOp(unaryop op, expr operand)"},
    {Py_tp_new, UnaryOp_new},
    {0, 0},
};

static PyType_Spec _UnaryOp_type_spec = {
    "ast._UnaryOp",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _UnaryOp_type_slots
};



expr_ty _PyAst_UnaryOp_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_UnaryOp_type);
    if (res == NULL) {
        goto error;
    }
    res->v.UnaryOp.op = self->v.UnaryOp.op;
    if (self->v.UnaryOp.operand != NULL) {
        res->v.UnaryOp.operand = _PyAst_expr_Copy(self->v.UnaryOp.operand);
        ERROR_IF_NULL(res->v.UnaryOp.operand);
    } else {
        res->v.UnaryOp.operand = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Lambda_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Lambda takes at most 2 positional arguments");
        return NULL;
    }
    arguments_ty args = NULL;
    expr_ty body = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_arguments(state, tmp, &args) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (args != NULL) {
            err = PyDict_PopString(kwargs, "args", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_arguments(state, tmp, &args) < 0) {
                    goto fail;
                }
            }
        }
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &body) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Lambda.args = args;
    res->v.Lambda.body = body;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(args);
    Py_XDECREF(body);
    return NULL;
}

static void Lambda_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Lambda.args);
    Py_XDECREF(obj->v.Lambda.body);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Lambda_members[] = {
    {"args", _Py_T_OBJECT, offsetof(struct _expr, v.Lambda.args), Py_READONLY,
      NULL},
    {"body", _Py_T_OBJECT, offsetof(struct _expr, v.Lambda.body), Py_READONLY,
      NULL},
    {0}
};

static PyType_Slot _Lambda_type_slots[] = {
    {Py_tp_dealloc, &Lambda_dealloc},
    {Py_tp_members, Lambda_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Lambda(arguments args, expr body)"},
    {Py_tp_new, Lambda_new},
    {0, 0},
};

static PyType_Spec _Lambda_type_spec = {
    "ast._Lambda",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Lambda_type_slots
};



expr_ty _PyAst_Lambda_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_Lambda_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Lambda.args != NULL) {
        res->v.Lambda.args = _PyAst_arguments_Copy(self->v.Lambda.args);
        ERROR_IF_NULL(res->v.Lambda.args);
    } else {
        res->v.Lambda.args = NULL;
    }
    if (self->v.Lambda.body != NULL) {
        res->v.Lambda.body = _PyAst_expr_Copy(self->v.Lambda.body);
        ERROR_IF_NULL(res->v.Lambda.body);
    } else {
        res->v.Lambda.body = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
IfExp_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "IfExp takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty test = NULL;
    expr_ty body = NULL;
    expr_ty orelse = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_expr(state, tmp, &orelse) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &test) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (test != NULL) {
            err = PyDict_PopString(kwargs, "test", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &test) < 0) {
                    goto fail;
                }
            }
        }
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &body) < 0) {
                    goto fail;
                }
            }
        }
        if (orelse != NULL) {
            err = PyDict_PopString(kwargs, "orelse", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &orelse) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.IfExp.test = test;
    res->v.IfExp.body = body;
    res->v.IfExp.orelse = orelse;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(test);
    Py_XDECREF(body);
    Py_XDECREF(orelse);
    return NULL;
}

static void IfExp_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.IfExp.test);
    Py_XDECREF(obj->v.IfExp.body);
    Py_XDECREF(obj->v.IfExp.orelse);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef IfExp_members[] = {
    {"test", _Py_T_OBJECT, offsetof(struct _expr, v.IfExp.test), Py_READONLY,
      NULL},
    {"body", _Py_T_OBJECT, offsetof(struct _expr, v.IfExp.body), Py_READONLY,
      NULL},
    {"orelse", _Py_T_OBJECT, offsetof(struct _expr, v.IfExp.orelse),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _IfExp_type_slots[] = {
    {Py_tp_dealloc, &IfExp_dealloc},
    {Py_tp_members, IfExp_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "IfExp(expr test, expr body, expr orelse)"},
    {Py_tp_new, IfExp_new},
    {0, 0},
};

static PyType_Spec _IfExp_type_spec = {
    "ast._IfExp",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _IfExp_type_slots
};



expr_ty _PyAst_IfExp_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_IfExp_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.IfExp.test != NULL) {
        res->v.IfExp.test = _PyAst_expr_Copy(self->v.IfExp.test);
        ERROR_IF_NULL(res->v.IfExp.test);
    } else {
        res->v.IfExp.test = NULL;
    }
    if (self->v.IfExp.body != NULL) {
        res->v.IfExp.body = _PyAst_expr_Copy(self->v.IfExp.body);
        ERROR_IF_NULL(res->v.IfExp.body);
    } else {
        res->v.IfExp.body = NULL;
    }
    if (self->v.IfExp.orelse != NULL) {
        res->v.IfExp.orelse = _PyAst_expr_Copy(self->v.IfExp.orelse);
        ERROR_IF_NULL(res->v.IfExp.orelse);
    } else {
        res->v.IfExp.orelse = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Dict_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Dict takes at most 2 positional arguments");
        return NULL;
    }
    asdl_expr_seq* keys = NULL;
    asdl_expr_seq* values = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr_seq(state, tmp, "Dict", "values", &values) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr_seq(state, tmp, "Dict", "keys", &keys) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (keys != NULL) {
            err = PyDict_PopString(kwargs, "keys", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "Dict", "keys", &keys) < 0) {
                    goto fail;
                }
            }
        }
        if (values != NULL) {
            err = PyDict_PopString(kwargs, "values", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "Dict", "values", &values) <
                    0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Dict.keys = keys;
    res->v.Dict.values = values;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(keys);
    Py_XDECREF(values);
    return NULL;
}

static void Dict_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Dict.keys);
    Py_XDECREF(obj->v.Dict.values);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Dict_members[] = {
    {"keys", _Py_T_OBJECT, offsetof(struct _expr, v.Dict.keys), Py_READONLY,
      NULL},
    {"values", _Py_T_OBJECT, offsetof(struct _expr, v.Dict.values),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Dict_type_slots[] = {
    {Py_tp_dealloc, &Dict_dealloc},
    {Py_tp_members, Dict_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Dict(expr?* keys, expr* values)"},
    {Py_tp_new, Dict_new},
    {0, 0},
};

static PyType_Spec _Dict_type_spec = {
    "ast._Dict",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Dict_type_slots
};



expr_ty _PyAst_Dict_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject *)state->_Dict_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Dict.keys != NULL) {
        res->v.Dict.keys = _PyAst_expr_seq_Copy(self->v.Dict.keys);
        ERROR_IF_NULL(res->v.Dict.keys);
    } else {
        res->v.Dict.keys = NULL;
    }
    if (self->v.Dict.values != NULL) {
        res->v.Dict.values = _PyAst_expr_seq_Copy(self->v.Dict.values);
        ERROR_IF_NULL(res->v.Dict.values);
    } else {
        res->v.Dict.values = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Set_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "Set takes at most 1 positional argument");
        return NULL;
    }
    asdl_expr_seq* elts = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr_seq(state, tmp, "Set", "elts", &elts) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (elts != NULL) {
            err = PyDict_PopString(kwargs, "elts", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "Set", "elts", &elts) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Set.elts = elts;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(elts);
    return NULL;
}

static void Set_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Set.elts);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Set_members[] = {
    {"elts", _Py_T_OBJECT, offsetof(struct _expr, v.Set.elts), Py_READONLY,
      NULL},
    {0}
};

static PyType_Slot _Set_type_slots[] = {
    {Py_tp_dealloc, &Set_dealloc},
    {Py_tp_members, Set_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Set(expr* elts)"},
    {Py_tp_new, Set_new},
    {0, 0},
};

static PyType_Spec _Set_type_spec = {
    "ast._Set",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Set_type_slots
};



expr_ty _PyAst_Set_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject *)state->_Set_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Set.elts != NULL) {
        res->v.Set.elts = _PyAst_expr_seq_Copy(self->v.Set.elts);
        ERROR_IF_NULL(res->v.Set.elts);
    } else {
        res->v.Set.elts = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
ListComp_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "ListComp takes at most 2 positional arguments");
        return NULL;
    }
    expr_ty elt = NULL;
    asdl_comprehension_seq* generators = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_comprehension_seq(state, tmp, "ListComp", "generators",
                &generators) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &elt) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (elt != NULL) {
            err = PyDict_PopString(kwargs, "elt", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &elt) < 0) {
                    goto fail;
                }
            }
        }
        if (generators != NULL) {
            err = PyDict_PopString(kwargs, "generators", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_comprehension_seq(state, tmp, "ListComp",
                    "generators", &generators) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.ListComp.elt = elt;
    res->v.ListComp.generators = generators;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(elt);
    Py_XDECREF(generators);
    return NULL;
}

static void ListComp_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.ListComp.elt);
    Py_XDECREF(obj->v.ListComp.generators);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef ListComp_members[] = {
    {"elt", _Py_T_OBJECT, offsetof(struct _expr, v.ListComp.elt), Py_READONLY,
      NULL},
    {"generators", _Py_T_OBJECT, offsetof(struct _expr, v.ListComp.generators),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _ListComp_type_slots[] = {
    {Py_tp_dealloc, &ListComp_dealloc},
    {Py_tp_members, ListComp_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "ListComp(expr elt, comprehension* generators)"},
    {Py_tp_new, ListComp_new},
    {0, 0},
};

static PyType_Spec _ListComp_type_spec = {
    "ast._ListComp",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _ListComp_type_slots
};



expr_ty _PyAst_ListComp_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_ListComp_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.ListComp.elt != NULL) {
        res->v.ListComp.elt = _PyAst_expr_Copy(self->v.ListComp.elt);
        ERROR_IF_NULL(res->v.ListComp.elt);
    } else {
        res->v.ListComp.elt = NULL;
    }
    if (self->v.ListComp.generators != NULL) {
        res->v.ListComp.generators =
        _PyAst_comprehension_seq_Copy(self->v.ListComp.generators);
        ERROR_IF_NULL(res->v.ListComp.generators);
    } else {
        res->v.ListComp.generators = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
SetComp_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "SetComp takes at most 2 positional arguments");
        return NULL;
    }
    expr_ty elt = NULL;
    asdl_comprehension_seq* generators = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_comprehension_seq(state, tmp, "SetComp", "generators",
                &generators) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &elt) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (elt != NULL) {
            err = PyDict_PopString(kwargs, "elt", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &elt) < 0) {
                    goto fail;
                }
            }
        }
        if (generators != NULL) {
            err = PyDict_PopString(kwargs, "generators", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_comprehension_seq(state, tmp, "SetComp",
                    "generators", &generators) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.SetComp.elt = elt;
    res->v.SetComp.generators = generators;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(elt);
    Py_XDECREF(generators);
    return NULL;
}

static void SetComp_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.SetComp.elt);
    Py_XDECREF(obj->v.SetComp.generators);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef SetComp_members[] = {
    {"elt", _Py_T_OBJECT, offsetof(struct _expr, v.SetComp.elt), Py_READONLY,
      NULL},
    {"generators", _Py_T_OBJECT, offsetof(struct _expr, v.SetComp.generators),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _SetComp_type_slots[] = {
    {Py_tp_dealloc, &SetComp_dealloc},
    {Py_tp_members, SetComp_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "SetComp(expr elt, comprehension* generators)"},
    {Py_tp_new, SetComp_new},
    {0, 0},
};

static PyType_Spec _SetComp_type_spec = {
    "ast._SetComp",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _SetComp_type_slots
};



expr_ty _PyAst_SetComp_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_SetComp_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.SetComp.elt != NULL) {
        res->v.SetComp.elt = _PyAst_expr_Copy(self->v.SetComp.elt);
        ERROR_IF_NULL(res->v.SetComp.elt);
    } else {
        res->v.SetComp.elt = NULL;
    }
    if (self->v.SetComp.generators != NULL) {
        res->v.SetComp.generators =
        _PyAst_comprehension_seq_Copy(self->v.SetComp.generators);
        ERROR_IF_NULL(res->v.SetComp.generators);
    } else {
        res->v.SetComp.generators = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
DictComp_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "DictComp takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty key = NULL;
    expr_ty value = NULL;
    asdl_comprehension_seq* generators = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_comprehension_seq(state, tmp, "DictComp", "generators",
                &generators) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &key) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (key != NULL) {
            err = PyDict_PopString(kwargs, "key", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &key) < 0) {
                    goto fail;
                }
            }
        }
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (generators != NULL) {
            err = PyDict_PopString(kwargs, "generators", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_comprehension_seq(state, tmp, "DictComp",
                    "generators", &generators) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.DictComp.key = key;
    res->v.DictComp.value = value;
    res->v.DictComp.generators = generators;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(key);
    Py_XDECREF(value);
    Py_XDECREF(generators);
    return NULL;
}

static void DictComp_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.DictComp.key);
    Py_XDECREF(obj->v.DictComp.value);
    Py_XDECREF(obj->v.DictComp.generators);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef DictComp_members[] = {
    {"key", _Py_T_OBJECT, offsetof(struct _expr, v.DictComp.key), Py_READONLY,
      NULL},
    {"value", _Py_T_OBJECT, offsetof(struct _expr, v.DictComp.value),
      Py_READONLY, NULL},
    {"generators", _Py_T_OBJECT, offsetof(struct _expr, v.DictComp.generators),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _DictComp_type_slots[] = {
    {Py_tp_dealloc, &DictComp_dealloc},
    {Py_tp_members, DictComp_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "DictComp(expr key, expr value, comprehension* generators)"},
    {Py_tp_new, DictComp_new},
    {0, 0},
};

static PyType_Spec _DictComp_type_spec = {
    "ast._DictComp",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _DictComp_type_slots
};



expr_ty _PyAst_DictComp_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_DictComp_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.DictComp.key != NULL) {
        res->v.DictComp.key = _PyAst_expr_Copy(self->v.DictComp.key);
        ERROR_IF_NULL(res->v.DictComp.key);
    } else {
        res->v.DictComp.key = NULL;
    }
    if (self->v.DictComp.value != NULL) {
        res->v.DictComp.value = _PyAst_expr_Copy(self->v.DictComp.value);
        ERROR_IF_NULL(res->v.DictComp.value);
    } else {
        res->v.DictComp.value = NULL;
    }
    if (self->v.DictComp.generators != NULL) {
        res->v.DictComp.generators =
        _PyAst_comprehension_seq_Copy(self->v.DictComp.generators);
        ERROR_IF_NULL(res->v.DictComp.generators);
    } else {
        res->v.DictComp.generators = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
GeneratorExp_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "GeneratorExp takes at most 2 positional arguments");
        return NULL;
    }
    expr_ty elt = NULL;
    asdl_comprehension_seq* generators = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_comprehension_seq(state, tmp, "GeneratorExp",
                "generators", &generators) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &elt) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (elt != NULL) {
            err = PyDict_PopString(kwargs, "elt", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &elt) < 0) {
                    goto fail;
                }
            }
        }
        if (generators != NULL) {
            err = PyDict_PopString(kwargs, "generators", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_comprehension_seq(state, tmp, "GeneratorExp",
                    "generators", &generators) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.GeneratorExp.elt = elt;
    res->v.GeneratorExp.generators = generators;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(elt);
    Py_XDECREF(generators);
    return NULL;
}

static void GeneratorExp_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.GeneratorExp.elt);
    Py_XDECREF(obj->v.GeneratorExp.generators);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef GeneratorExp_members[] = {
    {"elt", _Py_T_OBJECT, offsetof(struct _expr, v.GeneratorExp.elt),
      Py_READONLY, NULL},
    {"generators", _Py_T_OBJECT, offsetof(struct _expr,
      v.GeneratorExp.generators), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _GeneratorExp_type_slots[] = {
    {Py_tp_dealloc, &GeneratorExp_dealloc},
    {Py_tp_members, GeneratorExp_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "GeneratorExp(expr elt, comprehension* generators)"},
    {Py_tp_new, GeneratorExp_new},
    {0, 0},
};

static PyType_Spec _GeneratorExp_type_spec = {
    "ast._GeneratorExp",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _GeneratorExp_type_slots
};



expr_ty _PyAst_GeneratorExp_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_GeneratorExp_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.GeneratorExp.elt != NULL) {
        res->v.GeneratorExp.elt = _PyAst_expr_Copy(self->v.GeneratorExp.elt);
        ERROR_IF_NULL(res->v.GeneratorExp.elt);
    } else {
        res->v.GeneratorExp.elt = NULL;
    }
    if (self->v.GeneratorExp.generators != NULL) {
        res->v.GeneratorExp.generators =
        _PyAst_comprehension_seq_Copy(self->v.GeneratorExp.generators);
        ERROR_IF_NULL(res->v.GeneratorExp.generators);
    } else {
        res->v.GeneratorExp.generators = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Await_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "Await takes at most 1 positional argument");
        return NULL;
    }
    expr_ty value = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Await.value = value;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(value);
    return NULL;
}

static void Await_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Await.value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Await_members[] = {
    {"value", _Py_T_OBJECT, offsetof(struct _expr, v.Await.value), Py_READONLY,
      NULL},
    {0}
};

static PyType_Slot _Await_type_slots[] = {
    {Py_tp_dealloc, &Await_dealloc},
    {Py_tp_members, Await_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Await(expr value)"},
    {Py_tp_new, Await_new},
    {0, 0},
};

static PyType_Spec _Await_type_spec = {
    "ast._Await",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Await_type_slots
};



expr_ty _PyAst_Await_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_Await_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Await.value != NULL) {
        res->v.Await.value = _PyAst_expr_Copy(self->v.Await.value);
        ERROR_IF_NULL(res->v.Await.value);
    } else {
        res->v.Await.value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Yield_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "Yield takes at most 1 positional argument");
        return NULL;
    }
    expr_ty value = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Yield.value = value;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(value);
    return NULL;
}

static void Yield_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Yield.value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Yield_members[] = {
    {"value", _Py_T_OBJECT, offsetof(struct _expr, v.Yield.value), Py_READONLY,
      NULL},
    {0}
};

static PyType_Slot _Yield_type_slots[] = {
    {Py_tp_dealloc, &Yield_dealloc},
    {Py_tp_members, Yield_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Yield(expr? value)"},
    {Py_tp_new, Yield_new},
    {0, 0},
};

static PyType_Spec _Yield_type_spec = {
    "ast._Yield",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Yield_type_slots
};



expr_ty _PyAst_Yield_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_Yield_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Yield.value != NULL) {
        res->v.Yield.value = _PyAst_expr_Copy(self->v.Yield.value);
        ERROR_IF_NULL(res->v.Yield.value);
    } else {
        res->v.Yield.value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
YieldFrom_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "YieldFrom takes at most 1 positional argument");
        return NULL;
    }
    expr_ty value = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.YieldFrom.value = value;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(value);
    return NULL;
}

static void YieldFrom_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.YieldFrom.value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef YieldFrom_members[] = {
    {"value", _Py_T_OBJECT, offsetof(struct _expr, v.YieldFrom.value),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _YieldFrom_type_slots[] = {
    {Py_tp_dealloc, &YieldFrom_dealloc},
    {Py_tp_members, YieldFrom_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "YieldFrom(expr value)"},
    {Py_tp_new, YieldFrom_new},
    {0, 0},
};

static PyType_Spec _YieldFrom_type_spec = {
    "ast._YieldFrom",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _YieldFrom_type_slots
};



expr_ty _PyAst_YieldFrom_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_YieldFrom_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.YieldFrom.value != NULL) {
        res->v.YieldFrom.value = _PyAst_expr_Copy(self->v.YieldFrom.value);
        ERROR_IF_NULL(res->v.YieldFrom.value);
    } else {
        res->v.YieldFrom.value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Compare_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "Compare takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty left = NULL;
    asdl_int_seq* ops = NULL;
    bool got_ops = false;
    asdl_expr_seq* comparators = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_expr_seq(state, tmp, "Compare", "comparators",
                &comparators) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_cmpop_seq(state, tmp, "Compare", "ops", &ops) < 0) {
                goto fail;
            }
            got_ops = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &left) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (left != NULL) {
            err = PyDict_PopString(kwargs, "left", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &left) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_ops) {
            err = PyDict_PopString(kwargs, "ops", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_cmpop_seq(state, tmp, "Compare", "ops", &ops) < 0) {
                    goto fail;
                }
            }
        }
        if (comparators != NULL) {
            err = PyDict_PopString(kwargs, "comparators", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "Compare", "comparators",
                    &comparators) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Compare.left = left;
    res->v.Compare.ops = ops;
    res->v.Compare.comparators = comparators;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(left);
    Py_XDECREF(comparators);
    return NULL;
}

static void Compare_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Compare.left);
    Py_XDECREF(obj->v.Compare.comparators);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Compare_members[] = {
    {"left", _Py_T_OBJECT, offsetof(struct _expr, v.Compare.left), Py_READONLY,
      NULL},
    {"ops", Py_T_INT, offsetof(struct _expr, v.Compare.ops), Py_READONLY, NULL},
    {"comparators", _Py_T_OBJECT, offsetof(struct _expr,
      v.Compare.comparators), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Compare_type_slots[] = {
    {Py_tp_dealloc, &Compare_dealloc},
    {Py_tp_members, Compare_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Compare(expr left, cmpop* ops, expr* comparators)"},
    {Py_tp_new, Compare_new},
    {0, 0},
};

static PyType_Spec _Compare_type_spec = {
    "ast._Compare",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Compare_type_slots
};



expr_ty _PyAst_Compare_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_Compare_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Compare.left != NULL) {
        res->v.Compare.left = _PyAst_expr_Copy(self->v.Compare.left);
        ERROR_IF_NULL(res->v.Compare.left);
    } else {
        res->v.Compare.left = NULL;
    }
    if (self->v.Compare.ops != NULL) {
        res->v.Compare.ops = _PyAst_int_seq_Copy(self->v.Compare.ops);
        ERROR_IF_NULL(res->v.Compare.ops);
    } else {
        res->v.Compare.ops = NULL;
    }
    if (self->v.Compare.comparators != NULL) {
        res->v.Compare.comparators =
        _PyAst_expr_seq_Copy(self->v.Compare.comparators);
        ERROR_IF_NULL(res->v.Compare.comparators);
    } else {
        res->v.Compare.comparators = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Call_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "Call takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty func = NULL;
    asdl_expr_seq* args = NULL;
    asdl_keyword_seq* keywords = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_keyword_seq(state, tmp, "Call", "keywords", &keywords)
                < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr_seq(state, tmp, "Call", "args", &args) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &func) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (func != NULL) {
            err = PyDict_PopString(kwargs, "func", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &func) < 0) {
                    goto fail;
                }
            }
        }
        if (args != NULL) {
            err = PyDict_PopString(kwargs, "args", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "Call", "args", &args) < 0) {
                    goto fail;
                }
            }
        }
        if (keywords != NULL) {
            err = PyDict_PopString(kwargs, "keywords", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_keyword_seq(state, tmp, "Call", "keywords",
                    &keywords) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Call.func = func;
    res->v.Call.args = args;
    res->v.Call.keywords = keywords;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(func);
    Py_XDECREF(args);
    Py_XDECREF(keywords);
    return NULL;
}

static void Call_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Call.func);
    Py_XDECREF(obj->v.Call.args);
    Py_XDECREF(obj->v.Call.keywords);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Call_members[] = {
    {"func", _Py_T_OBJECT, offsetof(struct _expr, v.Call.func), Py_READONLY,
      NULL},
    {"args", _Py_T_OBJECT, offsetof(struct _expr, v.Call.args), Py_READONLY,
      NULL},
    {"keywords", _Py_T_OBJECT, offsetof(struct _expr, v.Call.keywords),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Call_type_slots[] = {
    {Py_tp_dealloc, &Call_dealloc},
    {Py_tp_members, Call_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Call(expr func, expr* args, keyword* keywords)"},
    {Py_tp_new, Call_new},
    {0, 0},
};

static PyType_Spec _Call_type_spec = {
    "ast._Call",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Call_type_slots
};



expr_ty _PyAst_Call_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject *)state->_Call_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Call.func != NULL) {
        res->v.Call.func = _PyAst_expr_Copy(self->v.Call.func);
        ERROR_IF_NULL(res->v.Call.func);
    } else {
        res->v.Call.func = NULL;
    }
    if (self->v.Call.args != NULL) {
        res->v.Call.args = _PyAst_expr_seq_Copy(self->v.Call.args);
        ERROR_IF_NULL(res->v.Call.args);
    } else {
        res->v.Call.args = NULL;
    }
    if (self->v.Call.keywords != NULL) {
        res->v.Call.keywords = _PyAst_keyword_seq_Copy(self->v.Call.keywords);
        ERROR_IF_NULL(res->v.Call.keywords);
    } else {
        res->v.Call.keywords = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
FormattedValue_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "FormattedValue takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty value = NULL;
    int conversion = 0;
    bool got_conversion = false;
    expr_ty format_spec = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_expr(state, tmp, &format_spec) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &conversion) < 0) {
                goto fail;
            }
            got_conversion = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_conversion) {
            err = PyDict_PopString(kwargs, "conversion", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &conversion) < 0) {
                    goto fail;
                }
            }
        }
        if (format_spec != NULL) {
            err = PyDict_PopString(kwargs, "format_spec", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &format_spec) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.FormattedValue.value = value;
    res->v.FormattedValue.conversion = conversion;
    res->v.FormattedValue.format_spec = format_spec;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(value);
    Py_XDECREF(format_spec);
    return NULL;
}

static void FormattedValue_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.FormattedValue.value);
    Py_XDECREF(obj->v.FormattedValue.format_spec);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef FormattedValue_members[] = {
    {"value", _Py_T_OBJECT, offsetof(struct _expr, v.FormattedValue.value),
      Py_READONLY, NULL},
    {"conversion", Py_T_INT, offsetof(struct _expr,
      v.FormattedValue.conversion), Py_READONLY, NULL},
    {"format_spec", _Py_T_OBJECT, offsetof(struct _expr,
      v.FormattedValue.format_spec), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _FormattedValue_type_slots[] = {
    {Py_tp_dealloc, &FormattedValue_dealloc},
    {Py_tp_members, FormattedValue_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "FormattedValue(expr value, int conversion, expr? format_spec)"},
    {Py_tp_new, FormattedValue_new},
    {0, 0},
};

static PyType_Spec _FormattedValue_type_spec = {
    "ast._FormattedValue",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _FormattedValue_type_slots
};



expr_ty _PyAst_FormattedValue_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_FormattedValue_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.FormattedValue.value != NULL) {
        res->v.FormattedValue.value =
        _PyAst_expr_Copy(self->v.FormattedValue.value);
        ERROR_IF_NULL(res->v.FormattedValue.value);
    } else {
        res->v.FormattedValue.value = NULL;
    }
    res->v.FormattedValue.conversion = self->v.FormattedValue.conversion;
    if (self->v.FormattedValue.format_spec != NULL) {
        res->v.FormattedValue.format_spec =
        _PyAst_expr_Copy(self->v.FormattedValue.format_spec);
        ERROR_IF_NULL(res->v.FormattedValue.format_spec);
    } else {
        res->v.FormattedValue.format_spec = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Interpolation_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 4) {
        PyErr_SetString(PyExc_TypeError,
                        "Interpolation takes at most 4 positional arguments");
        return NULL;
    }
    expr_ty value = NULL;
    constant str = NULL;
    int conversion = 0;
    bool got_conversion = false;
    expr_ty format_spec = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 8: {
            tmp = PyTuple_GET_ITEM(pargs, 7);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_expr(state, tmp, &format_spec) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &conversion) < 0) {
                goto fail;
            }
            got_conversion = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_constant(state, tmp, &str) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (str != NULL) {
            err = PyDict_PopString(kwargs, "str", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_constant(state, tmp, &str) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_conversion) {
            err = PyDict_PopString(kwargs, "conversion", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &conversion) < 0) {
                    goto fail;
                }
            }
        }
        if (format_spec != NULL) {
            err = PyDict_PopString(kwargs, "format_spec", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &format_spec) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Interpolation.value = value;
    res->v.Interpolation.str = str;
    res->v.Interpolation.conversion = conversion;
    res->v.Interpolation.format_spec = format_spec;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(value);
    Py_XDECREF(str);
    Py_XDECREF(format_spec);
    return NULL;
}

static void Interpolation_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Interpolation.value);
    Py_XDECREF(obj->v.Interpolation.str);
    Py_XDECREF(obj->v.Interpolation.format_spec);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Interpolation_members[] = {
    {"value", _Py_T_OBJECT, offsetof(struct _expr, v.Interpolation.value),
      Py_READONLY, NULL},
    {"str", _Py_T_OBJECT, offsetof(struct _expr, v.Interpolation.str),
      Py_READONLY, NULL},
    {"conversion", Py_T_INT, offsetof(struct _expr,
      v.Interpolation.conversion), Py_READONLY, NULL},
    {"format_spec", _Py_T_OBJECT, offsetof(struct _expr,
      v.Interpolation.format_spec), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Interpolation_type_slots[] = {
    {Py_tp_dealloc, &Interpolation_dealloc},
    {Py_tp_members, Interpolation_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Interpolation(expr value, constant str, int conversion, expr? format_spec)"},
    {Py_tp_new, Interpolation_new},
    {0, 0},
};

static PyType_Spec _Interpolation_type_spec = {
    "ast._Interpolation",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Interpolation_type_slots
};



expr_ty _PyAst_Interpolation_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_Interpolation_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Interpolation.value != NULL) {
        res->v.Interpolation.value =
        _PyAst_expr_Copy(self->v.Interpolation.value);
        ERROR_IF_NULL(res->v.Interpolation.value);
    } else {
        res->v.Interpolation.value = NULL;
    }
    if (self->v.Interpolation.str != NULL) {
        res->v.Interpolation.str = Py_NewRef(self->v.Interpolation.str);
        ERROR_IF_NULL(res->v.Interpolation.str);
    } else {
        res->v.Interpolation.str = NULL;
    }
    res->v.Interpolation.conversion = self->v.Interpolation.conversion;
    if (self->v.Interpolation.format_spec != NULL) {
        res->v.Interpolation.format_spec =
        _PyAst_expr_Copy(self->v.Interpolation.format_spec);
        ERROR_IF_NULL(res->v.Interpolation.format_spec);
    } else {
        res->v.Interpolation.format_spec = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
JoinedStr_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "JoinedStr takes at most 1 positional argument");
        return NULL;
    }
    asdl_expr_seq* values = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr_seq(state, tmp, "JoinedStr", "values", &values) <
                0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (values != NULL) {
            err = PyDict_PopString(kwargs, "values", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "JoinedStr", "values",
                    &values) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.JoinedStr.values = values;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(values);
    return NULL;
}

static void JoinedStr_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.JoinedStr.values);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef JoinedStr_members[] = {
    {"values", _Py_T_OBJECT, offsetof(struct _expr, v.JoinedStr.values),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _JoinedStr_type_slots[] = {
    {Py_tp_dealloc, &JoinedStr_dealloc},
    {Py_tp_members, JoinedStr_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "JoinedStr(expr* values)"},
    {Py_tp_new, JoinedStr_new},
    {0, 0},
};

static PyType_Spec _JoinedStr_type_spec = {
    "ast._JoinedStr",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _JoinedStr_type_slots
};



expr_ty _PyAst_JoinedStr_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_JoinedStr_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.JoinedStr.values != NULL) {
        res->v.JoinedStr.values =
        _PyAst_expr_seq_Copy(self->v.JoinedStr.values);
        ERROR_IF_NULL(res->v.JoinedStr.values);
    } else {
        res->v.JoinedStr.values = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
TemplateStr_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "TemplateStr takes at most 1 positional argument");
        return NULL;
    }
    asdl_expr_seq* values = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr_seq(state, tmp, "TemplateStr", "values", &values)
                < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (values != NULL) {
            err = PyDict_PopString(kwargs, "values", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "TemplateStr", "values",
                    &values) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.TemplateStr.values = values;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(values);
    return NULL;
}

static void TemplateStr_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.TemplateStr.values);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef TemplateStr_members[] = {
    {"values", _Py_T_OBJECT, offsetof(struct _expr, v.TemplateStr.values),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _TemplateStr_type_slots[] = {
    {Py_tp_dealloc, &TemplateStr_dealloc},
    {Py_tp_members, TemplateStr_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "TemplateStr(expr* values)"},
    {Py_tp_new, TemplateStr_new},
    {0, 0},
};

static PyType_Spec _TemplateStr_type_spec = {
    "ast._TemplateStr",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _TemplateStr_type_slots
};



expr_ty _PyAst_TemplateStr_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_TemplateStr_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.TemplateStr.values != NULL) {
        res->v.TemplateStr.values =
        _PyAst_expr_seq_Copy(self->v.TemplateStr.values);
        ERROR_IF_NULL(res->v.TemplateStr.values);
    } else {
        res->v.TemplateStr.values = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Constant_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Constant takes at most 2 positional arguments");
        return NULL;
    }
    constant value = NULL;
    string kind = 0;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_string(state, tmp, &kind) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_constant(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_constant(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (kind != NULL) {
            err = PyDict_PopString(kwargs, "kind", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_string(state, tmp, &kind) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Constant.value = value;
    res->v.Constant.kind = kind;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(value);
    Py_XDECREF(kind);
    return NULL;
}

static void Constant_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Constant.value);
    Py_XDECREF(obj->v.Constant.kind);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Constant_members[] = {
    {"value", _Py_T_OBJECT, offsetof(struct _expr, v.Constant.value),
      Py_READONLY, NULL},
    {"kind", _Py_T_OBJECT, offsetof(struct _expr, v.Constant.kind),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Constant_type_slots[] = {
    {Py_tp_dealloc, &Constant_dealloc},
    {Py_tp_members, Constant_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Constant(constant value, string? kind)"},
    {Py_tp_new, Constant_new},
    {0, 0},
};

static PyType_Spec _Constant_type_spec = {
    "ast._Constant",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Constant_type_slots
};



expr_ty _PyAst_Constant_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_Constant_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Constant.value != NULL) {
        res->v.Constant.value = Py_NewRef(self->v.Constant.value);
        ERROR_IF_NULL(res->v.Constant.value);
    } else {
        res->v.Constant.value = NULL;
    }
    if (self->v.Constant.kind != NULL) {
        res->v.Constant.kind = Py_NewRef(self->v.Constant.kind);
        ERROR_IF_NULL(res->v.Constant.kind);
    } else {
        res->v.Constant.kind = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Attribute_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "Attribute takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty value = NULL;
    identifier attr = NULL;
    expr_context_ty ctx = 0;
    bool got_ctx = false;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_expr_context(state, tmp, &ctx) < 0) {
                goto fail;
            }
            got_ctx = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_identifier(state, tmp, &attr) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (attr != NULL) {
            err = PyDict_PopString(kwargs, "attr", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &attr) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_ctx) {
            err = PyDict_PopString(kwargs, "ctx", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_context(state, tmp, &ctx) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Attribute.value = value;
    res->v.Attribute.attr = attr;
    res->v.Attribute.ctx = ctx;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(value);
    Py_XDECREF(attr);
    return NULL;
}

static void Attribute_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Attribute.value);
    Py_XDECREF(obj->v.Attribute.attr);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Attribute_members[] = {
    {"value", _Py_T_OBJECT, offsetof(struct _expr, v.Attribute.value),
      Py_READONLY, NULL},
    {"attr", _Py_T_OBJECT, offsetof(struct _expr, v.Attribute.attr),
      Py_READONLY, NULL},
    {"ctx", Py_T_INT, offsetof(struct _expr, v.Attribute.ctx), Py_READONLY,
      NULL},
    {0}
};

static PyType_Slot _Attribute_type_slots[] = {
    {Py_tp_dealloc, &Attribute_dealloc},
    {Py_tp_members, Attribute_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Attribute(expr value, identifier attr, expr_context ctx)"},
    {Py_tp_new, Attribute_new},
    {0, 0},
};

static PyType_Spec _Attribute_type_spec = {
    "ast._Attribute",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Attribute_type_slots
};



expr_ty _PyAst_Attribute_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_Attribute_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Attribute.value != NULL) {
        res->v.Attribute.value = _PyAst_expr_Copy(self->v.Attribute.value);
        ERROR_IF_NULL(res->v.Attribute.value);
    } else {
        res->v.Attribute.value = NULL;
    }
    if (self->v.Attribute.attr != NULL) {
        res->v.Attribute.attr = Py_NewRef(self->v.Attribute.attr);
        ERROR_IF_NULL(res->v.Attribute.attr);
    } else {
        res->v.Attribute.attr = NULL;
    }
    res->v.Attribute.ctx = self->v.Attribute.ctx;
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Subscript_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "Subscript takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty value = NULL;
    expr_ty slice = NULL;
    expr_context_ty ctx = 0;
    bool got_ctx = false;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_expr_context(state, tmp, &ctx) < 0) {
                goto fail;
            }
            got_ctx = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &slice) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (slice != NULL) {
            err = PyDict_PopString(kwargs, "slice", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &slice) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_ctx) {
            err = PyDict_PopString(kwargs, "ctx", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_context(state, tmp, &ctx) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Subscript.value = value;
    res->v.Subscript.slice = slice;
    res->v.Subscript.ctx = ctx;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(value);
    Py_XDECREF(slice);
    return NULL;
}

static void Subscript_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Subscript.value);
    Py_XDECREF(obj->v.Subscript.slice);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Subscript_members[] = {
    {"value", _Py_T_OBJECT, offsetof(struct _expr, v.Subscript.value),
      Py_READONLY, NULL},
    {"slice", _Py_T_OBJECT, offsetof(struct _expr, v.Subscript.slice),
      Py_READONLY, NULL},
    {"ctx", Py_T_INT, offsetof(struct _expr, v.Subscript.ctx), Py_READONLY,
      NULL},
    {0}
};

static PyType_Slot _Subscript_type_slots[] = {
    {Py_tp_dealloc, &Subscript_dealloc},
    {Py_tp_members, Subscript_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Subscript(expr value, expr slice, expr_context ctx)"},
    {Py_tp_new, Subscript_new},
    {0, 0},
};

static PyType_Spec _Subscript_type_spec = {
    "ast._Subscript",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Subscript_type_slots
};



expr_ty _PyAst_Subscript_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_Subscript_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Subscript.value != NULL) {
        res->v.Subscript.value = _PyAst_expr_Copy(self->v.Subscript.value);
        ERROR_IF_NULL(res->v.Subscript.value);
    } else {
        res->v.Subscript.value = NULL;
    }
    if (self->v.Subscript.slice != NULL) {
        res->v.Subscript.slice = _PyAst_expr_Copy(self->v.Subscript.slice);
        ERROR_IF_NULL(res->v.Subscript.slice);
    } else {
        res->v.Subscript.slice = NULL;
    }
    res->v.Subscript.ctx = self->v.Subscript.ctx;
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Starred_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Starred takes at most 2 positional arguments");
        return NULL;
    }
    expr_ty value = NULL;
    expr_context_ty ctx = 0;
    bool got_ctx = false;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr_context(state, tmp, &ctx) < 0) {
                goto fail;
            }
            got_ctx = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_ctx) {
            err = PyDict_PopString(kwargs, "ctx", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_context(state, tmp, &ctx) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Starred.value = value;
    res->v.Starred.ctx = ctx;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(value);
    return NULL;
}

static void Starred_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Starred.value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Starred_members[] = {
    {"value", _Py_T_OBJECT, offsetof(struct _expr, v.Starred.value),
      Py_READONLY, NULL},
    {"ctx", Py_T_INT, offsetof(struct _expr, v.Starred.ctx), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Starred_type_slots[] = {
    {Py_tp_dealloc, &Starred_dealloc},
    {Py_tp_members, Starred_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Starred(expr value, expr_context ctx)"},
    {Py_tp_new, Starred_new},
    {0, 0},
};

static PyType_Spec _Starred_type_spec = {
    "ast._Starred",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Starred_type_slots
};



expr_ty _PyAst_Starred_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_Starred_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Starred.value != NULL) {
        res->v.Starred.value = _PyAst_expr_Copy(self->v.Starred.value);
        ERROR_IF_NULL(res->v.Starred.value);
    } else {
        res->v.Starred.value = NULL;
    }
    res->v.Starred.ctx = self->v.Starred.ctx;
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Name_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Name takes at most 2 positional arguments");
        return NULL;
    }
    identifier id = NULL;
    expr_context_ty ctx = 0;
    bool got_ctx = false;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr_context(state, tmp, &ctx) < 0) {
                goto fail;
            }
            got_ctx = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier(state, tmp, &id) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (id != NULL) {
            err = PyDict_PopString(kwargs, "id", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &id) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_ctx) {
            err = PyDict_PopString(kwargs, "ctx", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_context(state, tmp, &ctx) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Name.id = id;
    res->v.Name.ctx = ctx;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(id);
    return NULL;
}

static void Name_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Name.id);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Name_members[] = {
    {"id", _Py_T_OBJECT, offsetof(struct _expr, v.Name.id), Py_READONLY, NULL},
    {"ctx", Py_T_INT, offsetof(struct _expr, v.Name.ctx), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Name_type_slots[] = {
    {Py_tp_dealloc, &Name_dealloc},
    {Py_tp_members, Name_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Name(identifier id, expr_context ctx)"},
    {Py_tp_new, Name_new},
    {0, 0},
};

static PyType_Spec _Name_type_spec = {
    "ast._Name",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Name_type_slots
};



expr_ty _PyAst_Name_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject *)state->_Name_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Name.id != NULL) {
        res->v.Name.id = Py_NewRef(self->v.Name.id);
        ERROR_IF_NULL(res->v.Name.id);
    } else {
        res->v.Name.id = NULL;
    }
    res->v.Name.ctx = self->v.Name.ctx;
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
List_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "List takes at most 2 positional arguments");
        return NULL;
    }
    asdl_expr_seq* elts = NULL;
    expr_context_ty ctx = 0;
    bool got_ctx = false;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr_context(state, tmp, &ctx) < 0) {
                goto fail;
            }
            got_ctx = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr_seq(state, tmp, "List", "elts", &elts) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (elts != NULL) {
            err = PyDict_PopString(kwargs, "elts", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "List", "elts", &elts) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_ctx) {
            err = PyDict_PopString(kwargs, "ctx", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_context(state, tmp, &ctx) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.List.elts = elts;
    res->v.List.ctx = ctx;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(elts);
    return NULL;
}

static void List_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.List.elts);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef List_members[] = {
    {"elts", _Py_T_OBJECT, offsetof(struct _expr, v.List.elts), Py_READONLY,
      NULL},
    {"ctx", Py_T_INT, offsetof(struct _expr, v.List.ctx), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _List_type_slots[] = {
    {Py_tp_dealloc, &List_dealloc},
    {Py_tp_members, List_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "List(expr* elts, expr_context ctx)"},
    {Py_tp_new, List_new},
    {0, 0},
};

static PyType_Spec _List_type_spec = {
    "ast._List",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _List_type_slots
};



expr_ty _PyAst_List_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject *)state->_List_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.List.elts != NULL) {
        res->v.List.elts = _PyAst_expr_seq_Copy(self->v.List.elts);
        ERROR_IF_NULL(res->v.List.elts);
    } else {
        res->v.List.elts = NULL;
    }
    res->v.List.ctx = self->v.List.ctx;
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Tuple_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Tuple takes at most 2 positional arguments");
        return NULL;
    }
    asdl_expr_seq* elts = NULL;
    expr_context_ty ctx = 0;
    bool got_ctx = false;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr_context(state, tmp, &ctx) < 0) {
                goto fail;
            }
            got_ctx = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr_seq(state, tmp, "Tuple", "elts", &elts) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (elts != NULL) {
            err = PyDict_PopString(kwargs, "elts", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "Tuple", "elts", &elts) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_ctx) {
            err = PyDict_PopString(kwargs, "ctx", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_context(state, tmp, &ctx) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Tuple.elts = elts;
    res->v.Tuple.ctx = ctx;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(elts);
    return NULL;
}

static void Tuple_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Tuple.elts);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Tuple_members[] = {
    {"elts", _Py_T_OBJECT, offsetof(struct _expr, v.Tuple.elts), Py_READONLY,
      NULL},
    {"ctx", Py_T_INT, offsetof(struct _expr, v.Tuple.ctx), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _Tuple_type_slots[] = {
    {Py_tp_dealloc, &Tuple_dealloc},
    {Py_tp_members, Tuple_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Tuple(expr* elts, expr_context ctx)"},
    {Py_tp_new, Tuple_new},
    {0, 0},
};

static PyType_Spec _Tuple_type_spec = {
    "ast._Tuple",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Tuple_type_slots
};



expr_ty _PyAst_Tuple_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_Tuple_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Tuple.elts != NULL) {
        res->v.Tuple.elts = _PyAst_expr_seq_Copy(self->v.Tuple.elts);
        ERROR_IF_NULL(res->v.Tuple.elts);
    } else {
        res->v.Tuple.elts = NULL;
    }
    res->v.Tuple.ctx = self->v.Tuple.ctx;
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
Slice_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "Slice takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty lower = NULL;
    expr_ty upper = NULL;
    expr_ty step = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_expr(state, tmp, &step) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &upper) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &lower) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (lower != NULL) {
            err = PyDict_PopString(kwargs, "lower", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &lower) < 0) {
                    goto fail;
                }
            }
        }
        if (upper != NULL) {
            err = PyDict_PopString(kwargs, "upper", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &upper) < 0) {
                    goto fail;
                }
            }
        }
        if (step != NULL) {
            err = PyDict_PopString(kwargs, "step", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &step) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.Slice.lower = lower;
    res->v.Slice.upper = upper;
    res->v.Slice.step = step;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(lower);
    Py_XDECREF(upper);
    Py_XDECREF(step);
    return NULL;
}

static void Slice_dealloc(PyObject *self) {
    expr_ty obj = (expr_ty)self;
    Py_XDECREF(obj->v.Slice.lower);
    Py_XDECREF(obj->v.Slice.upper);
    Py_XDECREF(obj->v.Slice.step);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Slice_members[] = {
    {"lower", _Py_T_OBJECT, offsetof(struct _expr, v.Slice.lower), Py_READONLY,
      NULL},
    {"upper", _Py_T_OBJECT, offsetof(struct _expr, v.Slice.upper), Py_READONLY,
      NULL},
    {"step", _Py_T_OBJECT, offsetof(struct _expr, v.Slice.step), Py_READONLY,
      NULL},
    {0}
};

static PyType_Slot _Slice_type_slots[] = {
    {Py_tp_dealloc, &Slice_dealloc},
    {Py_tp_members, Slice_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Slice(expr? lower, expr? upper, expr? step)"},
    {Py_tp_new, Slice_new},
    {0, 0},
};

static PyType_Spec _Slice_type_spec = {
    "ast._Slice",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Slice_type_slots
};



expr_ty _PyAst_Slice_Copy(expr_ty self) {
    struct ast_state *state = get_ast_state();
    expr_ty res = PyObject_New(struct _expr, (PyTypeObject
                               *)state->_Slice_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.Slice.lower != NULL) {
        res->v.Slice.lower = _PyAst_expr_Copy(self->v.Slice.lower);
        ERROR_IF_NULL(res->v.Slice.lower);
    } else {
        res->v.Slice.lower = NULL;
    }
    if (self->v.Slice.upper != NULL) {
        res->v.Slice.upper = _PyAst_expr_Copy(self->v.Slice.upper);
        ERROR_IF_NULL(res->v.Slice.upper);
    } else {
        res->v.Slice.upper = NULL;
    }
    if (self->v.Slice.step != NULL) {
        res->v.Slice.step = _PyAst_expr_Copy(self->v.Slice.step);
        ERROR_IF_NULL(res->v.Slice.step);
    } else {
        res->v.Slice.step = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}


expr_ty _PyAst_expr_Copy(expr_ty node) {
    switch (node->kind) {
        case BoolOp_kind:
            return _PyAst_BoolOp_Copy(node);
        case NamedExpr_kind:
            return _PyAst_NamedExpr_Copy(node);
        case BinOp_kind:
            return _PyAst_BinOp_Copy(node);
        case UnaryOp_kind:
            return _PyAst_UnaryOp_Copy(node);
        case Lambda_kind:
            return _PyAst_Lambda_Copy(node);
        case IfExp_kind:
            return _PyAst_IfExp_Copy(node);
        case Dict_kind:
            return _PyAst_Dict_Copy(node);
        case Set_kind:
            return _PyAst_Set_Copy(node);
        case ListComp_kind:
            return _PyAst_ListComp_Copy(node);
        case SetComp_kind:
            return _PyAst_SetComp_Copy(node);
        case DictComp_kind:
            return _PyAst_DictComp_Copy(node);
        case GeneratorExp_kind:
            return _PyAst_GeneratorExp_Copy(node);
        case Await_kind:
            return _PyAst_Await_Copy(node);
        case Yield_kind:
            return _PyAst_Yield_Copy(node);
        case YieldFrom_kind:
            return _PyAst_YieldFrom_Copy(node);
        case Compare_kind:
            return _PyAst_Compare_Copy(node);
        case Call_kind:
            return _PyAst_Call_Copy(node);
        case FormattedValue_kind:
            return _PyAst_FormattedValue_Copy(node);
        case Interpolation_kind:
            return _PyAst_Interpolation_Copy(node);
        case JoinedStr_kind:
            return _PyAst_JoinedStr_Copy(node);
        case TemplateStr_kind:
            return _PyAst_TemplateStr_Copy(node);
        case Constant_kind:
            return _PyAst_Constant_Copy(node);
        case Attribute_kind:
            return _PyAst_Attribute_Copy(node);
        case Subscript_kind:
            return _PyAst_Subscript_Copy(node);
        case Starred_kind:
            return _PyAst_Starred_Copy(node);
        case Name_kind:
            return _PyAst_Name_Copy(node);
        case List_kind:
            return _PyAst_List_Copy(node);
        case Tuple_kind:
            return _PyAst_Tuple_Copy(node);
        case Slice_kind:
            return _PyAst_Slice_Copy(node);
    }
    return NULL;
}

static PyObject *
expr_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "expr takes at most 0 positional arguments");
        return NULL;
    }
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _expr *res = (struct _expr*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    return NULL;
}

static void expr_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef expr_members[] = {
    {0}
};

static PyType_Slot _expr_type_slots[] = {
    {Py_tp_dealloc, &expr_dealloc},
    {Py_tp_members, expr_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "expr = BoolOp(boolop op, expr* values)\n"
        "     | NamedExpr(expr target, expr value)\n"
        "     | BinOp(expr left, operator op, expr right)\n"
        "     | UnaryOp(unaryop op, expr operand)\n"
        "     | Lambda(arguments args, expr body)\n"
        "     | IfExp(expr test, expr body, expr orelse)\n"
        "     | Dict(expr?* keys, expr* values)\n"
        "     | Set(expr* elts)\n"
        "     | ListComp(expr elt, comprehension* generators)\n"
        "     | SetComp(expr elt, comprehension* generators)\n"
        "     | DictComp(expr key, expr value, comprehension* generators)\n"
        "     | GeneratorExp(expr elt, comprehension* generators)\n"
        "     | Await(expr value)\n"
        "     | Yield(expr? value)\n"
        "     | YieldFrom(expr value)\n"
        "     | Compare(expr left, cmpop* ops, expr* comparators)\n"
        "     | Call(expr func, expr* args, keyword* keywords)\n"
        "     | FormattedValue(expr value, int conversion, expr? format_spec)\n"
        "     | Interpolation(expr value, constant str, int conversion, expr? format_spec)\n"
        "     | JoinedStr(expr* values)\n"
        "     | TemplateStr(expr* values)\n"
        "     | Constant(constant value, string? kind)\n"
        "     | Attribute(expr value, identifier attr, expr_context ctx)\n"
        "     | Subscript(expr value, expr slice, expr_context ctx)\n"
        "     | Starred(expr value, expr_context ctx)\n"
        "     | Name(identifier id, expr_context ctx)\n"
        "     | List(expr* elts, expr_context ctx)\n"
        "     | Tuple(expr* elts, expr_context ctx)\n"
        "     | Slice(expr? lower, expr? upper, expr? step)"},
    {Py_tp_new, expr_new},
    {0, 0},
};

static PyType_Spec _expr_type_spec = {
    "ast._expr",
    sizeof(struct _expr),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _expr_type_slots
};



static void expr_seq_dealloc(PyObject *self) {
    asdl_expr_seq *obj = (asdl_expr_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_expr_seq_type_slots[] = {
    {Py_tp_dealloc, &expr_seq_dealloc},
    //{Py_tp_members, expr_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _expr_seq_type_spec = {
    "ast._expr_seq",
    sizeof(asdl_expr_seq) - sizeof(expr_ty),
    sizeof(expr_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_expr_seq_type_slots
};

asdl_expr_seq *_PyAst_expr_seq_Copy(asdl_expr_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_expr_seq *res = PyObject_NewVar(asdl_expr_seq, (PyTypeObject *)state->_expr_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] = _PyAst_expr_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
expr_context_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "expr_context takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    return pytype->tp_alloc(pytype, 0);
fail:
    return NULL;
}

static void expr_context_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef expr_context_members[] = {
    {0}
};

static PyType_Slot _expr_context_type_slots[] = {
    {Py_tp_dealloc, &expr_context_dealloc},
    {Py_tp_members, expr_context_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "expr_context = Load | Store | Del"},
    {Py_tp_new, expr_context_new},
    {0, 0},
};

static PyType_Spec _expr_context_type_spec = {
    "ast._expr_context",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _expr_context_type_slots
};



static PyObject *
Load_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Load takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Load_singleton);
fail:
    return NULL;
}

static void Load_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Load_members[] = {
    {0}
};

static PyType_Slot _Load_type_slots[] = {
    {Py_tp_dealloc, &Load_dealloc},
    {Py_tp_members, Load_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Load"},
    {Py_tp_new, Load_new},
    {0, 0},
};

static PyType_Spec _Load_type_spec = {
    "ast._Load",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Load_type_slots
};



static PyObject *
Store_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Store takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Store_singleton);
fail:
    return NULL;
}

static void Store_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Store_members[] = {
    {0}
};

static PyType_Slot _Store_type_slots[] = {
    {Py_tp_dealloc, &Store_dealloc},
    {Py_tp_members, Store_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Store"},
    {Py_tp_new, Store_new},
    {0, 0},
};

static PyType_Spec _Store_type_spec = {
    "ast._Store",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Store_type_slots
};



static PyObject *
Del_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Del takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Del_singleton);
fail:
    return NULL;
}

static void Del_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Del_members[] = {
    {0}
};

static PyType_Slot _Del_type_slots[] = {
    {Py_tp_dealloc, &Del_dealloc},
    {Py_tp_members, Del_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Del"},
    {Py_tp_new, Del_new},
    {0, 0},
};

static PyType_Spec _Del_type_spec = {
    "ast._Del",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Del_type_slots
};



static PyObject *
boolop_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "boolop takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    return pytype->tp_alloc(pytype, 0);
fail:
    return NULL;
}

static void boolop_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef boolop_members[] = {
    {0}
};

static PyType_Slot _boolop_type_slots[] = {
    {Py_tp_dealloc, &boolop_dealloc},
    {Py_tp_members, boolop_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "boolop = And | Or"},
    {Py_tp_new, boolop_new},
    {0, 0},
};

static PyType_Spec _boolop_type_spec = {
    "ast._boolop",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _boolop_type_slots
};



static PyObject *
And_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "And takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_And_singleton);
fail:
    return NULL;
}

static void And_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef And_members[] = {
    {0}
};

static PyType_Slot _And_type_slots[] = {
    {Py_tp_dealloc, &And_dealloc},
    {Py_tp_members, And_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "And"},
    {Py_tp_new, And_new},
    {0, 0},
};

static PyType_Spec _And_type_spec = {
    "ast._And",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _And_type_slots
};



static PyObject *
Or_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Or takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Or_singleton);
fail:
    return NULL;
}

static void Or_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Or_members[] = {
    {0}
};

static PyType_Slot _Or_type_slots[] = {
    {Py_tp_dealloc, &Or_dealloc},
    {Py_tp_members, Or_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Or"},
    {Py_tp_new, Or_new},
    {0, 0},
};

static PyType_Spec _Or_type_spec = {
    "ast._Or",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Or_type_slots
};



static PyObject *
operator_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "operator takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    return pytype->tp_alloc(pytype, 0);
fail:
    return NULL;
}

static void operator_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef operator_members[] = {
    {0}
};

static PyType_Slot _operator_type_slots[] = {
    {Py_tp_dealloc, &operator_dealloc},
    {Py_tp_members, operator_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift | RShift | BitOr | BitXor | BitAnd | FloorDiv"},
    {Py_tp_new, operator_new},
    {0, 0},
};

static PyType_Spec _operator_type_spec = {
    "ast._operator",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _operator_type_slots
};



static PyObject *
Add_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Add takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Add_singleton);
fail:
    return NULL;
}

static void Add_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Add_members[] = {
    {0}
};

static PyType_Slot _Add_type_slots[] = {
    {Py_tp_dealloc, &Add_dealloc},
    {Py_tp_members, Add_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Add"},
    {Py_tp_new, Add_new},
    {0, 0},
};

static PyType_Spec _Add_type_spec = {
    "ast._Add",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Add_type_slots
};



static PyObject *
Sub_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Sub takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Sub_singleton);
fail:
    return NULL;
}

static void Sub_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Sub_members[] = {
    {0}
};

static PyType_Slot _Sub_type_slots[] = {
    {Py_tp_dealloc, &Sub_dealloc},
    {Py_tp_members, Sub_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Sub"},
    {Py_tp_new, Sub_new},
    {0, 0},
};

static PyType_Spec _Sub_type_spec = {
    "ast._Sub",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Sub_type_slots
};



static PyObject *
Mult_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Mult takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Mult_singleton);
fail:
    return NULL;
}

static void Mult_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Mult_members[] = {
    {0}
};

static PyType_Slot _Mult_type_slots[] = {
    {Py_tp_dealloc, &Mult_dealloc},
    {Py_tp_members, Mult_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Mult"},
    {Py_tp_new, Mult_new},
    {0, 0},
};

static PyType_Spec _Mult_type_spec = {
    "ast._Mult",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Mult_type_slots
};



static PyObject *
MatMult_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "MatMult takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_MatMult_singleton);
fail:
    return NULL;
}

static void MatMult_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef MatMult_members[] = {
    {0}
};

static PyType_Slot _MatMult_type_slots[] = {
    {Py_tp_dealloc, &MatMult_dealloc},
    {Py_tp_members, MatMult_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "MatMult"},
    {Py_tp_new, MatMult_new},
    {0, 0},
};

static PyType_Spec _MatMult_type_spec = {
    "ast._MatMult",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _MatMult_type_slots
};



static PyObject *
Div_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Div takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Div_singleton);
fail:
    return NULL;
}

static void Div_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Div_members[] = {
    {0}
};

static PyType_Slot _Div_type_slots[] = {
    {Py_tp_dealloc, &Div_dealloc},
    {Py_tp_members, Div_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Div"},
    {Py_tp_new, Div_new},
    {0, 0},
};

static PyType_Spec _Div_type_spec = {
    "ast._Div",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Div_type_slots
};



static PyObject *
Mod_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Mod takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Mod_singleton);
fail:
    return NULL;
}

static void Mod_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Mod_members[] = {
    {0}
};

static PyType_Slot _Mod_type_slots[] = {
    {Py_tp_dealloc, &Mod_dealloc},
    {Py_tp_members, Mod_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Mod"},
    {Py_tp_new, Mod_new},
    {0, 0},
};

static PyType_Spec _Mod_type_spec = {
    "ast._Mod",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Mod_type_slots
};



static PyObject *
Pow_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Pow takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Pow_singleton);
fail:
    return NULL;
}

static void Pow_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Pow_members[] = {
    {0}
};

static PyType_Slot _Pow_type_slots[] = {
    {Py_tp_dealloc, &Pow_dealloc},
    {Py_tp_members, Pow_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Pow"},
    {Py_tp_new, Pow_new},
    {0, 0},
};

static PyType_Spec _Pow_type_spec = {
    "ast._Pow",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Pow_type_slots
};



static PyObject *
LShift_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "LShift takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_LShift_singleton);
fail:
    return NULL;
}

static void LShift_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef LShift_members[] = {
    {0}
};

static PyType_Slot _LShift_type_slots[] = {
    {Py_tp_dealloc, &LShift_dealloc},
    {Py_tp_members, LShift_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "LShift"},
    {Py_tp_new, LShift_new},
    {0, 0},
};

static PyType_Spec _LShift_type_spec = {
    "ast._LShift",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _LShift_type_slots
};



static PyObject *
RShift_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "RShift takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_RShift_singleton);
fail:
    return NULL;
}

static void RShift_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef RShift_members[] = {
    {0}
};

static PyType_Slot _RShift_type_slots[] = {
    {Py_tp_dealloc, &RShift_dealloc},
    {Py_tp_members, RShift_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "RShift"},
    {Py_tp_new, RShift_new},
    {0, 0},
};

static PyType_Spec _RShift_type_spec = {
    "ast._RShift",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _RShift_type_slots
};



static PyObject *
BitOr_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "BitOr takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_BitOr_singleton);
fail:
    return NULL;
}

static void BitOr_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef BitOr_members[] = {
    {0}
};

static PyType_Slot _BitOr_type_slots[] = {
    {Py_tp_dealloc, &BitOr_dealloc},
    {Py_tp_members, BitOr_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "BitOr"},
    {Py_tp_new, BitOr_new},
    {0, 0},
};

static PyType_Spec _BitOr_type_spec = {
    "ast._BitOr",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _BitOr_type_slots
};



static PyObject *
BitXor_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "BitXor takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_BitXor_singleton);
fail:
    return NULL;
}

static void BitXor_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef BitXor_members[] = {
    {0}
};

static PyType_Slot _BitXor_type_slots[] = {
    {Py_tp_dealloc, &BitXor_dealloc},
    {Py_tp_members, BitXor_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "BitXor"},
    {Py_tp_new, BitXor_new},
    {0, 0},
};

static PyType_Spec _BitXor_type_spec = {
    "ast._BitXor",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _BitXor_type_slots
};



static PyObject *
BitAnd_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "BitAnd takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_BitAnd_singleton);
fail:
    return NULL;
}

static void BitAnd_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef BitAnd_members[] = {
    {0}
};

static PyType_Slot _BitAnd_type_slots[] = {
    {Py_tp_dealloc, &BitAnd_dealloc},
    {Py_tp_members, BitAnd_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "BitAnd"},
    {Py_tp_new, BitAnd_new},
    {0, 0},
};

static PyType_Spec _BitAnd_type_spec = {
    "ast._BitAnd",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _BitAnd_type_slots
};



static PyObject *
FloorDiv_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "FloorDiv takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_FloorDiv_singleton);
fail:
    return NULL;
}

static void FloorDiv_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef FloorDiv_members[] = {
    {0}
};

static PyType_Slot _FloorDiv_type_slots[] = {
    {Py_tp_dealloc, &FloorDiv_dealloc},
    {Py_tp_members, FloorDiv_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "FloorDiv"},
    {Py_tp_new, FloorDiv_new},
    {0, 0},
};

static PyType_Spec _FloorDiv_type_spec = {
    "ast._FloorDiv",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _FloorDiv_type_slots
};



static PyObject *
unaryop_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "unaryop takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    return pytype->tp_alloc(pytype, 0);
fail:
    return NULL;
}

static void unaryop_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef unaryop_members[] = {
    {0}
};

static PyType_Slot _unaryop_type_slots[] = {
    {Py_tp_dealloc, &unaryop_dealloc},
    {Py_tp_members, unaryop_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "unaryop = Invert | Not | UAdd | USub"},
    {Py_tp_new, unaryop_new},
    {0, 0},
};

static PyType_Spec _unaryop_type_spec = {
    "ast._unaryop",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _unaryop_type_slots
};



static PyObject *
Invert_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Invert takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Invert_singleton);
fail:
    return NULL;
}

static void Invert_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Invert_members[] = {
    {0}
};

static PyType_Slot _Invert_type_slots[] = {
    {Py_tp_dealloc, &Invert_dealloc},
    {Py_tp_members, Invert_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Invert"},
    {Py_tp_new, Invert_new},
    {0, 0},
};

static PyType_Spec _Invert_type_spec = {
    "ast._Invert",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Invert_type_slots
};



static PyObject *
Not_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Not takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Not_singleton);
fail:
    return NULL;
}

static void Not_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Not_members[] = {
    {0}
};

static PyType_Slot _Not_type_slots[] = {
    {Py_tp_dealloc, &Not_dealloc},
    {Py_tp_members, Not_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Not"},
    {Py_tp_new, Not_new},
    {0, 0},
};

static PyType_Spec _Not_type_spec = {
    "ast._Not",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Not_type_slots
};



static PyObject *
UAdd_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "UAdd takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_UAdd_singleton);
fail:
    return NULL;
}

static void UAdd_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef UAdd_members[] = {
    {0}
};

static PyType_Slot _UAdd_type_slots[] = {
    {Py_tp_dealloc, &UAdd_dealloc},
    {Py_tp_members, UAdd_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "UAdd"},
    {Py_tp_new, UAdd_new},
    {0, 0},
};

static PyType_Spec _UAdd_type_spec = {
    "ast._UAdd",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _UAdd_type_slots
};



static PyObject *
USub_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "USub takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_USub_singleton);
fail:
    return NULL;
}

static void USub_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef USub_members[] = {
    {0}
};

static PyType_Slot _USub_type_slots[] = {
    {Py_tp_dealloc, &USub_dealloc},
    {Py_tp_members, USub_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "USub"},
    {Py_tp_new, USub_new},
    {0, 0},
};

static PyType_Spec _USub_type_spec = {
    "ast._USub",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _USub_type_slots
};



static PyObject *
cmpop_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "cmpop takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    return pytype->tp_alloc(pytype, 0);
fail:
    return NULL;
}

static void cmpop_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef cmpop_members[] = {
    {0}
};

static PyType_Slot _cmpop_type_slots[] = {
    {Py_tp_dealloc, &cmpop_dealloc},
    {Py_tp_members, cmpop_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn"},
    {Py_tp_new, cmpop_new},
    {0, 0},
};

static PyType_Spec _cmpop_type_spec = {
    "ast._cmpop",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _cmpop_type_slots
};



static PyObject *
Eq_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Eq takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Eq_singleton);
fail:
    return NULL;
}

static void Eq_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Eq_members[] = {
    {0}
};

static PyType_Slot _Eq_type_slots[] = {
    {Py_tp_dealloc, &Eq_dealloc},
    {Py_tp_members, Eq_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Eq"},
    {Py_tp_new, Eq_new},
    {0, 0},
};

static PyType_Spec _Eq_type_spec = {
    "ast._Eq",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Eq_type_slots
};



static PyObject *
NotEq_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "NotEq takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_NotEq_singleton);
fail:
    return NULL;
}

static void NotEq_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef NotEq_members[] = {
    {0}
};

static PyType_Slot _NotEq_type_slots[] = {
    {Py_tp_dealloc, &NotEq_dealloc},
    {Py_tp_members, NotEq_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "NotEq"},
    {Py_tp_new, NotEq_new},
    {0, 0},
};

static PyType_Spec _NotEq_type_spec = {
    "ast._NotEq",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _NotEq_type_slots
};



static PyObject *
Lt_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Lt takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Lt_singleton);
fail:
    return NULL;
}

static void Lt_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Lt_members[] = {
    {0}
};

static PyType_Slot _Lt_type_slots[] = {
    {Py_tp_dealloc, &Lt_dealloc},
    {Py_tp_members, Lt_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Lt"},
    {Py_tp_new, Lt_new},
    {0, 0},
};

static PyType_Spec _Lt_type_spec = {
    "ast._Lt",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Lt_type_slots
};



static PyObject *
LtE_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "LtE takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_LtE_singleton);
fail:
    return NULL;
}

static void LtE_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef LtE_members[] = {
    {0}
};

static PyType_Slot _LtE_type_slots[] = {
    {Py_tp_dealloc, &LtE_dealloc},
    {Py_tp_members, LtE_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "LtE"},
    {Py_tp_new, LtE_new},
    {0, 0},
};

static PyType_Spec _LtE_type_spec = {
    "ast._LtE",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _LtE_type_slots
};



static PyObject *
Gt_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Gt takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Gt_singleton);
fail:
    return NULL;
}

static void Gt_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Gt_members[] = {
    {0}
};

static PyType_Slot _Gt_type_slots[] = {
    {Py_tp_dealloc, &Gt_dealloc},
    {Py_tp_members, Gt_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Gt"},
    {Py_tp_new, Gt_new},
    {0, 0},
};

static PyType_Spec _Gt_type_spec = {
    "ast._Gt",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Gt_type_slots
};



static PyObject *
GtE_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "GtE takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_GtE_singleton);
fail:
    return NULL;
}

static void GtE_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef GtE_members[] = {
    {0}
};

static PyType_Slot _GtE_type_slots[] = {
    {Py_tp_dealloc, &GtE_dealloc},
    {Py_tp_members, GtE_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "GtE"},
    {Py_tp_new, GtE_new},
    {0, 0},
};

static PyType_Spec _GtE_type_spec = {
    "ast._GtE",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _GtE_type_slots
};



static PyObject *
Is_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "Is takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_Is_singleton);
fail:
    return NULL;
}

static void Is_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef Is_members[] = {
    {0}
};

static PyType_Slot _Is_type_slots[] = {
    {Py_tp_dealloc, &Is_dealloc},
    {Py_tp_members, Is_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "Is"},
    {Py_tp_new, Is_new},
    {0, 0},
};

static PyType_Spec _Is_type_spec = {
    "ast._Is",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _Is_type_slots
};



static PyObject *
IsNot_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "IsNot takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_IsNot_singleton);
fail:
    return NULL;
}

static void IsNot_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef IsNot_members[] = {
    {0}
};

static PyType_Slot _IsNot_type_slots[] = {
    {Py_tp_dealloc, &IsNot_dealloc},
    {Py_tp_members, IsNot_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "IsNot"},
    {Py_tp_new, IsNot_new},
    {0, 0},
};

static PyType_Spec _IsNot_type_spec = {
    "ast._IsNot",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _IsNot_type_slots
};



static PyObject *
In_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "In takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_In_singleton);
fail:
    return NULL;
}

static void In_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef In_members[] = {
    {0}
};

static PyType_Slot _In_type_slots[] = {
    {Py_tp_dealloc, &In_dealloc},
    {Py_tp_members, In_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "In"},
    {Py_tp_new, In_new},
    {0, 0},
};

static PyType_Spec _In_type_spec = {
    "ast._In",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _In_type_slots
};



static PyObject *
NotIn_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "NotIn takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct ast_state *state = get_ast_state();
    return Py_NewRef(state->_NotIn_singleton);
fail:
    return NULL;
}

static void NotIn_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef NotIn_members[] = {
    {0}
};

static PyType_Slot _NotIn_type_slots[] = {
    {Py_tp_dealloc, &NotIn_dealloc},
    {Py_tp_members, NotIn_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "NotIn"},
    {Py_tp_new, NotIn_new},
    {0, 0},
};

static PyType_Spec _NotIn_type_spec = {
    "ast._NotIn",
    sizeof(struct _object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _NotIn_type_slots
};



static void comprehension_seq_dealloc(PyObject *self) {
    asdl_comprehension_seq *obj = (asdl_comprehension_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_comprehension_seq_type_slots[] = {
    {Py_tp_dealloc, &comprehension_seq_dealloc},
    //{Py_tp_members, comprehension_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _comprehension_seq_type_spec = {
    "ast._comprehension_seq",
    sizeof(asdl_comprehension_seq) - sizeof(comprehension_ty),
    sizeof(comprehension_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_comprehension_seq_type_slots
};

asdl_comprehension_seq *_PyAst_comprehension_seq_Copy(asdl_comprehension_seq
                                                      *seq) {
    struct ast_state *state = get_ast_state();
    asdl_comprehension_seq *res = PyObject_NewVar(asdl_comprehension_seq, (PyTypeObject *)state->_comprehension_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] =
            _PyAst_comprehension_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
comprehension_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 4) {
        PyErr_SetString(PyExc_TypeError,
                        "comprehension takes at most 4 positional arguments");
        return NULL;
    }
    expr_ty target = NULL;
    expr_ty iter = NULL;
    asdl_expr_seq* ifs = NULL;
    int is_async = 0;
    bool got_is_async = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &is_async) < 0) {
                goto fail;
            }
            got_is_async = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_expr_seq(state, tmp, "comprehension", "ifs", &ifs) < 0)
                {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &iter) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &target) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (target != NULL) {
            err = PyDict_PopString(kwargs, "target", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &target) < 0) {
                    goto fail;
                }
            }
        }
        if (iter != NULL) {
            err = PyDict_PopString(kwargs, "iter", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &iter) < 0) {
                    goto fail;
                }
            }
        }
        if (ifs != NULL) {
            err = PyDict_PopString(kwargs, "ifs", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "comprehension", "ifs", &ifs)
                    < 0) {
                    goto fail;
                }
            }
        }
        if (!got_is_async) {
            err = PyDict_PopString(kwargs, "is_async", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &is_async) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _comprehension *res = (struct
                                  _comprehension*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->target = target;
    res->iter = iter;
    res->ifs = ifs;
    res->is_async = is_async;
    return (PyObject *)res;
fail:
    Py_XDECREF(target);
    Py_XDECREF(iter);
    Py_XDECREF(ifs);
    return NULL;
}

static void comprehension_dealloc(PyObject *self) {
    comprehension_ty obj = (comprehension_ty)self;
    Py_XDECREF(obj->target);
    Py_XDECREF(obj->iter);
    Py_XDECREF(obj->ifs);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef comprehension_members[] = {
    {0}
};

static PyType_Slot _comprehension_type_slots[] = {
    {Py_tp_dealloc, &comprehension_dealloc},
    {Py_tp_members, comprehension_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "comprehension(expr target, expr iter, expr* ifs, int is_async)"},
    {Py_tp_new, comprehension_new},
    {0, 0},
};

static PyType_Spec _comprehension_type_spec = {
    "ast._comprehension",
    sizeof(struct _comprehension),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _comprehension_type_slots
};



comprehension_ty _PyAst_comprehension_Copy(comprehension_ty self) {
    struct ast_state *state = get_ast_state();
    comprehension_ty res = PyObject_New(struct _comprehension, (PyTypeObject
                                        *)state->_comprehension_type);
    if (res == NULL) {
        goto error;
    }
    if (self->target != NULL) {
        res->target = _PyAst_expr_Copy(self->target);
        ERROR_IF_NULL(res->target);
    } else {
        res->target = NULL;
    }
    if (self->iter != NULL) {
        res->iter = _PyAst_expr_Copy(self->iter);
        ERROR_IF_NULL(res->iter);
    } else {
        res->iter = NULL;
    }
    if (self->ifs != NULL) {
        res->ifs = _PyAst_expr_seq_Copy(self->ifs);
        ERROR_IF_NULL(res->ifs);
    } else {
        res->ifs = NULL;
    }
    res->is_async = self->is_async;
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
ExceptHandler_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "ExceptHandler takes at most 3 positional arguments");
        return NULL;
    }
    expr_ty type = NULL;
    identifier name = NULL;
    asdl_stmt_seq* body = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_stmt_seq(state, tmp, "ExceptHandler", "body", &body) <
                0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_identifier(state, tmp, &name) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &type) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (type != NULL) {
            err = PyDict_PopString(kwargs, "type", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &type) < 0) {
                    goto fail;
                }
            }
        }
        if (name != NULL) {
            err = PyDict_PopString(kwargs, "name", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &name) < 0) {
                    goto fail;
                }
            }
        }
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "ExceptHandler", "body",
                    &body) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _excepthandler *res = (struct
                                  _excepthandler*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.ExceptHandler.type = type;
    res->v.ExceptHandler.name = name;
    res->v.ExceptHandler.body = body;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(type);
    Py_XDECREF(name);
    Py_XDECREF(body);
    return NULL;
}

static void ExceptHandler_dealloc(PyObject *self) {
    excepthandler_ty obj = (excepthandler_ty)self;
    Py_XDECREF(obj->v.ExceptHandler.type);
    Py_XDECREF(obj->v.ExceptHandler.name);
    Py_XDECREF(obj->v.ExceptHandler.body);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef ExceptHandler_members[] = {
    {"type", _Py_T_OBJECT, offsetof(struct _excepthandler,
      v.ExceptHandler.type), Py_READONLY, NULL},
    {"name", _Py_T_OBJECT, offsetof(struct _excepthandler,
      v.ExceptHandler.name), Py_READONLY, NULL},
    {"body", _Py_T_OBJECT, offsetof(struct _excepthandler,
      v.ExceptHandler.body), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _ExceptHandler_type_slots[] = {
    {Py_tp_dealloc, &ExceptHandler_dealloc},
    {Py_tp_members, ExceptHandler_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "ExceptHandler(expr? type, identifier? name, stmt* body)"},
    {Py_tp_new, ExceptHandler_new},
    {0, 0},
};

static PyType_Spec _ExceptHandler_type_spec = {
    "ast._ExceptHandler",
    sizeof(struct _excepthandler),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _ExceptHandler_type_slots
};



excepthandler_ty _PyAst_ExceptHandler_Copy(excepthandler_ty self) {
    struct ast_state *state = get_ast_state();
    excepthandler_ty res = PyObject_New(struct _excepthandler, (PyTypeObject
                                        *)state->_ExceptHandler_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.ExceptHandler.type != NULL) {
        res->v.ExceptHandler.type =
        _PyAst_expr_Copy(self->v.ExceptHandler.type);
        ERROR_IF_NULL(res->v.ExceptHandler.type);
    } else {
        res->v.ExceptHandler.type = NULL;
    }
    if (self->v.ExceptHandler.name != NULL) {
        res->v.ExceptHandler.name = Py_NewRef(self->v.ExceptHandler.name);
        ERROR_IF_NULL(res->v.ExceptHandler.name);
    } else {
        res->v.ExceptHandler.name = NULL;
    }
    if (self->v.ExceptHandler.body != NULL) {
        res->v.ExceptHandler.body =
        _PyAst_stmt_seq_Copy(self->v.ExceptHandler.body);
        ERROR_IF_NULL(res->v.ExceptHandler.body);
    } else {
        res->v.ExceptHandler.body = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}


excepthandler_ty _PyAst_excepthandler_Copy(excepthandler_ty node) {
    switch (node->kind) {
        case ExceptHandler_kind:
            return _PyAst_ExceptHandler_Copy(node);
    }
    return NULL;
}

static PyObject *
excepthandler_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "excepthandler takes at most 0 positional arguments");
        return NULL;
    }
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _excepthandler *res = (struct
                                  _excepthandler*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    return NULL;
}

static void excepthandler_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef excepthandler_members[] = {
    {0}
};

static PyType_Slot _excepthandler_type_slots[] = {
    {Py_tp_dealloc, &excepthandler_dealloc},
    {Py_tp_members, excepthandler_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)"},
    {Py_tp_new, excepthandler_new},
    {0, 0},
};

static PyType_Spec _excepthandler_type_spec = {
    "ast._excepthandler",
    sizeof(struct _excepthandler),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _excepthandler_type_slots
};



static void excepthandler_seq_dealloc(PyObject *self) {
    asdl_excepthandler_seq *obj = (asdl_excepthandler_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_excepthandler_seq_type_slots[] = {
    {Py_tp_dealloc, &excepthandler_seq_dealloc},
    //{Py_tp_members, excepthandler_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _excepthandler_seq_type_spec = {
    "ast._excepthandler_seq",
    sizeof(asdl_excepthandler_seq) - sizeof(excepthandler_ty),
    sizeof(excepthandler_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_excepthandler_seq_type_slots
};

asdl_excepthandler_seq *_PyAst_excepthandler_seq_Copy(asdl_excepthandler_seq
                                                      *seq) {
    struct ast_state *state = get_ast_state();
    asdl_excepthandler_seq *res = PyObject_NewVar(asdl_excepthandler_seq, (PyTypeObject *)state->_excepthandler_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] =
            _PyAst_excepthandler_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static void arguments_seq_dealloc(PyObject *self) {
    asdl_arguments_seq *obj = (asdl_arguments_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_arguments_seq_type_slots[] = {
    {Py_tp_dealloc, &arguments_seq_dealloc},
    //{Py_tp_members, arguments_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _arguments_seq_type_spec = {
    "ast._arguments_seq",
    sizeof(asdl_arguments_seq) - sizeof(arguments_ty),
    sizeof(arguments_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_arguments_seq_type_slots
};

asdl_arguments_seq *_PyAst_arguments_seq_Copy(asdl_arguments_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_arguments_seq *res = PyObject_NewVar(asdl_arguments_seq, (PyTypeObject *)state->_arguments_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] =
            _PyAst_arguments_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
arguments_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 7) {
        PyErr_SetString(PyExc_TypeError,
                        "arguments takes at most 7 positional arguments");
        return NULL;
    }
    asdl_arg_seq* posonlyargs = NULL;
    asdl_arg_seq* args = NULL;
    arg_ty vararg = NULL;
    asdl_arg_seq* kwonlyargs = NULL;
    asdl_expr_seq* kw_defaults = NULL;
    arg_ty kwarg = NULL;
    asdl_expr_seq* defaults = NULL;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_expr_seq(state, tmp, "arguments", "defaults",
                &defaults) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_arg(state, tmp, &kwarg) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_expr_seq(state, tmp, "arguments", "kw_defaults",
                &kw_defaults) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_arg_seq(state, tmp, "arguments", "kwonlyargs",
                &kwonlyargs) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_arg(state, tmp, &vararg) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_arg_seq(state, tmp, "arguments", "args", &args) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_arg_seq(state, tmp, "arguments", "posonlyargs",
                &posonlyargs) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (posonlyargs != NULL) {
            err = PyDict_PopString(kwargs, "posonlyargs", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_arg_seq(state, tmp, "arguments", "posonlyargs",
                    &posonlyargs) < 0) {
                    goto fail;
                }
            }
        }
        if (args != NULL) {
            err = PyDict_PopString(kwargs, "args", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_arg_seq(state, tmp, "arguments", "args", &args) <
                    0) {
                    goto fail;
                }
            }
        }
        if (vararg != NULL) {
            err = PyDict_PopString(kwargs, "vararg", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_arg(state, tmp, &vararg) < 0) {
                    goto fail;
                }
            }
        }
        if (kwonlyargs != NULL) {
            err = PyDict_PopString(kwargs, "kwonlyargs", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_arg_seq(state, tmp, "arguments", "kwonlyargs",
                    &kwonlyargs) < 0) {
                    goto fail;
                }
            }
        }
        if (kw_defaults != NULL) {
            err = PyDict_PopString(kwargs, "kw_defaults", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "arguments", "kw_defaults",
                    &kw_defaults) < 0) {
                    goto fail;
                }
            }
        }
        if (kwarg != NULL) {
            err = PyDict_PopString(kwargs, "kwarg", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_arg(state, tmp, &kwarg) < 0) {
                    goto fail;
                }
            }
        }
        if (defaults != NULL) {
            err = PyDict_PopString(kwargs, "defaults", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "arguments", "defaults",
                    &defaults) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _arguments *res = (struct _arguments*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->posonlyargs = posonlyargs;
    res->args = args;
    res->vararg = vararg;
    res->kwonlyargs = kwonlyargs;
    res->kw_defaults = kw_defaults;
    res->kwarg = kwarg;
    res->defaults = defaults;
    return (PyObject *)res;
fail:
    Py_XDECREF(posonlyargs);
    Py_XDECREF(args);
    Py_XDECREF(vararg);
    Py_XDECREF(kwonlyargs);
    Py_XDECREF(kw_defaults);
    Py_XDECREF(kwarg);
    Py_XDECREF(defaults);
    return NULL;
}

static void arguments_dealloc(PyObject *self) {
    arguments_ty obj = (arguments_ty)self;
    Py_XDECREF(obj->posonlyargs);
    Py_XDECREF(obj->args);
    Py_XDECREF(obj->vararg);
    Py_XDECREF(obj->kwonlyargs);
    Py_XDECREF(obj->kw_defaults);
    Py_XDECREF(obj->kwarg);
    Py_XDECREF(obj->defaults);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef arguments_members[] = {
    {0}
};

static PyType_Slot _arguments_type_slots[] = {
    {Py_tp_dealloc, &arguments_dealloc},
    {Py_tp_members, arguments_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "arguments(arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs, expr* kw_defaults, arg? kwarg, expr* defaults)"},
    {Py_tp_new, arguments_new},
    {0, 0},
};

static PyType_Spec _arguments_type_spec = {
    "ast._arguments",
    sizeof(struct _arguments),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _arguments_type_slots
};



arguments_ty _PyAst_arguments_Copy(arguments_ty self) {
    struct ast_state *state = get_ast_state();
    arguments_ty res = PyObject_New(struct _arguments, (PyTypeObject
                                    *)state->_arguments_type);
    if (res == NULL) {
        goto error;
    }
    if (self->posonlyargs != NULL) {
        res->posonlyargs = _PyAst_arg_seq_Copy(self->posonlyargs);
        ERROR_IF_NULL(res->posonlyargs);
    } else {
        res->posonlyargs = NULL;
    }
    if (self->args != NULL) {
        res->args = _PyAst_arg_seq_Copy(self->args);
        ERROR_IF_NULL(res->args);
    } else {
        res->args = NULL;
    }
    if (self->vararg != NULL) {
        res->vararg = _PyAst_arg_Copy(self->vararg);
        ERROR_IF_NULL(res->vararg);
    } else {
        res->vararg = NULL;
    }
    if (self->kwonlyargs != NULL) {
        res->kwonlyargs = _PyAst_arg_seq_Copy(self->kwonlyargs);
        ERROR_IF_NULL(res->kwonlyargs);
    } else {
        res->kwonlyargs = NULL;
    }
    if (self->kw_defaults != NULL) {
        res->kw_defaults = _PyAst_expr_seq_Copy(self->kw_defaults);
        ERROR_IF_NULL(res->kw_defaults);
    } else {
        res->kw_defaults = NULL;
    }
    if (self->kwarg != NULL) {
        res->kwarg = _PyAst_arg_Copy(self->kwarg);
        ERROR_IF_NULL(res->kwarg);
    } else {
        res->kwarg = NULL;
    }
    if (self->defaults != NULL) {
        res->defaults = _PyAst_expr_seq_Copy(self->defaults);
        ERROR_IF_NULL(res->defaults);
    } else {
        res->defaults = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static void arg_seq_dealloc(PyObject *self) {
    asdl_arg_seq *obj = (asdl_arg_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_arg_seq_type_slots[] = {
    {Py_tp_dealloc, &arg_seq_dealloc},
    //{Py_tp_members, arg_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _arg_seq_type_spec = {
    "ast._arg_seq",
    sizeof(asdl_arg_seq) - sizeof(arg_ty),
    sizeof(arg_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_arg_seq_type_slots
};

asdl_arg_seq *_PyAst_arg_seq_Copy(asdl_arg_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_arg_seq *res = PyObject_NewVar(asdl_arg_seq, (PyTypeObject *)state->_arg_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] = _PyAst_arg_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
arg_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "arg takes at most 3 positional arguments");
        return NULL;
    }
    identifier arg = NULL;
    expr_ty annotation = NULL;
    string type_comment = 0;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_string(state, tmp, &type_comment) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &annotation) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier(state, tmp, &arg) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (arg != NULL) {
            err = PyDict_PopString(kwargs, "arg", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &arg) < 0) {
                    goto fail;
                }
            }
        }
        if (annotation != NULL) {
            err = PyDict_PopString(kwargs, "annotation", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &annotation) < 0) {
                    goto fail;
                }
            }
        }
        if (type_comment != NULL) {
            err = PyDict_PopString(kwargs, "type_comment", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_string(state, tmp, &type_comment) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _arg *res = (struct _arg*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->arg = arg;
    res->annotation = annotation;
    res->type_comment = type_comment;
    return (PyObject *)res;
fail:
    Py_XDECREF(arg);
    Py_XDECREF(annotation);
    Py_XDECREF(type_comment);
    return NULL;
}

static void arg_dealloc(PyObject *self) {
    arg_ty obj = (arg_ty)self;
    Py_XDECREF(obj->arg);
    Py_XDECREF(obj->annotation);
    Py_XDECREF(obj->type_comment);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef arg_members[] = {
    {0}
};

static PyType_Slot _arg_type_slots[] = {
    {Py_tp_dealloc, &arg_dealloc},
    {Py_tp_members, arg_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "arg(identifier arg, expr? annotation, string? type_comment)"},
    {Py_tp_new, arg_new},
    {0, 0},
};

static PyType_Spec _arg_type_spec = {
    "ast._arg",
    sizeof(struct _arg),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _arg_type_slots
};



arg_ty _PyAst_arg_Copy(arg_ty self) {
    struct ast_state *state = get_ast_state();
    arg_ty res = PyObject_New(struct _arg, (PyTypeObject *)state->_arg_type);
    if (res == NULL) {
        goto error;
    }
    if (self->arg != NULL) {
        res->arg = Py_NewRef(self->arg);
        ERROR_IF_NULL(res->arg);
    } else {
        res->arg = NULL;
    }
    if (self->annotation != NULL) {
        res->annotation = _PyAst_expr_Copy(self->annotation);
        ERROR_IF_NULL(res->annotation);
    } else {
        res->annotation = NULL;
    }
    if (self->type_comment != NULL) {
        res->type_comment = Py_NewRef(self->type_comment);
        ERROR_IF_NULL(res->type_comment);
    } else {
        res->type_comment = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static void keyword_seq_dealloc(PyObject *self) {
    asdl_keyword_seq *obj = (asdl_keyword_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_keyword_seq_type_slots[] = {
    {Py_tp_dealloc, &keyword_seq_dealloc},
    //{Py_tp_members, keyword_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _keyword_seq_type_spec = {
    "ast._keyword_seq",
    sizeof(asdl_keyword_seq) - sizeof(keyword_ty),
    sizeof(keyword_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_keyword_seq_type_slots
};

asdl_keyword_seq *_PyAst_keyword_seq_Copy(asdl_keyword_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_keyword_seq *res = PyObject_NewVar(asdl_keyword_seq, (PyTypeObject *)state->_keyword_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] =
            _PyAst_keyword_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
keyword_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "keyword takes at most 2 positional arguments");
        return NULL;
    }
    identifier arg = NULL;
    expr_ty value = NULL;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier(state, tmp, &arg) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (arg != NULL) {
            err = PyDict_PopString(kwargs, "arg", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &arg) < 0) {
                    goto fail;
                }
            }
        }
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _keyword *res = (struct _keyword*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->arg = arg;
    res->value = value;
    return (PyObject *)res;
fail:
    Py_XDECREF(arg);
    Py_XDECREF(value);
    return NULL;
}

static void keyword_dealloc(PyObject *self) {
    keyword_ty obj = (keyword_ty)self;
    Py_XDECREF(obj->arg);
    Py_XDECREF(obj->value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef keyword_members[] = {
    {0}
};

static PyType_Slot _keyword_type_slots[] = {
    {Py_tp_dealloc, &keyword_dealloc},
    {Py_tp_members, keyword_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "keyword(identifier? arg, expr value)"},
    {Py_tp_new, keyword_new},
    {0, 0},
};

static PyType_Spec _keyword_type_spec = {
    "ast._keyword",
    sizeof(struct _keyword),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _keyword_type_slots
};



keyword_ty _PyAst_keyword_Copy(keyword_ty self) {
    struct ast_state *state = get_ast_state();
    keyword_ty res = PyObject_New(struct _keyword, (PyTypeObject
                                  *)state->_keyword_type);
    if (res == NULL) {
        goto error;
    }
    if (self->arg != NULL) {
        res->arg = Py_NewRef(self->arg);
        ERROR_IF_NULL(res->arg);
    } else {
        res->arg = NULL;
    }
    if (self->value != NULL) {
        res->value = _PyAst_expr_Copy(self->value);
        ERROR_IF_NULL(res->value);
    } else {
        res->value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static void alias_seq_dealloc(PyObject *self) {
    asdl_alias_seq *obj = (asdl_alias_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_alias_seq_type_slots[] = {
    {Py_tp_dealloc, &alias_seq_dealloc},
    //{Py_tp_members, alias_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _alias_seq_type_spec = {
    "ast._alias_seq",
    sizeof(asdl_alias_seq) - sizeof(alias_ty),
    sizeof(alias_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_alias_seq_type_slots
};

asdl_alias_seq *_PyAst_alias_seq_Copy(asdl_alias_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_alias_seq *res = PyObject_NewVar(asdl_alias_seq, (PyTypeObject *)state->_alias_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] = _PyAst_alias_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
alias_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "alias takes at most 2 positional arguments");
        return NULL;
    }
    identifier name = NULL;
    identifier asname = NULL;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_identifier(state, tmp, &asname) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier(state, tmp, &name) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (name != NULL) {
            err = PyDict_PopString(kwargs, "name", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &name) < 0) {
                    goto fail;
                }
            }
        }
        if (asname != NULL) {
            err = PyDict_PopString(kwargs, "asname", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &asname) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _alias *res = (struct _alias*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->name = name;
    res->asname = asname;
    return (PyObject *)res;
fail:
    Py_XDECREF(name);
    Py_XDECREF(asname);
    return NULL;
}

static void alias_dealloc(PyObject *self) {
    alias_ty obj = (alias_ty)self;
    Py_XDECREF(obj->name);
    Py_XDECREF(obj->asname);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef alias_members[] = {
    {0}
};

static PyType_Slot _alias_type_slots[] = {
    {Py_tp_dealloc, &alias_dealloc},
    {Py_tp_members, alias_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "alias(identifier name, identifier? asname)"},
    {Py_tp_new, alias_new},
    {0, 0},
};

static PyType_Spec _alias_type_spec = {
    "ast._alias",
    sizeof(struct _alias),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _alias_type_slots
};



alias_ty _PyAst_alias_Copy(alias_ty self) {
    struct ast_state *state = get_ast_state();
    alias_ty res = PyObject_New(struct _alias, (PyTypeObject
                                *)state->_alias_type);
    if (res == NULL) {
        goto error;
    }
    if (self->name != NULL) {
        res->name = Py_NewRef(self->name);
        ERROR_IF_NULL(res->name);
    } else {
        res->name = NULL;
    }
    if (self->asname != NULL) {
        res->asname = Py_NewRef(self->asname);
        ERROR_IF_NULL(res->asname);
    } else {
        res->asname = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static void withitem_seq_dealloc(PyObject *self) {
    asdl_withitem_seq *obj = (asdl_withitem_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_withitem_seq_type_slots[] = {
    {Py_tp_dealloc, &withitem_seq_dealloc},
    //{Py_tp_members, withitem_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _withitem_seq_type_spec = {
    "ast._withitem_seq",
    sizeof(asdl_withitem_seq) - sizeof(withitem_ty),
    sizeof(withitem_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_withitem_seq_type_slots
};

asdl_withitem_seq *_PyAst_withitem_seq_Copy(asdl_withitem_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_withitem_seq *res = PyObject_NewVar(asdl_withitem_seq, (PyTypeObject *)state->_withitem_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] =
            _PyAst_withitem_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
withitem_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "withitem takes at most 2 positional arguments");
        return NULL;
    }
    expr_ty context_expr = NULL;
    expr_ty optional_vars = NULL;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &optional_vars) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &context_expr) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (context_expr != NULL) {
            err = PyDict_PopString(kwargs, "context_expr", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &context_expr) < 0) {
                    goto fail;
                }
            }
        }
        if (optional_vars != NULL) {
            err = PyDict_PopString(kwargs, "optional_vars", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &optional_vars) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _withitem *res = (struct _withitem*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->context_expr = context_expr;
    res->optional_vars = optional_vars;
    return (PyObject *)res;
fail:
    Py_XDECREF(context_expr);
    Py_XDECREF(optional_vars);
    return NULL;
}

static void withitem_dealloc(PyObject *self) {
    withitem_ty obj = (withitem_ty)self;
    Py_XDECREF(obj->context_expr);
    Py_XDECREF(obj->optional_vars);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef withitem_members[] = {
    {0}
};

static PyType_Slot _withitem_type_slots[] = {
    {Py_tp_dealloc, &withitem_dealloc},
    {Py_tp_members, withitem_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "withitem(expr context_expr, expr? optional_vars)"},
    {Py_tp_new, withitem_new},
    {0, 0},
};

static PyType_Spec _withitem_type_spec = {
    "ast._withitem",
    sizeof(struct _withitem),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _withitem_type_slots
};



withitem_ty _PyAst_withitem_Copy(withitem_ty self) {
    struct ast_state *state = get_ast_state();
    withitem_ty res = PyObject_New(struct _withitem, (PyTypeObject
                                   *)state->_withitem_type);
    if (res == NULL) {
        goto error;
    }
    if (self->context_expr != NULL) {
        res->context_expr = _PyAst_expr_Copy(self->context_expr);
        ERROR_IF_NULL(res->context_expr);
    } else {
        res->context_expr = NULL;
    }
    if (self->optional_vars != NULL) {
        res->optional_vars = _PyAst_expr_Copy(self->optional_vars);
        ERROR_IF_NULL(res->optional_vars);
    } else {
        res->optional_vars = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static void match_case_seq_dealloc(PyObject *self) {
    asdl_match_case_seq *obj = (asdl_match_case_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_match_case_seq_type_slots[] = {
    {Py_tp_dealloc, &match_case_seq_dealloc},
    //{Py_tp_members, match_case_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _match_case_seq_type_spec = {
    "ast._match_case_seq",
    sizeof(asdl_match_case_seq) - sizeof(match_case_ty),
    sizeof(match_case_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_match_case_seq_type_slots
};

asdl_match_case_seq *_PyAst_match_case_seq_Copy(asdl_match_case_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_match_case_seq *res = PyObject_NewVar(asdl_match_case_seq, (PyTypeObject *)state->_match_case_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] =
            _PyAst_match_case_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
match_case_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "match_case takes at most 3 positional arguments");
        return NULL;
    }
    pattern_ty pattern = NULL;
    expr_ty guard = NULL;
    asdl_stmt_seq* body = NULL;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_stmt_seq(state, tmp, "match_case", "body", &body) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &guard) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_pattern(state, tmp, &pattern) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (pattern != NULL) {
            err = PyDict_PopString(kwargs, "pattern", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_pattern(state, tmp, &pattern) < 0) {
                    goto fail;
                }
            }
        }
        if (guard != NULL) {
            err = PyDict_PopString(kwargs, "guard", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &guard) < 0) {
                    goto fail;
                }
            }
        }
        if (body != NULL) {
            err = PyDict_PopString(kwargs, "body", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_stmt_seq(state, tmp, "match_case", "body", &body) <
                    0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _match_case *res = (struct _match_case*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->pattern = pattern;
    res->guard = guard;
    res->body = body;
    return (PyObject *)res;
fail:
    Py_XDECREF(pattern);
    Py_XDECREF(guard);
    Py_XDECREF(body);
    return NULL;
}

static void match_case_dealloc(PyObject *self) {
    match_case_ty obj = (match_case_ty)self;
    Py_XDECREF(obj->pattern);
    Py_XDECREF(obj->guard);
    Py_XDECREF(obj->body);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef match_case_members[] = {
    {0}
};

static PyType_Slot _match_case_type_slots[] = {
    {Py_tp_dealloc, &match_case_dealloc},
    {Py_tp_members, match_case_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "match_case(pattern pattern, expr? guard, stmt* body)"},
    {Py_tp_new, match_case_new},
    {0, 0},
};

static PyType_Spec _match_case_type_spec = {
    "ast._match_case",
    sizeof(struct _match_case),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _match_case_type_slots
};



match_case_ty _PyAst_match_case_Copy(match_case_ty self) {
    struct ast_state *state = get_ast_state();
    match_case_ty res = PyObject_New(struct _match_case, (PyTypeObject
                                     *)state->_match_case_type);
    if (res == NULL) {
        goto error;
    }
    if (self->pattern != NULL) {
        res->pattern = _PyAst_pattern_Copy(self->pattern);
        ERROR_IF_NULL(res->pattern);
    } else {
        res->pattern = NULL;
    }
    if (self->guard != NULL) {
        res->guard = _PyAst_expr_Copy(self->guard);
        ERROR_IF_NULL(res->guard);
    } else {
        res->guard = NULL;
    }
    if (self->body != NULL) {
        res->body = _PyAst_stmt_seq_Copy(self->body);
        ERROR_IF_NULL(res->body);
    } else {
        res->body = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
MatchValue_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "MatchValue takes at most 1 positional argument");
        return NULL;
    }
    expr_ty value = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _pattern *res = (struct _pattern*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.MatchValue.value = value;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(value);
    return NULL;
}

static void MatchValue_dealloc(PyObject *self) {
    pattern_ty obj = (pattern_ty)self;
    Py_XDECREF(obj->v.MatchValue.value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef MatchValue_members[] = {
    {"value", _Py_T_OBJECT, offsetof(struct _pattern, v.MatchValue.value),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _MatchValue_type_slots[] = {
    {Py_tp_dealloc, &MatchValue_dealloc},
    {Py_tp_members, MatchValue_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "MatchValue(expr value)"},
    {Py_tp_new, MatchValue_new},
    {0, 0},
};

static PyType_Spec _MatchValue_type_spec = {
    "ast._MatchValue",
    sizeof(struct _pattern),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _MatchValue_type_slots
};



pattern_ty _PyAst_MatchValue_Copy(pattern_ty self) {
    struct ast_state *state = get_ast_state();
    pattern_ty res = PyObject_New(struct _pattern, (PyTypeObject
                                  *)state->_MatchValue_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.MatchValue.value != NULL) {
        res->v.MatchValue.value = _PyAst_expr_Copy(self->v.MatchValue.value);
        ERROR_IF_NULL(res->v.MatchValue.value);
    } else {
        res->v.MatchValue.value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
MatchSingleton_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "MatchSingleton takes at most 1 positional argument");
        return NULL;
    }
    constant value = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_constant(state, tmp, &value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (value != NULL) {
            err = PyDict_PopString(kwargs, "value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_constant(state, tmp, &value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _pattern *res = (struct _pattern*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.MatchSingleton.value = value;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(value);
    return NULL;
}

static void MatchSingleton_dealloc(PyObject *self) {
    pattern_ty obj = (pattern_ty)self;
    Py_XDECREF(obj->v.MatchSingleton.value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef MatchSingleton_members[] = {
    {"value", _Py_T_OBJECT, offsetof(struct _pattern, v.MatchSingleton.value),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _MatchSingleton_type_slots[] = {
    {Py_tp_dealloc, &MatchSingleton_dealloc},
    {Py_tp_members, MatchSingleton_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "MatchSingleton(constant value)"},
    {Py_tp_new, MatchSingleton_new},
    {0, 0},
};

static PyType_Spec _MatchSingleton_type_spec = {
    "ast._MatchSingleton",
    sizeof(struct _pattern),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _MatchSingleton_type_slots
};



pattern_ty _PyAst_MatchSingleton_Copy(pattern_ty self) {
    struct ast_state *state = get_ast_state();
    pattern_ty res = PyObject_New(struct _pattern, (PyTypeObject
                                  *)state->_MatchSingleton_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.MatchSingleton.value != NULL) {
        res->v.MatchSingleton.value = Py_NewRef(self->v.MatchSingleton.value);
        ERROR_IF_NULL(res->v.MatchSingleton.value);
    } else {
        res->v.MatchSingleton.value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
MatchSequence_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "MatchSequence takes at most 1 positional argument");
        return NULL;
    }
    asdl_pattern_seq* patterns = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_pattern_seq(state, tmp, "MatchSequence", "patterns",
                &patterns) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (patterns != NULL) {
            err = PyDict_PopString(kwargs, "patterns", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_pattern_seq(state, tmp, "MatchSequence",
                    "patterns", &patterns) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _pattern *res = (struct _pattern*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.MatchSequence.patterns = patterns;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(patterns);
    return NULL;
}

static void MatchSequence_dealloc(PyObject *self) {
    pattern_ty obj = (pattern_ty)self;
    Py_XDECREF(obj->v.MatchSequence.patterns);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef MatchSequence_members[] = {
    {"patterns", _Py_T_OBJECT, offsetof(struct _pattern,
      v.MatchSequence.patterns), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _MatchSequence_type_slots[] = {
    {Py_tp_dealloc, &MatchSequence_dealloc},
    {Py_tp_members, MatchSequence_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "MatchSequence(pattern* patterns)"},
    {Py_tp_new, MatchSequence_new},
    {0, 0},
};

static PyType_Spec _MatchSequence_type_spec = {
    "ast._MatchSequence",
    sizeof(struct _pattern),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _MatchSequence_type_slots
};



pattern_ty _PyAst_MatchSequence_Copy(pattern_ty self) {
    struct ast_state *state = get_ast_state();
    pattern_ty res = PyObject_New(struct _pattern, (PyTypeObject
                                  *)state->_MatchSequence_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.MatchSequence.patterns != NULL) {
        res->v.MatchSequence.patterns =
        _PyAst_pattern_seq_Copy(self->v.MatchSequence.patterns);
        ERROR_IF_NULL(res->v.MatchSequence.patterns);
    } else {
        res->v.MatchSequence.patterns = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
MatchMapping_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "MatchMapping takes at most 3 positional arguments");
        return NULL;
    }
    asdl_expr_seq* keys = NULL;
    asdl_pattern_seq* patterns = NULL;
    identifier rest = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_identifier(state, tmp, &rest) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_pattern_seq(state, tmp, "MatchMapping", "patterns",
                &patterns) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr_seq(state, tmp, "MatchMapping", "keys", &keys) <
                0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (keys != NULL) {
            err = PyDict_PopString(kwargs, "keys", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr_seq(state, tmp, "MatchMapping", "keys", &keys)
                    < 0) {
                    goto fail;
                }
            }
        }
        if (patterns != NULL) {
            err = PyDict_PopString(kwargs, "patterns", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_pattern_seq(state, tmp, "MatchMapping", "patterns",
                    &patterns) < 0) {
                    goto fail;
                }
            }
        }
        if (rest != NULL) {
            err = PyDict_PopString(kwargs, "rest", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &rest) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _pattern *res = (struct _pattern*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.MatchMapping.keys = keys;
    res->v.MatchMapping.patterns = patterns;
    res->v.MatchMapping.rest = rest;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(keys);
    Py_XDECREF(patterns);
    Py_XDECREF(rest);
    return NULL;
}

static void MatchMapping_dealloc(PyObject *self) {
    pattern_ty obj = (pattern_ty)self;
    Py_XDECREF(obj->v.MatchMapping.keys);
    Py_XDECREF(obj->v.MatchMapping.patterns);
    Py_XDECREF(obj->v.MatchMapping.rest);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef MatchMapping_members[] = {
    {"keys", _Py_T_OBJECT, offsetof(struct _pattern, v.MatchMapping.keys),
      Py_READONLY, NULL},
    {"patterns", _Py_T_OBJECT, offsetof(struct _pattern,
      v.MatchMapping.patterns), Py_READONLY, NULL},
    {"rest", _Py_T_OBJECT, offsetof(struct _pattern, v.MatchMapping.rest),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _MatchMapping_type_slots[] = {
    {Py_tp_dealloc, &MatchMapping_dealloc},
    {Py_tp_members, MatchMapping_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "MatchMapping(expr* keys, pattern* patterns, identifier? rest)"},
    {Py_tp_new, MatchMapping_new},
    {0, 0},
};

static PyType_Spec _MatchMapping_type_spec = {
    "ast._MatchMapping",
    sizeof(struct _pattern),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _MatchMapping_type_slots
};



pattern_ty _PyAst_MatchMapping_Copy(pattern_ty self) {
    struct ast_state *state = get_ast_state();
    pattern_ty res = PyObject_New(struct _pattern, (PyTypeObject
                                  *)state->_MatchMapping_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.MatchMapping.keys != NULL) {
        res->v.MatchMapping.keys =
        _PyAst_expr_seq_Copy(self->v.MatchMapping.keys);
        ERROR_IF_NULL(res->v.MatchMapping.keys);
    } else {
        res->v.MatchMapping.keys = NULL;
    }
    if (self->v.MatchMapping.patterns != NULL) {
        res->v.MatchMapping.patterns =
        _PyAst_pattern_seq_Copy(self->v.MatchMapping.patterns);
        ERROR_IF_NULL(res->v.MatchMapping.patterns);
    } else {
        res->v.MatchMapping.patterns = NULL;
    }
    if (self->v.MatchMapping.rest != NULL) {
        res->v.MatchMapping.rest = Py_NewRef(self->v.MatchMapping.rest);
        ERROR_IF_NULL(res->v.MatchMapping.rest);
    } else {
        res->v.MatchMapping.rest = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
MatchClass_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 4) {
        PyErr_SetString(PyExc_TypeError,
                        "MatchClass takes at most 4 positional arguments");
        return NULL;
    }
    expr_ty cls = NULL;
    asdl_pattern_seq* patterns = NULL;
    asdl_identifier_seq* kwd_attrs = NULL;
    asdl_pattern_seq* kwd_patterns = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 8: {
            tmp = PyTuple_GET_ITEM(pargs, 7);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_pattern_seq(state, tmp, "MatchClass", "kwd_patterns",
                &kwd_patterns) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_identifier_seq(state, tmp, "MatchClass", "kwd_attrs",
                &kwd_attrs) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_pattern_seq(state, tmp, "MatchClass", "patterns",
                &patterns) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_expr(state, tmp, &cls) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (cls != NULL) {
            err = PyDict_PopString(kwargs, "cls", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &cls) < 0) {
                    goto fail;
                }
            }
        }
        if (patterns != NULL) {
            err = PyDict_PopString(kwargs, "patterns", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_pattern_seq(state, tmp, "MatchClass", "patterns",
                    &patterns) < 0) {
                    goto fail;
                }
            }
        }
        if (kwd_attrs != NULL) {
            err = PyDict_PopString(kwargs, "kwd_attrs", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier_seq(state, tmp, "MatchClass",
                    "kwd_attrs", &kwd_attrs) < 0) {
                    goto fail;
                }
            }
        }
        if (kwd_patterns != NULL) {
            err = PyDict_PopString(kwargs, "kwd_patterns", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_pattern_seq(state, tmp, "MatchClass",
                    "kwd_patterns", &kwd_patterns) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _pattern *res = (struct _pattern*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.MatchClass.cls = cls;
    res->v.MatchClass.patterns = patterns;
    res->v.MatchClass.kwd_attrs = kwd_attrs;
    res->v.MatchClass.kwd_patterns = kwd_patterns;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(cls);
    Py_XDECREF(patterns);
    Py_XDECREF(kwd_attrs);
    Py_XDECREF(kwd_patterns);
    return NULL;
}

static void MatchClass_dealloc(PyObject *self) {
    pattern_ty obj = (pattern_ty)self;
    Py_XDECREF(obj->v.MatchClass.cls);
    Py_XDECREF(obj->v.MatchClass.patterns);
    Py_XDECREF(obj->v.MatchClass.kwd_attrs);
    Py_XDECREF(obj->v.MatchClass.kwd_patterns);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef MatchClass_members[] = {
    {"cls", _Py_T_OBJECT, offsetof(struct _pattern, v.MatchClass.cls),
      Py_READONLY, NULL},
    {"patterns", _Py_T_OBJECT, offsetof(struct _pattern,
      v.MatchClass.patterns), Py_READONLY, NULL},
    {"kwd_attrs", _Py_T_OBJECT, offsetof(struct _pattern,
      v.MatchClass.kwd_attrs), Py_READONLY, NULL},
    {"kwd_patterns", _Py_T_OBJECT, offsetof(struct _pattern,
      v.MatchClass.kwd_patterns), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _MatchClass_type_slots[] = {
    {Py_tp_dealloc, &MatchClass_dealloc},
    {Py_tp_members, MatchClass_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, pattern* kwd_patterns)"},
    {Py_tp_new, MatchClass_new},
    {0, 0},
};

static PyType_Spec _MatchClass_type_spec = {
    "ast._MatchClass",
    sizeof(struct _pattern),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _MatchClass_type_slots
};



pattern_ty _PyAst_MatchClass_Copy(pattern_ty self) {
    struct ast_state *state = get_ast_state();
    pattern_ty res = PyObject_New(struct _pattern, (PyTypeObject
                                  *)state->_MatchClass_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.MatchClass.cls != NULL) {
        res->v.MatchClass.cls = _PyAst_expr_Copy(self->v.MatchClass.cls);
        ERROR_IF_NULL(res->v.MatchClass.cls);
    } else {
        res->v.MatchClass.cls = NULL;
    }
    if (self->v.MatchClass.patterns != NULL) {
        res->v.MatchClass.patterns =
        _PyAst_pattern_seq_Copy(self->v.MatchClass.patterns);
        ERROR_IF_NULL(res->v.MatchClass.patterns);
    } else {
        res->v.MatchClass.patterns = NULL;
    }
    if (self->v.MatchClass.kwd_attrs != NULL) {
        res->v.MatchClass.kwd_attrs =
        _PyAst_identifier_seq_Copy(self->v.MatchClass.kwd_attrs);
        ERROR_IF_NULL(res->v.MatchClass.kwd_attrs);
    } else {
        res->v.MatchClass.kwd_attrs = NULL;
    }
    if (self->v.MatchClass.kwd_patterns != NULL) {
        res->v.MatchClass.kwd_patterns =
        _PyAst_pattern_seq_Copy(self->v.MatchClass.kwd_patterns);
        ERROR_IF_NULL(res->v.MatchClass.kwd_patterns);
    } else {
        res->v.MatchClass.kwd_patterns = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
MatchStar_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "MatchStar takes at most 1 positional argument");
        return NULL;
    }
    identifier name = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier(state, tmp, &name) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (name != NULL) {
            err = PyDict_PopString(kwargs, "name", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &name) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _pattern *res = (struct _pattern*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.MatchStar.name = name;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(name);
    return NULL;
}

static void MatchStar_dealloc(PyObject *self) {
    pattern_ty obj = (pattern_ty)self;
    Py_XDECREF(obj->v.MatchStar.name);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef MatchStar_members[] = {
    {"name", _Py_T_OBJECT, offsetof(struct _pattern, v.MatchStar.name),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _MatchStar_type_slots[] = {
    {Py_tp_dealloc, &MatchStar_dealloc},
    {Py_tp_members, MatchStar_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "MatchStar(identifier? name)"},
    {Py_tp_new, MatchStar_new},
    {0, 0},
};

static PyType_Spec _MatchStar_type_spec = {
    "ast._MatchStar",
    sizeof(struct _pattern),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _MatchStar_type_slots
};



pattern_ty _PyAst_MatchStar_Copy(pattern_ty self) {
    struct ast_state *state = get_ast_state();
    pattern_ty res = PyObject_New(struct _pattern, (PyTypeObject
                                  *)state->_MatchStar_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.MatchStar.name != NULL) {
        res->v.MatchStar.name = Py_NewRef(self->v.MatchStar.name);
        ERROR_IF_NULL(res->v.MatchStar.name);
    } else {
        res->v.MatchStar.name = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
MatchAs_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "MatchAs takes at most 2 positional arguments");
        return NULL;
    }
    pattern_ty pattern = NULL;
    identifier name = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_identifier(state, tmp, &name) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_pattern(state, tmp, &pattern) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (pattern != NULL) {
            err = PyDict_PopString(kwargs, "pattern", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_pattern(state, tmp, &pattern) < 0) {
                    goto fail;
                }
            }
        }
        if (name != NULL) {
            err = PyDict_PopString(kwargs, "name", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &name) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _pattern *res = (struct _pattern*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.MatchAs.pattern = pattern;
    res->v.MatchAs.name = name;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(pattern);
    Py_XDECREF(name);
    return NULL;
}

static void MatchAs_dealloc(PyObject *self) {
    pattern_ty obj = (pattern_ty)self;
    Py_XDECREF(obj->v.MatchAs.pattern);
    Py_XDECREF(obj->v.MatchAs.name);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef MatchAs_members[] = {
    {"pattern", _Py_T_OBJECT, offsetof(struct _pattern, v.MatchAs.pattern),
      Py_READONLY, NULL},
    {"name", _Py_T_OBJECT, offsetof(struct _pattern, v.MatchAs.name),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _MatchAs_type_slots[] = {
    {Py_tp_dealloc, &MatchAs_dealloc},
    {Py_tp_members, MatchAs_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "MatchAs(pattern? pattern, identifier? name)"},
    {Py_tp_new, MatchAs_new},
    {0, 0},
};

static PyType_Spec _MatchAs_type_spec = {
    "ast._MatchAs",
    sizeof(struct _pattern),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _MatchAs_type_slots
};



pattern_ty _PyAst_MatchAs_Copy(pattern_ty self) {
    struct ast_state *state = get_ast_state();
    pattern_ty res = PyObject_New(struct _pattern, (PyTypeObject
                                  *)state->_MatchAs_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.MatchAs.pattern != NULL) {
        res->v.MatchAs.pattern = _PyAst_pattern_Copy(self->v.MatchAs.pattern);
        ERROR_IF_NULL(res->v.MatchAs.pattern);
    } else {
        res->v.MatchAs.pattern = NULL;
    }
    if (self->v.MatchAs.name != NULL) {
        res->v.MatchAs.name = Py_NewRef(self->v.MatchAs.name);
        ERROR_IF_NULL(res->v.MatchAs.name);
    } else {
        res->v.MatchAs.name = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
MatchOr_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 1) {
        PyErr_SetString(PyExc_TypeError,
                        "MatchOr takes at most 1 positional argument");
        return NULL;
    }
    asdl_pattern_seq* patterns = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_pattern_seq(state, tmp, "MatchOr", "patterns",
                &patterns) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (patterns != NULL) {
            err = PyDict_PopString(kwargs, "patterns", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_pattern_seq(state, tmp, "MatchOr", "patterns",
                    &patterns) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _pattern *res = (struct _pattern*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.MatchOr.patterns = patterns;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(patterns);
    return NULL;
}

static void MatchOr_dealloc(PyObject *self) {
    pattern_ty obj = (pattern_ty)self;
    Py_XDECREF(obj->v.MatchOr.patterns);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef MatchOr_members[] = {
    {"patterns", _Py_T_OBJECT, offsetof(struct _pattern, v.MatchOr.patterns),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _MatchOr_type_slots[] = {
    {Py_tp_dealloc, &MatchOr_dealloc},
    {Py_tp_members, MatchOr_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "MatchOr(pattern* patterns)"},
    {Py_tp_new, MatchOr_new},
    {0, 0},
};

static PyType_Spec _MatchOr_type_spec = {
    "ast._MatchOr",
    sizeof(struct _pattern),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _MatchOr_type_slots
};



pattern_ty _PyAst_MatchOr_Copy(pattern_ty self) {
    struct ast_state *state = get_ast_state();
    pattern_ty res = PyObject_New(struct _pattern, (PyTypeObject
                                  *)state->_MatchOr_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.MatchOr.patterns != NULL) {
        res->v.MatchOr.patterns =
        _PyAst_pattern_seq_Copy(self->v.MatchOr.patterns);
        ERROR_IF_NULL(res->v.MatchOr.patterns);
    } else {
        res->v.MatchOr.patterns = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}


pattern_ty _PyAst_pattern_Copy(pattern_ty node) {
    switch (node->kind) {
        case MatchValue_kind:
            return _PyAst_MatchValue_Copy(node);
        case MatchSingleton_kind:
            return _PyAst_MatchSingleton_Copy(node);
        case MatchSequence_kind:
            return _PyAst_MatchSequence_Copy(node);
        case MatchMapping_kind:
            return _PyAst_MatchMapping_Copy(node);
        case MatchClass_kind:
            return _PyAst_MatchClass_Copy(node);
        case MatchStar_kind:
            return _PyAst_MatchStar_Copy(node);
        case MatchAs_kind:
            return _PyAst_MatchAs_Copy(node);
        case MatchOr_kind:
            return _PyAst_MatchOr_Copy(node);
    }
    return NULL;
}

static PyObject *
pattern_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "pattern takes at most 0 positional arguments");
        return NULL;
    }
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _pattern *res = (struct _pattern*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    return NULL;
}

static void pattern_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef pattern_members[] = {
    {0}
};

static PyType_Slot _pattern_type_slots[] = {
    {Py_tp_dealloc, &pattern_dealloc},
    {Py_tp_members, pattern_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "pattern = MatchValue(expr value)\n"
        "        | MatchSingleton(constant value)\n"
        "        | MatchSequence(pattern* patterns)\n"
        "        | MatchMapping(expr* keys, pattern* patterns, identifier? rest)\n"
        "        | MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, pattern* kwd_patterns)\n"
        "        | MatchStar(identifier? name)\n"
        "        | MatchAs(pattern? pattern, identifier? name)\n"
        "        | MatchOr(pattern* patterns)"},
    {Py_tp_new, pattern_new},
    {0, 0},
};

static PyType_Spec _pattern_type_spec = {
    "ast._pattern",
    sizeof(struct _pattern),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _pattern_type_slots
};



static void pattern_seq_dealloc(PyObject *self) {
    asdl_pattern_seq *obj = (asdl_pattern_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_pattern_seq_type_slots[] = {
    {Py_tp_dealloc, &pattern_seq_dealloc},
    //{Py_tp_members, pattern_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _pattern_seq_type_spec = {
    "ast._pattern_seq",
    sizeof(asdl_pattern_seq) - sizeof(pattern_ty),
    sizeof(pattern_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_pattern_seq_type_slots
};

asdl_pattern_seq *_PyAst_pattern_seq_Copy(asdl_pattern_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_pattern_seq *res = PyObject_NewVar(asdl_pattern_seq, (PyTypeObject *)state->_pattern_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] =
            _PyAst_pattern_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
TypeIgnore_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "TypeIgnore takes at most 2 positional arguments");
        return NULL;
    }
    int lineno = 0;
    bool got_lineno = false;
    string tag = 0;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_string(state, tmp, &tag) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (tag != NULL) {
            err = PyDict_PopString(kwargs, "tag", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_string(state, tmp, &tag) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _type_ignore *res = (struct _type_ignore*)pytype->tp_alloc(pytype,
                                0);
    if (!res) goto fail;
    res->v.TypeIgnore.lineno = lineno;
    res->v.TypeIgnore.tag = tag;
    return (PyObject *)res;
fail:
    Py_XDECREF(tag);
    return NULL;
}

static void TypeIgnore_dealloc(PyObject *self) {
    type_ignore_ty obj = (type_ignore_ty)self;
    Py_XDECREF(obj->v.TypeIgnore.tag);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef TypeIgnore_members[] = {
    {"lineno", Py_T_INT, offsetof(struct _type_ignore, v.TypeIgnore.lineno),
      Py_READONLY, NULL},
    {"tag", _Py_T_OBJECT, offsetof(struct _type_ignore, v.TypeIgnore.tag),
      Py_READONLY, NULL},
    {0}
};

static PyType_Slot _TypeIgnore_type_slots[] = {
    {Py_tp_dealloc, &TypeIgnore_dealloc},
    {Py_tp_members, TypeIgnore_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "TypeIgnore(int lineno, string tag)"},
    {Py_tp_new, TypeIgnore_new},
    {0, 0},
};

static PyType_Spec _TypeIgnore_type_spec = {
    "ast._TypeIgnore",
    sizeof(struct _type_ignore),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _TypeIgnore_type_slots
};



type_ignore_ty _PyAst_TypeIgnore_Copy(type_ignore_ty self) {
    struct ast_state *state = get_ast_state();
    type_ignore_ty res = PyObject_New(struct _type_ignore, (PyTypeObject
                                      *)state->_TypeIgnore_type);
    if (res == NULL) {
        goto error;
    }
    res->v.TypeIgnore.lineno = self->v.TypeIgnore.lineno;
    if (self->v.TypeIgnore.tag != NULL) {
        res->v.TypeIgnore.tag = Py_NewRef(self->v.TypeIgnore.tag);
        ERROR_IF_NULL(res->v.TypeIgnore.tag);
    } else {
        res->v.TypeIgnore.tag = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}


type_ignore_ty _PyAst_type_ignore_Copy(type_ignore_ty node) {
    switch (node->kind) {
        case TypeIgnore_kind:
            return _PyAst_TypeIgnore_Copy(node);
    }
    return NULL;
}

static PyObject *
type_ignore_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "type_ignore takes at most 0 positional arguments");
        return NULL;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _type_ignore *res = (struct _type_ignore*)pytype->tp_alloc(pytype,
                                0);
    if (!res) goto fail;
    return (PyObject *)res;
fail:
    return NULL;
}

static void type_ignore_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef type_ignore_members[] = {
    {0}
};

static PyType_Slot _type_ignore_type_slots[] = {
    {Py_tp_dealloc, &type_ignore_dealloc},
    {Py_tp_members, type_ignore_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "type_ignore = TypeIgnore(int lineno, string tag)"},
    {Py_tp_new, type_ignore_new},
    {0, 0},
};

static PyType_Spec _type_ignore_type_spec = {
    "ast._type_ignore",
    sizeof(struct _type_ignore),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _type_ignore_type_slots
};



static void type_ignore_seq_dealloc(PyObject *self) {
    asdl_type_ignore_seq *obj = (asdl_type_ignore_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_type_ignore_seq_type_slots[] = {
    {Py_tp_dealloc, &type_ignore_seq_dealloc},
    //{Py_tp_members, type_ignore_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _type_ignore_seq_type_spec = {
    "ast._type_ignore_seq",
    sizeof(asdl_type_ignore_seq) - sizeof(type_ignore_ty),
    sizeof(type_ignore_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_type_ignore_seq_type_slots
};

asdl_type_ignore_seq *_PyAst_type_ignore_seq_Copy(asdl_type_ignore_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_type_ignore_seq *res = PyObject_NewVar(asdl_type_ignore_seq, (PyTypeObject *)state->_type_ignore_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] =
            _PyAst_type_ignore_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
TypeVar_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 3) {
        PyErr_SetString(PyExc_TypeError,
                        "TypeVar takes at most 3 positional arguments");
        return NULL;
    }
    identifier name = NULL;
    expr_ty bound = NULL;
    expr_ty default_value = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 7: {
            tmp = PyTuple_GET_ITEM(pargs, 6);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_expr(state, tmp, &default_value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &bound) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier(state, tmp, &name) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (name != NULL) {
            err = PyDict_PopString(kwargs, "name", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &name) < 0) {
                    goto fail;
                }
            }
        }
        if (bound != NULL) {
            err = PyDict_PopString(kwargs, "bound", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &bound) < 0) {
                    goto fail;
                }
            }
        }
        if (default_value != NULL) {
            err = PyDict_PopString(kwargs, "default_value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &default_value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _type_param *res = (struct _type_param*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.TypeVar.name = name;
    res->v.TypeVar.bound = bound;
    res->v.TypeVar.default_value = default_value;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(name);
    Py_XDECREF(bound);
    Py_XDECREF(default_value);
    return NULL;
}

static void TypeVar_dealloc(PyObject *self) {
    type_param_ty obj = (type_param_ty)self;
    Py_XDECREF(obj->v.TypeVar.name);
    Py_XDECREF(obj->v.TypeVar.bound);
    Py_XDECREF(obj->v.TypeVar.default_value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef TypeVar_members[] = {
    {"name", _Py_T_OBJECT, offsetof(struct _type_param, v.TypeVar.name),
      Py_READONLY, NULL},
    {"bound", _Py_T_OBJECT, offsetof(struct _type_param, v.TypeVar.bound),
      Py_READONLY, NULL},
    {"default_value", _Py_T_OBJECT, offsetof(struct _type_param,
      v.TypeVar.default_value), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _TypeVar_type_slots[] = {
    {Py_tp_dealloc, &TypeVar_dealloc},
    {Py_tp_members, TypeVar_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "TypeVar(identifier name, expr? bound, expr? default_value)"},
    {Py_tp_new, TypeVar_new},
    {0, 0},
};

static PyType_Spec _TypeVar_type_spec = {
    "ast._TypeVar",
    sizeof(struct _type_param),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _TypeVar_type_slots
};



type_param_ty _PyAst_TypeVar_Copy(type_param_ty self) {
    struct ast_state *state = get_ast_state();
    type_param_ty res = PyObject_New(struct _type_param, (PyTypeObject
                                     *)state->_TypeVar_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.TypeVar.name != NULL) {
        res->v.TypeVar.name = Py_NewRef(self->v.TypeVar.name);
        ERROR_IF_NULL(res->v.TypeVar.name);
    } else {
        res->v.TypeVar.name = NULL;
    }
    if (self->v.TypeVar.bound != NULL) {
        res->v.TypeVar.bound = _PyAst_expr_Copy(self->v.TypeVar.bound);
        ERROR_IF_NULL(res->v.TypeVar.bound);
    } else {
        res->v.TypeVar.bound = NULL;
    }
    if (self->v.TypeVar.default_value != NULL) {
        res->v.TypeVar.default_value =
        _PyAst_expr_Copy(self->v.TypeVar.default_value);
        ERROR_IF_NULL(res->v.TypeVar.default_value);
    } else {
        res->v.TypeVar.default_value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
ParamSpec_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "ParamSpec takes at most 2 positional arguments");
        return NULL;
    }
    identifier name = NULL;
    expr_ty default_value = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &default_value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier(state, tmp, &name) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (name != NULL) {
            err = PyDict_PopString(kwargs, "name", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &name) < 0) {
                    goto fail;
                }
            }
        }
        if (default_value != NULL) {
            err = PyDict_PopString(kwargs, "default_value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &default_value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _type_param *res = (struct _type_param*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.ParamSpec.name = name;
    res->v.ParamSpec.default_value = default_value;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(name);
    Py_XDECREF(default_value);
    return NULL;
}

static void ParamSpec_dealloc(PyObject *self) {
    type_param_ty obj = (type_param_ty)self;
    Py_XDECREF(obj->v.ParamSpec.name);
    Py_XDECREF(obj->v.ParamSpec.default_value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef ParamSpec_members[] = {
    {"name", _Py_T_OBJECT, offsetof(struct _type_param, v.ParamSpec.name),
      Py_READONLY, NULL},
    {"default_value", _Py_T_OBJECT, offsetof(struct _type_param,
      v.ParamSpec.default_value), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _ParamSpec_type_slots[] = {
    {Py_tp_dealloc, &ParamSpec_dealloc},
    {Py_tp_members, ParamSpec_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "ParamSpec(identifier name, expr? default_value)"},
    {Py_tp_new, ParamSpec_new},
    {0, 0},
};

static PyType_Spec _ParamSpec_type_spec = {
    "ast._ParamSpec",
    sizeof(struct _type_param),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _ParamSpec_type_slots
};



type_param_ty _PyAst_ParamSpec_Copy(type_param_ty self) {
    struct ast_state *state = get_ast_state();
    type_param_ty res = PyObject_New(struct _type_param, (PyTypeObject
                                     *)state->_ParamSpec_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.ParamSpec.name != NULL) {
        res->v.ParamSpec.name = Py_NewRef(self->v.ParamSpec.name);
        ERROR_IF_NULL(res->v.ParamSpec.name);
    } else {
        res->v.ParamSpec.name = NULL;
    }
    if (self->v.ParamSpec.default_value != NULL) {
        res->v.ParamSpec.default_value =
        _PyAst_expr_Copy(self->v.ParamSpec.default_value);
        ERROR_IF_NULL(res->v.ParamSpec.default_value);
    } else {
        res->v.ParamSpec.default_value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}

static PyObject *
TypeVarTuple_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 2) {
        PyErr_SetString(PyExc_TypeError,
                        "TypeVarTuple takes at most 2 positional arguments");
        return NULL;
    }
    identifier name = NULL;
    expr_ty default_value = NULL;
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    switch (posargs) {
        case 6: {
            tmp = PyTuple_GET_ITEM(pargs, 5);
            if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                goto fail;
            }
            got_end_col_offset = true;
        }
        // fallthrough
        case 5: {
            tmp = PyTuple_GET_ITEM(pargs, 4);
            if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                goto fail;
            }
            got_end_lineno = true;
        }
        // fallthrough
        case 4: {
            tmp = PyTuple_GET_ITEM(pargs, 3);
            if (obj2imm_int(state, tmp, &col_offset) < 0) {
                goto fail;
            }
            got_col_offset = true;
        }
        // fallthrough
        case 3: {
            tmp = PyTuple_GET_ITEM(pargs, 2);
            if (obj2imm_int(state, tmp, &lineno) < 0) {
                goto fail;
            }
            got_lineno = true;
        }
        // fallthrough
        case 2: {
            tmp = PyTuple_GET_ITEM(pargs, 1);
            if (obj2imm_expr(state, tmp, &default_value) < 0) {
                goto fail;
            }
        }
        // fallthrough
        case 1: {
            tmp = PyTuple_GET_ITEM(pargs, 0);
            if (obj2imm_identifier(state, tmp, &name) < 0) {
                goto fail;
            }
        }
        // fallthrough
        default:
            break;
    }
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (name != NULL) {
            err = PyDict_PopString(kwargs, "name", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_identifier(state, tmp, &name) < 0) {
                    goto fail;
                }
            }
        }
        if (default_value != NULL) {
            err = PyDict_PopString(kwargs, "default_value", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_expr(state, tmp, &default_value) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _type_param *res = (struct _type_param*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->v.TypeVarTuple.name = name;
    res->v.TypeVarTuple.default_value = default_value;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    Py_XDECREF(name);
    Py_XDECREF(default_value);
    return NULL;
}

static void TypeVarTuple_dealloc(PyObject *self) {
    type_param_ty obj = (type_param_ty)self;
    Py_XDECREF(obj->v.TypeVarTuple.name);
    Py_XDECREF(obj->v.TypeVarTuple.default_value);
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef TypeVarTuple_members[] = {
    {"name", _Py_T_OBJECT, offsetof(struct _type_param, v.TypeVarTuple.name),
      Py_READONLY, NULL},
    {"default_value", _Py_T_OBJECT, offsetof(struct _type_param,
      v.TypeVarTuple.default_value), Py_READONLY, NULL},
    {0}
};

static PyType_Slot _TypeVarTuple_type_slots[] = {
    {Py_tp_dealloc, &TypeVarTuple_dealloc},
    {Py_tp_members, TypeVarTuple_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "TypeVarTuple(identifier name, expr? default_value)"},
    {Py_tp_new, TypeVarTuple_new},
    {0, 0},
};

static PyType_Spec _TypeVarTuple_type_spec = {
    "ast._TypeVarTuple",
    sizeof(struct _type_param),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _TypeVarTuple_type_slots
};



type_param_ty _PyAst_TypeVarTuple_Copy(type_param_ty self) {
    struct ast_state *state = get_ast_state();
    type_param_ty res = PyObject_New(struct _type_param, (PyTypeObject
                                     *)state->_TypeVarTuple_type);
    if (res == NULL) {
        goto error;
    }
    if (self->v.TypeVarTuple.name != NULL) {
        res->v.TypeVarTuple.name = Py_NewRef(self->v.TypeVarTuple.name);
        ERROR_IF_NULL(res->v.TypeVarTuple.name);
    } else {
        res->v.TypeVarTuple.name = NULL;
    }
    if (self->v.TypeVarTuple.default_value != NULL) {
        res->v.TypeVarTuple.default_value =
        _PyAst_expr_Copy(self->v.TypeVarTuple.default_value);
        ERROR_IF_NULL(res->v.TypeVarTuple.default_value);
    } else {
        res->v.TypeVarTuple.default_value = NULL;
    }
    return res;
error:
    Py_XDECREF(res);
    return NULL;
}


type_param_ty _PyAst_type_param_Copy(type_param_ty node) {
    switch (node->kind) {
        case TypeVar_kind:
            return _PyAst_TypeVar_Copy(node);
        case ParamSpec_kind:
            return _PyAst_ParamSpec_Copy(node);
        case TypeVarTuple_kind:
            return _PyAst_TypeVarTuple_Copy(node);
    }
    return NULL;
}

static PyObject *
type_param_new(PyTypeObject *pytype, PyObject *pargs, PyObject *kwargs)
{
    Py_ssize_t posargs = PyTuple_GET_SIZE(pargs);
    if (posargs > 0) {
        PyErr_SetString(PyExc_TypeError,
                        "type_param takes at most 0 positional arguments");
        return NULL;
    }
    int lineno = 0;
    bool got_lineno = false;
    int col_offset = 0;
    bool got_col_offset = false;
    int end_lineno = 0;
    bool got_end_lineno = false;
    int end_col_offset = 0;
    bool got_end_col_offset = false;
    PyObject *tmp;
    struct ast_state *state = get_ast_state();
    if (kwargs != NULL && PyDict_Size(kwargs)) {
        int err;
        if (!got_lineno) {
            err = PyDict_PopString(kwargs, "lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_col_offset) {
            err = PyDict_PopString(kwargs, "col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_lineno) {
            err = PyDict_PopString(kwargs, "end_lineno", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_lineno) < 0) {
                    goto fail;
                }
            }
        }
        if (!got_end_col_offset) {
            err = PyDict_PopString(kwargs, "end_col_offset", &tmp);
            if (err < 0) goto fail;
            if (err) {
                if (obj2imm_int(state, tmp, &end_col_offset) < 0) {
                    goto fail;
                }
            }
        }
        if (PyDict_Size(kwargs)) {
            Py_ssize_t pos = 0;
            PyObject *key;
            while (PyDict_Next(kwargs, &pos, &key, NULL)) {
                PyErr_Format(PyExc_TypeError,
                                "%.400s.__replace__ got an unexpected keyword "
                                "argument '%U'.", pytype->tp_name, key);
                goto fail;
            }
        }
    }
    struct _type_param *res = (struct _type_param*)pytype->tp_alloc(pytype, 0);
    if (!res) goto fail;
    res->lineno = lineno;
    res->col_offset = col_offset;
    res->end_lineno = end_lineno;
    res->end_col_offset = end_col_offset;
    return (PyObject *)res;
fail:
    return NULL;
}

static void type_param_dealloc(PyObject *self) {
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}

static PyMemberDef type_param_members[] = {
    {0}
};

static PyType_Slot _type_param_type_slots[] = {
    {Py_tp_dealloc, &type_param_dealloc},
    {Py_tp_members, type_param_members},
    {Py_tp_free, PyObject_Free},
    {Py_tp_doc, "type_param = TypeVar(identifier name, expr? bound, expr? default_value)\n"
        "           | ParamSpec(identifier name, expr? default_value)\n"
        "           | TypeVarTuple(identifier name, expr? default_value)"},
    {Py_tp_new, type_param_new},
    {0, 0},
};

static PyType_Spec _type_param_type_spec = {
    "ast._type_param",
    sizeof(struct _type_param),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _type_param_type_slots
};



static void type_param_seq_dealloc(PyObject *self) {
    asdl_type_param_seq *obj = (asdl_type_param_seq *)self;
    for (Py_ssize_t i = 0; i < obj->size; i++) {
        PyObject *value = (PyObject *)obj->typed_elements[i];
        if (value) {
            Py_DECREF(value);
        }
    }
    PyTypeObject *type = Py_TYPE(self);
    type->tp_free(self);
    Py_DECREF(type);
}


static PyType_Slot _PyAST_type_param_seq_type_slots[] = {
    {Py_tp_dealloc, &type_param_seq_dealloc},
    //{Py_tp_members, type_param_seq_members},
    {Py_tp_free, PyObject_Free},
    {Py_sq_length, &ast_seq_len},
    {Py_sq_item, &ast_seq_get},
    {Py_sq_contains, &ast_seq_contains},
    {Py_mp_length, &ast_seq_len},
    {0},
};

static PyType_Spec _type_param_seq_type_spec = {
    "ast._type_param_seq",
    sizeof(asdl_type_param_seq) - sizeof(type_param_ty),
    sizeof(type_param_ty),
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    _PyAST_type_param_seq_type_slots
};

asdl_type_param_seq *_PyAst_type_param_seq_Copy(asdl_type_param_seq *seq) {
    struct ast_state *state = get_ast_state();
    asdl_type_param_seq *res = PyObject_NewVar(asdl_type_param_seq, (PyTypeObject *)state->_type_param_seq_type, seq->size);
    if (res == NULL) {
        goto error;
    }
    res->size = seq->size;
    res->elements = (void**)&res->typed_elements[0];
    for (Py_ssize_t i = 0; i < seq->size; i++) {
        if (seq->typed_elements[i] != NULL) {
            res->typed_elements[i] =
            _PyAst_type_param_Copy(seq->typed_elements[i]);
            ERROR_IF_NULL(res->typed_elements[i]);
        } else {
            res->typed_elements[i] = NULL;
        }
    }
    return res;
    error:
    Py_XDECREF(res);
    return NULL;
}




typedef struct {
    PyObject_HEAD
    PyObject *dict;
} AST_object;

static void
ast_dealloc(PyObject *op)
{
    AST_object *self = (AST_object*)op;
    /* bpo-31095: UnTrack is needed before calling any callbacks */
    PyTypeObject *tp = Py_TYPE(self);
    PyObject_GC_UnTrack(self);
    Py_CLEAR(self->dict);
    freefunc free_func = PyType_GetSlot(tp, Py_tp_free);
    assert(free_func != NULL);
    free_func(self);
    Py_DECREF(tp);
}

static int
ast_traverse(PyObject *op, visitproc visit, void *arg)
{
    AST_object *self = (AST_object*)op;
    Py_VISIT(Py_TYPE(self));
    Py_VISIT(self->dict);
    return 0;
}

static int
ast_clear(PyObject *op)
{
    AST_object *self = (AST_object*)op;
    Py_CLEAR(self->dict);
    return 0;
}

static int
ast_type_init(PyObject *self, PyObject *args, PyObject *kw)
{
    struct ast_state *state = get_ast_state();
    if (state == NULL) {
        return -1;
    }

    Py_ssize_t i, numfields = 0;
    int res = -1;
    PyObject *key, *value, *fields, *attributes = NULL, *remaining_fields = NULL;

    fields = PyObject_GetAttr((PyObject*)Py_TYPE(self), state->_fields);
    if (fields == NULL) {
        goto cleanup;
    }

    numfields = PySequence_Size(fields);
    if (numfields == -1) {
        goto cleanup;
    }
    remaining_fields = PySet_New(fields);
    if (remaining_fields == NULL) {
        goto cleanup;
    }

    res = 0; /* if no error occurs, this stays 0 to the end */
    if (numfields < PyTuple_GET_SIZE(args)) {
        PyErr_Format(PyExc_TypeError, "%.400s constructor takes at most "
                     "%zd positional argument%s",
                     _PyType_Name(Py_TYPE(self)),
                     numfields, numfields == 1 ? "" : "s");
        res = -1;
        goto cleanup;
    }
    for (i = 0; i < PyTuple_GET_SIZE(args); i++) {
        /* cannot be reached when fields is NULL */
        PyObject *name = PySequence_GetItem(fields, i);
        if (!name) {
            res = -1;
            goto cleanup;
        }
        res = PyObject_SetAttr(self, name, PyTuple_GET_ITEM(args, i));
        if (PySet_Discard(remaining_fields, name) < 0) {
            res = -1;
            Py_DECREF(name);
            goto cleanup;
        }
        Py_DECREF(name);
        if (res < 0) {
            goto cleanup;
        }
    }
    if (kw) {
        i = 0;  /* needed by PyDict_Next */
        while (PyDict_Next(kw, &i, &key, &value)) {
            int contains = PySequence_Contains(fields, key);
            if (contains == -1) {
                res = -1;
                goto cleanup;
            }
            else if (contains == 1) {
                int p = PySet_Discard(remaining_fields, key);
                if (p == -1) {
                    res = -1;
                    goto cleanup;
                }
                if (p == 0) {
                    PyErr_Format(PyExc_TypeError,
                        "%.400s got multiple values for argument '%U'",
                        Py_TYPE(self)->tp_name, key);
                    res = -1;
                    goto cleanup;
                }
            }
            else {
                // Lazily initialize "attributes"
                if (attributes == NULL) {
                    attributes = PyObject_GetAttr((PyObject*)Py_TYPE(self), state->_attributes);
                    if (attributes == NULL) {
                        res = -1;
                        goto cleanup;
                    }
                }
                int contains = PySequence_Contains(attributes, key);
                if (contains == -1) {
                    res = -1;
                    goto cleanup;
                }
                else if (contains == 0) {
                    if (PyErr_WarnFormat(
                        PyExc_DeprecationWarning, 1,
                        "%.400s.__init__ got an unexpected keyword argument '%U'. "
                        "Support for arbitrary keyword arguments is deprecated "
                        "and will be removed in Python 3.15.",
                        Py_TYPE(self)->tp_name, key
                    ) < 0) {
                        res = -1;
                        goto cleanup;
                    }
                }
            }
            res = PyObject_SetAttr(self, key, value);
            if (res < 0) {
                goto cleanup;
            }
        }
    }
    Py_ssize_t size = PySet_Size(remaining_fields);
    PyObject *field_types = NULL, *remaining_list = NULL;
    if (size > 0) {
        if (PyObject_GetOptionalAttr((PyObject*)Py_TYPE(self), &_Py_ID(_field_types),
                                     &field_types) < 0) {
            res = -1;
            goto cleanup;
        }
        if (field_types == NULL) {
            // Probably a user-defined subclass of AST that lacks _field_types.
            // This will continue to work as it did before 3.13; i.e., attributes
            // that are not passed in simply do not exist on the instance.
            goto cleanup;
        }
        remaining_list = PySequence_List(remaining_fields);
        if (!remaining_list) {
            goto set_remaining_cleanup;
        }
        for (Py_ssize_t i = 0; i < size; i++) {
            PyObject *name = PyList_GET_ITEM(remaining_list, i);
            PyObject *type = PyDict_GetItemWithError(field_types, name);
            if (!type) {
                if (PyErr_Occurred()) {
                    goto set_remaining_cleanup;
                }
                else {
                    if (PyErr_WarnFormat(
                        PyExc_DeprecationWarning, 1,
                        "Field %R is missing from %.400s._field_types. "
                        "This will become an error in Python 3.15.",
                        name, Py_TYPE(self)->tp_name
                    ) < 0) {
                        goto set_remaining_cleanup;
                    }
                }
            }
            else if (_PyUnion_Check(type)) {
                // optional field
                // do nothing, we'll have set a None default on the class
            }
            else if (Py_IS_TYPE(type, &Py_GenericAliasType)) {
                // list field
                PyObject *empty = PyList_New(0);
                if (!empty) {
                    goto set_remaining_cleanup;
                }
                res = PyObject_SetAttr(self, name, empty);
                Py_DECREF(empty);
                if (res < 0) {
                    goto set_remaining_cleanup;
                }
            }
            else if (type == state->expr_context_type) {
                // special case for expr_context: default to Load()
                res = PyObject_SetAttr(self, name, state->Load_singleton);
                if (res < 0) {
                    goto set_remaining_cleanup;
                }
            }
            else {
                // simple field (e.g., identifier)
                if (PyErr_WarnFormat(
                    PyExc_DeprecationWarning, 1,
                    "%.400s.__init__ missing 1 required positional argument: %R. "
                    "This will become an error in Python 3.15.",
                    Py_TYPE(self)->tp_name, name
                ) < 0) {
                    goto set_remaining_cleanup;
                }
            }
        }
        Py_DECREF(remaining_list);
        Py_DECREF(field_types);
    }
  cleanup:
    Py_XDECREF(attributes);
    Py_XDECREF(fields);
    Py_XDECREF(remaining_fields);
    return res;
  set_remaining_cleanup:
    Py_XDECREF(remaining_list);
    Py_XDECREF(field_types);
    res = -1;
    goto cleanup;
}

/* Pickling support */
static PyObject *
ast_type_reduce(PyObject *self, PyObject *unused)
{
    struct ast_state *state = get_ast_state();
    if (state == NULL) {
        return NULL;
    }

    PyObject *dict = NULL, *fields = NULL, *positional_args = NULL;
    if (PyObject_GetOptionalAttr(self, state->__dict__, &dict) < 0) {
        return NULL;
    }
    PyObject *result = NULL;
    if (dict) {
        // Unpickling (or copying) works as follows:
        // - Construct the object with only positional arguments
        // - Set the fields from the dict
        // We have two constraints:
        // - We must set all the required fields in the initial constructor call,
        //   or the unpickling or deepcopying of the object will trigger DeprecationWarnings.
        // - We must not include child nodes in the positional args, because
        //   that may trigger runaway recursion during copying (gh-120108).
        // To satisfy both constraints, we set all the fields to None in the
        // initial list of positional args, and then set the fields from the dict.
        if (PyObject_GetOptionalAttr((PyObject*)Py_TYPE(self), state->_fields, &fields) < 0) {
            goto cleanup;
        }
        if (fields) {
            Py_ssize_t numfields = PySequence_Size(fields);
            if (numfields == -1) {
                Py_DECREF(dict);
                goto cleanup;
            }
            positional_args = PyList_New(0);
            if (!positional_args) {
                goto cleanup;
            }
            for (Py_ssize_t i = 0; i < numfields; i++) {
                PyObject *name = PySequence_GetItem(fields, i);
                if (!name) {
                    goto cleanup;
                }
                PyObject *value;
                int rc = PyDict_GetItemRef(dict, name, &value);
                Py_DECREF(name);
                if (rc < 0) {
                    goto cleanup;
                }
                if (!value) {
                    break;
                }
                rc = PyList_Append(positional_args, Py_None);
                Py_DECREF(value);
                if (rc < 0) {
                    goto cleanup;
                }
            }
            PyObject *args_tuple = PyList_AsTuple(positional_args);
            if (!args_tuple) {
                goto cleanup;
            }
            result = Py_BuildValue("ONN", Py_TYPE(self), args_tuple, dict);
        }
        else {
            result = Py_BuildValue("O()N", Py_TYPE(self), dict);
        }
    }
    else {
        result = Py_BuildValue("O()", Py_TYPE(self));
    }
cleanup:
    Py_XDECREF(fields);
    Py_XDECREF(positional_args);
    return result;
}

/*
 * Perform the following validations:
 *
 *   - All keyword arguments are known 'fields' or 'attributes'.
 *   - No field or attribute would be left unfilled after copy.replace().
 *
 * On success, this returns 1. Otherwise, set a TypeError
 * exception and returns -1 (no exception is set if some
 * other internal errors occur).
 *
 * Parameters
 *
 *      self          The AST node instance.
 *      dict          The AST node instance dictionary (self.__dict__).
 *      fields        The list of fields (self._fields).
 *      attributes    The list of attributes (self._attributes).
 *      kwargs        Keyword arguments passed to ast_type_replace().
 *
 * The 'dict', 'fields', 'attributes' and 'kwargs' arguments can be NULL.
 *
 * Note: this function can be removed in 3.15 since the verification
 *       will be done inside the constructor.
 */
static inline int
ast_type_replace_check(PyObject *self,
                       PyObject *dict,
                       PyObject *fields,
                       PyObject *attributes,
                       PyObject *kwargs)
{
    // While it is possible to make some fast paths that would avoid
    // allocating objects on the stack, this would cost us readability.
    // For instance, if 'fields' and 'attributes' are both empty, and
    // 'kwargs' is not empty, we could raise a TypeError immediately.
    PyObject *expecting = PySet_New(fields);
    if (expecting == NULL) {
        return -1;
    }
    if (attributes) {
        if (_PySet_Update(expecting, attributes) < 0) {
            Py_DECREF(expecting);
            return -1;
        }
    }
    // Any keyword argument that is neither a field nor attribute is rejected.
    // We first need to check whether a keyword argument is accepted or not.
    // If all keyword arguments are accepted, we compute the required fields
    // and attributes. A field or attribute is not needed if:
    //
    //  1) it is given in 'kwargs', or
    //  2) it already exists on 'self'.
    if (kwargs) {
        Py_ssize_t pos = 0;
        PyObject *key, *value;
        while (PyDict_Next(kwargs, &pos, &key, &value)) {
            int rc = PySet_Discard(expecting, key);
            if (rc < 0) {
                Py_DECREF(expecting);
                return -1;
            }
            if (rc == 0) {
                PyErr_Format(PyExc_TypeError,
                             "%.400s.__replace__ got an unexpected keyword "
                             "argument '%U'.", Py_TYPE(self)->tp_name, key);
                Py_DECREF(expecting);
                return -1;
            }
        }
    }
    // check that the remaining fields or attributes would be filled
    if (dict) {
        Py_ssize_t pos = 0;
        PyObject *key, *value;
        while (PyDict_Next(dict, &pos, &key, &value)) {
            // Mark fields or attributes that are found on the instance
            // as non-mandatory. If they are not given in 'kwargs', they
            // will be shallow-coied; otherwise, they would be replaced
            // (not in this function).
            if (PySet_Discard(expecting, key) < 0) {
                Py_DECREF(expecting);
                return -1;
            }
        }
        if (attributes) {
            // Some attributes may or may not be present at runtime.
            // In particular, now that we checked whether 'kwargs'
            // is correct or not, we allow any attribute to be missing.
            //
            // Note that fields must still be entirely determined when
            // calling the constructor later.
            PyObject *unused = PyObject_CallMethodOneArg(expecting,
                                                         &_Py_ID(difference_update),
                                                         attributes);
            if (unused == NULL) {
                Py_DECREF(expecting);
                return -1;
            }
            Py_DECREF(unused);
        }
    }

    // Discard fields from 'expecting' that default to None
    PyObject *field_types = NULL;
    if (PyObject_GetOptionalAttr((PyObject*)Py_TYPE(self),
                                 &_Py_ID(_field_types),
                                 &field_types) < 0)
    {
        Py_DECREF(expecting);
        return -1;
    }
    if (field_types != NULL) {
        Py_ssize_t pos = 0;
        PyObject *field_name, *field_type;
        while (PyDict_Next(field_types, &pos, &field_name, &field_type)) {
            if (_PyUnion_Check(field_type)) {
                // optional field
                if (PySet_Discard(expecting, field_name) < 0) {
                    Py_DECREF(expecting);
                    Py_DECREF(field_types);
                    return -1;
                }
            }
        }
        Py_DECREF(field_types);
    }

    // Now 'expecting' contains the fields or attributes
    // that would not be filled inside ast_type_replace().
    Py_ssize_t m = PySet_GET_SIZE(expecting);
    if (m > 0) {
        PyObject *names = PyList_New(m);
        if (names == NULL) {
            Py_DECREF(expecting);
            return -1;
        }
        Py_ssize_t i = 0, pos = 0;
        PyObject *item;
        Py_hash_t hash;
        while (_PySet_NextEntry(expecting, &pos, &item, &hash)) {
            PyObject *name = PyObject_Repr(item);
            if (name == NULL) {
                Py_DECREF(expecting);
                Py_DECREF(names);
                return -1;
            }
            // steal the reference 'name'
            PyList_SET_ITEM(names, i++, name);
        }
        Py_DECREF(expecting);
        if (PyList_Sort(names) < 0) {
            Py_DECREF(names);
            return -1;
        }
        PyObject *sep = PyUnicode_FromString(", ");
        if (sep == NULL) {
            Py_DECREF(names);
            return -1;
        }
        PyObject *str_names = PyUnicode_Join(sep, names);
        Py_DECREF(sep);
        Py_DECREF(names);
        if (str_names == NULL) {
            return -1;
        }
        PyErr_Format(PyExc_TypeError,
                     "%.400s.__replace__ missing %ld keyword argument%s: %U.",
                     Py_TYPE(self)->tp_name, m, m == 1 ? "" : "s", str_names);
        Py_DECREF(str_names);
        return -1;
    }
    else {
        Py_DECREF(expecting);
        return 1;
    }
}

/*
 * Python equivalent:
 *
 *   for key in keys:
 *       if hasattr(self, key):
 *           payload[key] = getattr(self, key)
 *
 * The 'keys' argument is a sequence corresponding to
 * the '_fields' or the '_attributes' of an AST node.
 *
 * This returns -1 if an error occurs and 0 otherwise.
 *
 * Parameters
 *
 *      payload   A dictionary to fill.
 *      keys      A sequence of keys or NULL for an empty sequence.
 *      dict      The AST node instance dictionary (must not be NULL).
 */
static inline int
ast_type_replace_update_payload(PyObject *payload,
                                PyObject *keys,
                                PyObject *dict)
{
    assert(dict != NULL);
    if (keys == NULL) {
        return 0;
    }
    Py_ssize_t n = PySequence_Size(keys);
    if (n == -1) {
        return -1;
    }
    for (Py_ssize_t i = 0; i < n; i++) {
        PyObject *key = PySequence_GetItem(keys, i);
        if (key == NULL) {
            return -1;
        }
        PyObject *value;
        if (PyDict_GetItemRef(dict, key, &value) < 0) {
            Py_DECREF(key);
            return -1;
        }
        if (value == NULL) {
            Py_DECREF(key);
            // If a field or attribute is not present at runtime, it should
            // be explicitly given in 'kwargs'. If not, the constructor will
            // issue a warning (which becomes an error in 3.15).
            continue;
        }
        int rc = PyDict_SetItem(payload, key, value);
        Py_DECREF(key);
        Py_DECREF(value);
        if (rc < 0) {
            return -1;
        }
    }
    return 0;
}

/* copy.replace() support (shallow copy) */
static PyObject *
ast_type_replace(PyObject *self, PyObject *args, PyObject *kwargs)
{
    if (!_PyArg_NoPositional("__replace__", args)) {
        return NULL;
    }

    struct ast_state *state = get_ast_state();
    if (state == NULL) {
        return NULL;
    }

    PyObject *result = NULL;
    // known AST class fields and attributes
    PyObject *fields = NULL, *attributes = NULL;
    // current instance dictionary
    PyObject *dict = NULL;
    // constructor positional and keyword arguments
    PyObject *empty_tuple = NULL, *payload = NULL;

    PyObject *type = (PyObject *)Py_TYPE(self);
    if (PyObject_GetOptionalAttr(type, state->_fields, &fields) < 0) {
        goto cleanup;
    }
    if (PyObject_GetOptionalAttr(type, state->_attributes, &attributes) < 0) {
        goto cleanup;
    }
    if (PyObject_GetOptionalAttr(self, state->__dict__, &dict) < 0) {
        goto cleanup;
    }
    if (ast_type_replace_check(self, dict, fields, attributes, kwargs) < 0) {
        goto cleanup;
    }
    empty_tuple = PyTuple_New(0);
    if (empty_tuple == NULL) {
        goto cleanup;
    }
    payload = PyDict_New();
    if (payload == NULL) {
        goto cleanup;
    }
    if (dict) { // in case __dict__ is missing (for some obscure reason)
        // copy the instance's fields (possibly NULL)
        if (ast_type_replace_update_payload(payload, fields, dict) < 0) {
            goto cleanup;
        }
        // copy the instance's attributes (possibly NULL)
        if (ast_type_replace_update_payload(payload, attributes, dict) < 0) {
            goto cleanup;
        }
    }
    if (kwargs && PyDict_Update(payload, kwargs) < 0) {
        goto cleanup;
    }
    result = PyObject_Call(type, empty_tuple, payload);
cleanup:
    Py_XDECREF(payload);
    Py_XDECREF(empty_tuple);
    Py_XDECREF(dict);
    Py_XDECREF(attributes);
    Py_XDECREF(fields);
    return result;
}

static PyMemberDef ast_type_members[] = {
    {"__dictoffset__", Py_T_PYSSIZET, offsetof(AST_object, dict), Py_READONLY},
    {NULL}  /* Sentinel */
};

static PyMethodDef ast_type_methods[] = {
    {"__reduce__", ast_type_reduce, METH_NOARGS, NULL},
    {"__replace__", _PyCFunction_CAST(ast_type_replace), METH_VARARGS | METH_KEYWORDS,
     PyDoc_STR("__replace__($self, /, **fields)\n--\n\n"
               "Return a copy of the AST node with new values "
               "for the specified fields.")},
    {NULL}
};

static PyGetSetDef ast_type_getsets[] = {
    {"__dict__", PyObject_GenericGetDict, PyObject_GenericSetDict},
    {NULL}
};

static PyObject *
ast_repr_max_depth(PyObject *self, int depth);

/* Format list and tuple properties of AST nodes.
   Note that, only the first and last elements are shown.
   Anything in between is represented with an ellipsis ('...').
   For example, the list [1, 2, 3] is formatted as
   'List(elts=[Constant(1), ..., Constant(3)])'. */
static PyObject *
ast_repr_list(PyObject *list, int depth)
{
    assert(PySequence_Check(list));

    struct ast_state *state = get_ast_state();
    if (state == NULL) {
        return NULL;
    }

    Py_ssize_t length = PySequence_Size(list);
    if (length < 0) {
        return NULL;
    }
    else if (length == 0) {
        return PyObject_Repr(list);
    }

    PyObject *items[2] = {NULL, NULL};
    PyUnicodeWriter *writer = PyUnicodeWriter_Create(0);
    if (writer == NULL) {
        goto error;
    }

    items[0] = PySequence_GetItem(list, 0);
    if (!items[0]) {
        goto error;
    }
    if (length > 1) {
        items[1] = PySequence_GetItem(list, length - 1);
        if (!items[1]) {
            goto error;
        }
    }

    bool is_list = !PyTuple_Check(list);
    if (PyUnicodeWriter_WriteChar(writer, is_list ? '[' : '(') < 0) {
        goto error;
    }

    for (Py_ssize_t i = 0; i < Py_MIN(length, 2); i++) {
        if (i > 0) {
            if (PyUnicodeWriter_WriteASCII(writer, ", ", 2) < 0) {
                goto error;
            }
        }

        PyObject *item = items[i];
        if (PyType_IsSubtype(Py_TYPE(item), (PyTypeObject *)state->AST_type)) {
            PyObject *item_repr;
            item_repr = ast_repr_max_depth(item, depth - 1);
            if (!item_repr) {
                goto error;
            }
            if (PyUnicodeWriter_WriteStr(writer, item_repr) < 0) {
                Py_DECREF(item_repr);
                goto error;
            }
            Py_DECREF(item_repr);
        } else {
            if (PyUnicodeWriter_WriteRepr(writer, item) < 0) {
                goto error;
            }
        }

        if (i == 0 && length > 2) {
            if (PyUnicodeWriter_WriteASCII(writer, ", ...", 5) < 0) {
                goto error;
            }
        }
    }
    //if (!is_list && length == 1 &&
    //    PyUnicodeWriter_WriteChar(writer, is_list ? ']' : ')') < 0) {
    //    goto error;
    //}
    if (PyUnicodeWriter_WriteChar(writer, is_list ? ']' : ')') < 0) {
        goto error;
    }

    Py_XDECREF(items[0]);
    Py_XDECREF(items[1]);
    return PyUnicodeWriter_Finish(writer);

error:
    Py_XDECREF(items[0]);
    Py_XDECREF(items[1]);
    PyUnicodeWriter_Discard(writer);
    return NULL;
}

static PyObject *
ast_repr_max_depth(PyObject *self, int depth)
{
    struct ast_state *state = get_ast_state();
    if (state == NULL) {
        return NULL;
    }

    if (depth <= 0) {
        return PyUnicode_FromFormat("%s(...)", Py_TYPE(self)->tp_name);
    }

    int status = Py_ReprEnter((PyObject *)self);
    if (status != 0) {
        if (status < 0) {
            return NULL;
        }
        return PyUnicode_FromFormat("%s(...)", Py_TYPE(self)->tp_name);
    }

    PyObject *fields = PyObject_GetAttr((PyObject *)Py_TYPE(self), state->_fields);
    if (!fields) {
        Py_ReprLeave((PyObject *)self);
        return NULL;
    }

    Py_ssize_t numfields = PySequence_Size(fields);
    if (numfields < 0) {
        Py_ReprLeave((PyObject *)self);
        Py_DECREF(fields);
        return NULL;
    }

    if (numfields == 0) {
        Py_ReprLeave((PyObject *)self);
        Py_DECREF(fields);
        return PyUnicode_FromFormat("%s()", Py_TYPE(self)->tp_name);
    }

    const char* tp_name = Py_TYPE(self)->tp_name;
    PyUnicodeWriter *writer = PyUnicodeWriter_Create(0);
    if (writer == NULL) {
        goto error;
    }

    if (PyUnicodeWriter_WriteUTF8(writer, tp_name, -1) < 0) {
        goto error;
    }
    if (PyUnicodeWriter_WriteChar(writer, '(') < 0) {
        goto error;
    }

    for (Py_ssize_t i = 0; i < numfields; i++) {
        PyObject *name = PySequence_GetItem(fields, i);
        if (!name) {
            goto error;
        }

        PyObject *value = PyObject_GetAttr((PyObject *)self, name);
        if (!value) {
            Py_DECREF(name);
            goto error;
        }

        PyObject *value_repr;
        if (PyList_Check(value) || PyTuple_Check(value)) {
            value_repr = ast_repr_list(value, depth);
        }
        else if (PyObject_HasAttrString((PyObject *)Py_TYPE(value), "_fields")) {
            value_repr = ast_repr_max_depth(value, depth - 1);
        }
        else {
            value_repr = PyObject_Repr(value);
        }

        Py_DECREF(value);

        if (!value_repr) {
            Py_DECREF(name);
            goto error;
        }

        if (i > 0) {
            if (PyUnicodeWriter_WriteASCII(writer, ", ", 2) < 0) {
                Py_DECREF(name);
                Py_DECREF(value_repr);
                goto error;
            }
        }
        if (PyUnicodeWriter_WriteStr(writer, name) < 0) {
            Py_DECREF(name);
            Py_DECREF(value_repr);
            goto error;
        }

        Py_DECREF(name);

        if (PyUnicodeWriter_WriteChar(writer, '=') < 0) {
            Py_DECREF(value_repr);
            goto error;
        }
        if (PyUnicodeWriter_WriteStr(writer, value_repr) < 0) {
            Py_DECREF(value_repr);
            goto error;
        }

        Py_DECREF(value_repr);
    }

    if (PyUnicodeWriter_WriteChar(writer, ')') < 0) {
        goto error;
    }
    Py_ReprLeave((PyObject *)self);
    Py_DECREF(fields);
    return PyUnicodeWriter_Finish(writer);

error:
    Py_ReprLeave((PyObject *)self);
    Py_DECREF(fields);
    PyUnicodeWriter_Discard(writer);
    return NULL;
}

static PyObject *
ast_repr(PyObject *self)
{
    return ast_repr_max_depth(self, 3);
}

static PyObject *
ast_repr_generic(PyObject *self, PyObject *Py_UNUSED(b))
{
    return ast_repr_max_depth(self, 3);
}

static PyType_Slot AST_type_slots[] = {
    {Py_tp_dealloc, ast_dealloc},
    {Py_tp_repr, ast_repr},
    {Py_tp_getattro, PyObject_GenericGetAttr},
    {Py_tp_setattro, PyObject_GenericSetAttr},
    {Py_tp_traverse, ast_traverse},
    {Py_tp_clear, ast_clear},
    {Py_tp_members, ast_type_members},
    {Py_tp_methods, ast_type_methods},
    {Py_tp_getset, ast_type_getsets},
    {Py_tp_init, ast_type_init},
    {Py_tp_alloc, PyType_GenericAlloc},
    {Py_tp_new, PyType_GenericNew},
    {Py_tp_free, PyObject_GC_Del},
    {0, 0},
};

static PyType_Spec AST_type_spec = {
    "ast.AST",
    sizeof(AST_object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
    AST_type_slots
};

static PyObject *
make_fields(const char* const* fields, int num_fields)
{
    PyObject *fnames;
    fnames = PyTuple_New(num_fields);
    if (!fnames) return NULL;
    for (int i = 0; i < num_fields; i++) {
        PyObject *field = PyUnicode_InternFromString(fields[i]);
        if (!field) {
            Py_DECREF(fnames);
            return NULL;
        }
        PyTuple_SET_ITEM(fnames, i, field);
    }
    return fnames;
}

static int
add_fields(PyObject *type, const char* const* fields, int num_fields)
{
    PyObject *fnames = make_fields(fields, num_fields);
    if (!fnames) return -1;

    PyTypeObject *t = (PyTypeObject*)type;
    if (PyDict_SetItemString(t->tp_dict, "_fields", fnames) < 0) {
        Py_DECREF(fnames);
        return -1;
    }
    Py_DECREF(fnames);
    return 0;
}

static PyObject *
make_type(struct ast_state *state, const char *type, PyObject* base,
          const char* const* fields, int num_fields, const char *doc)
{
    PyObject *fnames = make_fields(fields, num_fields), *result;
    if (!fnames) return NULL;

    result = PyObject_CallFunction((PyObject*)&PyType_Type, "s(O){OOOOOOOs}",
                    type, base,
                    state->_fields, fnames,
                    state->__match_args__, fnames,
                    state->__module__,
                    state->ast,
                    state->__doc__, doc);
    Py_DECREF(fnames);
    return result;
}

static int
add_attributes(struct ast_state *state, PyObject *type, const char * const *attrs, int num_fields)
{
    int i, result;
    PyObject *s, *l = PyTuple_New(num_fields);
    if (!l)
        return -1;
    for (i = 0; i < num_fields; i++) {
        s = PyUnicode_InternFromString(attrs[i]);
        if (!s) {
            Py_DECREF(l);
            return -1;
        }
        PyTuple_SET_ITEM(l, i, s);
    }
    result = PyObject_SetAttr(type, state->_attributes, l);
    Py_DECREF(l);
    return result;
}

/* Conversion AST -> Python */

static PyObject* ast2obj_list(struct ast_state *state, asdl_seq *seq,
                              PyObject* (*func)(struct ast_state *state, void*))
{
    Py_ssize_t i, n = asdl_seq_LEN(seq);
    PyObject *result = PyList_New(n);
    PyObject *value;
    if (!result)
        return NULL;
    for (i = 0; i < n; i++) {
        value = func(state, asdl_seq_GET_UNTYPED(seq, i));
        if (!value) {
            Py_DECREF(result);
            return NULL;
        }
        PyList_SET_ITEM(result, i, value);
    }
    return result;
}

static PyObject* ast2obj_object(struct ast_state *Py_UNUSED(state), void *o)
{
    PyObject *op = (PyObject*)o;
    if (!op) {
        op = Py_None;
    }
    return Py_NewRef(op);
}
#define ast2obj_constant ast2obj_object
#define ast2obj_identifier ast2obj_object
#define ast2obj_string ast2obj_object

static PyObject* ast2obj_int(struct ast_state *Py_UNUSED(state), long b)
{
    return PyLong_FromLong(b);
}

/* Conversion Python -> AST */

static int obj2ast_object(struct ast_state *Py_UNUSED(state), PyObject* obj, PyObject** out, PyArena* arena)
{
    if (obj == Py_None)
        obj = NULL;
    if (obj) {
        if (_PyArena_AddPyObject(arena, obj) < 0) {
            *out = NULL;
            return -1;
        }
        *out = Py_NewRef(obj);
    }
    else {
        *out = NULL;
    }
    return 0;
}

static int obj2ast_constant(struct ast_state *Py_UNUSED(state), PyObject* obj, PyObject** out, PyArena* arena)
{
    if (_PyArena_AddPyObject(arena, obj) < 0) {
        *out = NULL;
        return -1;
    }
    *out = Py_NewRef(obj);
    return 0;
}

static int obj2ast_identifier(struct ast_state *state, PyObject* obj, PyObject** out, PyArena* arena)
{
    if (!PyUnicode_CheckExact(obj) && obj != Py_None) {
        PyErr_SetString(PyExc_TypeError, "AST identifier must be of type str");
        return -1;
    }
    return obj2ast_object(state, obj, out, arena);
}

static int obj2ast_string(struct ast_state *state, PyObject* obj, PyObject** out, PyArena* arena)
{
    if (!PyUnicode_CheckExact(obj) && !PyBytes_CheckExact(obj)) {
        PyErr_SetString(PyExc_TypeError, "AST string must be of type str");
        return -1;
    }
    return obj2ast_object(state, obj, out, arena);
}

static int obj2ast_int(struct ast_state* Py_UNUSED(state), PyObject* obj, int* out, PyArena* arena)
{
    int i;
    if (!PyLong_Check(obj)) {
        PyErr_Format(PyExc_ValueError, "invalid integer value: %R", obj);
        return -1;
    }

    i = PyLong_AsInt(obj);
    if (i == -1 && PyErr_Occurred())
        return -1;
    *out = i;
    return 0;
}

static int add_ast_fields(struct ast_state *state)
{
    PyObject *empty_tuple;
    empty_tuple = PyTuple_New(0);
    if (!empty_tuple ||
        PyObject_SetAttrString(state->AST_type, "_fields", empty_tuple) < 0 ||
        PyObject_SetAttrString(state->AST_type, "__match_args__", empty_tuple) < 0 ||
        PyObject_SetAttrString(state->AST_type, "_attributes", empty_tuple) < 0 ||
        PyObject_SetAttrString(state->_AST_type, "_fields", empty_tuple) < 0 ||
        PyObject_SetAttrString(state->_AST_type, "__match_args__", empty_tuple) < 0 ||
        PyObject_SetAttrString(state->_AST_type, "_attributes", empty_tuple) < 0) {
        Py_XDECREF(empty_tuple);
        return -1;
    }
    Py_DECREF(empty_tuple);
    return 0;
}



static int
init_types(void *arg)
{
    struct ast_state *state = arg;
    if (init_identifiers(state) < 0) {
        return -1;
    }
    state->AST_type = PyType_FromSpec(&AST_type_spec);
    if (!state->AST_type) {
        return -1;
    }
    state->_AST_type = PyType_FromSpec(&_AST_type_spec);
    if (state->_AST_type == NULL) {
        return -1;
    }
    if (add_ast_fields(state) < 0) {
        return -1;
    }
    PyObject *t;
    state->mod_type = make_type(state, "mod", state->AST_type, NULL, 0,
        "mod = Module(stmt* body, type_ignore* type_ignores)\n"
        "    | Interactive(stmt* body)\n"
        "    | Expression(expr body)\n"
        "    | FunctionType(expr* argtypes, expr returns)");
    if (!state->mod_type) return -1;
    if (add_attributes(state, state->mod_type, NULL, 0) < 0) return -1;
    t = PyType_FromSpecWithBases(&_mod_type_spec, state->_AST_type);
    state->_mod_type = t;
    if (state->_mod_type == NULL) return -1;
    t = PyType_FromSpecWithBases(&_mod_seq_type_spec, state->_AST_type);
    state->_mod_seq_type = t;
    if (state->_mod_seq_type == NULL) return -1;
    state->Module_type = make_type(state, "Module", state->mod_type,
                                   Module_fields, 2,
        "Module(stmt* body, type_ignore* type_ignores)");
    if (!state->Module_type) return -1;
    t = PyType_FromSpecWithBases(&_Module_type_spec, state->_mod_type);
    state->_Module_type = t;
    if (state->_Module_type == NULL) return -1;
    if (add_fields(state->_Module_type, Module_fields, 2) < 0) return -1;
    state->Interactive_type = make_type(state, "Interactive", state->mod_type,
                                        Interactive_fields, 1,
        "Interactive(stmt* body)");
    if (!state->Interactive_type) return -1;
    t = PyType_FromSpecWithBases(&_Interactive_type_spec, state->_mod_type);
    state->_Interactive_type = t;
    if (state->_Interactive_type == NULL) return -1;
    if (add_fields(state->_Interactive_type, Interactive_fields, 1) < 0) return
        -1;
    state->Expression_type = make_type(state, "Expression", state->mod_type,
                                       Expression_fields, 1,
        "Expression(expr body)");
    if (!state->Expression_type) return -1;
    t = PyType_FromSpecWithBases(&_Expression_type_spec, state->_mod_type);
    state->_Expression_type = t;
    if (state->_Expression_type == NULL) return -1;
    if (add_fields(state->_Expression_type, Expression_fields, 1) < 0) return
        -1;
    state->FunctionType_type = make_type(state, "FunctionType",
                                         state->mod_type, FunctionType_fields,
                                         2,
        "FunctionType(expr* argtypes, expr returns)");
    if (!state->FunctionType_type) return -1;
    t = PyType_FromSpecWithBases(&_FunctionType_type_spec, state->_mod_type);
    state->_FunctionType_type = t;
    if (state->_FunctionType_type == NULL) return -1;
    if (add_fields(state->_FunctionType_type, FunctionType_fields, 2) < 0)
        return -1;
    state->stmt_type = make_type(state, "stmt", state->AST_type, NULL, 0,
        "stmt = FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment, type_param* type_params)\n"
        "     | AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment, type_param* type_params)\n"
        "     | ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list, type_param* type_params)\n"
        "     | Return(expr? value)\n"
        "     | Delete(expr* targets)\n"
        "     | Assign(expr* targets, expr value, string? type_comment)\n"
        "     | TypeAlias(expr name, type_param* type_params, expr value)\n"
        "     | AugAssign(expr target, operator op, expr value)\n"
        "     | AnnAssign(expr target, expr annotation, expr? value, int simple)\n"
        "     | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)\n"
        "     | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)\n"
        "     | While(expr test, stmt* body, stmt* orelse)\n"
        "     | If(expr test, stmt* body, stmt* orelse)\n"
        "     | With(withitem* items, stmt* body, string? type_comment)\n"
        "     | AsyncWith(withitem* items, stmt* body, string? type_comment)\n"
        "     | Match(expr subject, match_case* cases)\n"
        "     | Raise(expr? exc, expr? cause)\n"
        "     | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)\n"
        "     | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)\n"
        "     | Assert(expr test, expr? msg)\n"
        "     | Import(alias* names)\n"
        "     | ImportFrom(identifier? module, alias* names, int? level)\n"
        "     | Global(identifier* names)\n"
        "     | Nonlocal(identifier* names)\n"
        "     | Expr(expr value)\n"
        "     | Pass\n"
        "     | Break\n"
        "     | Continue");
    if (!state->stmt_type) return -1;
    if (add_attributes(state, state->stmt_type, stmt_attributes, 4) < 0) return
        -1;
    if (PyObject_SetAttr(state->stmt_type, state->end_lineno, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->stmt_type, state->end_col_offset, Py_None) ==
        -1)
        return -1;
    t = PyType_FromSpecWithBases(&_stmt_type_spec, state->_AST_type);
    state->_stmt_type = t;
    if (state->_stmt_type == NULL) return -1;
    if (add_attributes(state, state->_stmt_type, stmt_attributes, 4) < 0)
        return -1;
    if (PyObject_SetAttr(state->_stmt_type, state->end_lineno, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_stmt_type, state->end_col_offset, Py_None) ==
        -1)
        return -1;
    t = PyType_FromSpecWithBases(&_stmt_seq_type_spec, state->_AST_type);
    state->_stmt_seq_type = t;
    if (state->_stmt_seq_type == NULL) return -1;
    state->FunctionDef_type = make_type(state, "FunctionDef", state->stmt_type,
                                        FunctionDef_fields, 7,
        "FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment, type_param* type_params)");
    if (!state->FunctionDef_type) return -1;
    if (PyObject_SetAttr(state->FunctionDef_type, state->returns, Py_None) ==
        -1)
        return -1;
    if (PyObject_SetAttr(state->FunctionDef_type, state->type_comment, Py_None)
        == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_FunctionDef_type_spec, state->_stmt_type);
    state->_FunctionDef_type = t;
    if (state->_FunctionDef_type == NULL) return -1;
    if (add_fields(state->_FunctionDef_type, FunctionDef_fields, 7) < 0) return
        -1;
    if (PyObject_SetAttr(state->_FunctionDef_type, state->returns, Py_None) ==
        -1)
        return -1;
    if (PyObject_SetAttr(state->_FunctionDef_type, state->type_comment,
        Py_None) == -1)
        return -1;
    state->AsyncFunctionDef_type = make_type(state, "AsyncFunctionDef",
                                             state->stmt_type,
                                             AsyncFunctionDef_fields, 7,
        "AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment, type_param* type_params)");
    if (!state->AsyncFunctionDef_type) return -1;
    if (PyObject_SetAttr(state->AsyncFunctionDef_type, state->returns, Py_None)
        == -1)
        return -1;
    if (PyObject_SetAttr(state->AsyncFunctionDef_type, state->type_comment,
        Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_AsyncFunctionDef_type_spec,
                                 state->_stmt_type);
    state->_AsyncFunctionDef_type = t;
    if (state->_AsyncFunctionDef_type == NULL) return -1;
    if (add_fields(state->_AsyncFunctionDef_type, AsyncFunctionDef_fields, 7) <
        0) return -1;
    if (PyObject_SetAttr(state->_AsyncFunctionDef_type, state->returns,
        Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_AsyncFunctionDef_type, state->type_comment,
        Py_None) == -1)
        return -1;
    state->ClassDef_type = make_type(state, "ClassDef", state->stmt_type,
                                     ClassDef_fields, 6,
        "ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list, type_param* type_params)");
    if (!state->ClassDef_type) return -1;
    t = PyType_FromSpecWithBases(&_ClassDef_type_spec, state->_stmt_type);
    state->_ClassDef_type = t;
    if (state->_ClassDef_type == NULL) return -1;
    if (add_fields(state->_ClassDef_type, ClassDef_fields, 6) < 0) return -1;
    state->Return_type = make_type(state, "Return", state->stmt_type,
                                   Return_fields, 1,
        "Return(expr? value)");
    if (!state->Return_type) return -1;
    if (PyObject_SetAttr(state->Return_type, state->value, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_Return_type_spec, state->_stmt_type);
    state->_Return_type = t;
    if (state->_Return_type == NULL) return -1;
    if (add_fields(state->_Return_type, Return_fields, 1) < 0) return -1;
    if (PyObject_SetAttr(state->_Return_type, state->value, Py_None) == -1)
        return -1;
    state->Delete_type = make_type(state, "Delete", state->stmt_type,
                                   Delete_fields, 1,
        "Delete(expr* targets)");
    if (!state->Delete_type) return -1;
    t = PyType_FromSpecWithBases(&_Delete_type_spec, state->_stmt_type);
    state->_Delete_type = t;
    if (state->_Delete_type == NULL) return -1;
    if (add_fields(state->_Delete_type, Delete_fields, 1) < 0) return -1;
    state->Assign_type = make_type(state, "Assign", state->stmt_type,
                                   Assign_fields, 3,
        "Assign(expr* targets, expr value, string? type_comment)");
    if (!state->Assign_type) return -1;
    if (PyObject_SetAttr(state->Assign_type, state->type_comment, Py_None) ==
        -1)
        return -1;
    t = PyType_FromSpecWithBases(&_Assign_type_spec, state->_stmt_type);
    state->_Assign_type = t;
    if (state->_Assign_type == NULL) return -1;
    if (add_fields(state->_Assign_type, Assign_fields, 3) < 0) return -1;
    if (PyObject_SetAttr(state->_Assign_type, state->type_comment, Py_None) ==
        -1)
        return -1;
    state->TypeAlias_type = make_type(state, "TypeAlias", state->stmt_type,
                                      TypeAlias_fields, 3,
        "TypeAlias(expr name, type_param* type_params, expr value)");
    if (!state->TypeAlias_type) return -1;
    t = PyType_FromSpecWithBases(&_TypeAlias_type_spec, state->_stmt_type);
    state->_TypeAlias_type = t;
    if (state->_TypeAlias_type == NULL) return -1;
    if (add_fields(state->_TypeAlias_type, TypeAlias_fields, 3) < 0) return -1;
    state->AugAssign_type = make_type(state, "AugAssign", state->stmt_type,
                                      AugAssign_fields, 3,
        "AugAssign(expr target, operator op, expr value)");
    if (!state->AugAssign_type) return -1;
    t = PyType_FromSpecWithBases(&_AugAssign_type_spec, state->_stmt_type);
    state->_AugAssign_type = t;
    if (state->_AugAssign_type == NULL) return -1;
    if (add_fields(state->_AugAssign_type, AugAssign_fields, 3) < 0) return -1;
    state->AnnAssign_type = make_type(state, "AnnAssign", state->stmt_type,
                                      AnnAssign_fields, 4,
        "AnnAssign(expr target, expr annotation, expr? value, int simple)");
    if (!state->AnnAssign_type) return -1;
    if (PyObject_SetAttr(state->AnnAssign_type, state->value, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_AnnAssign_type_spec, state->_stmt_type);
    state->_AnnAssign_type = t;
    if (state->_AnnAssign_type == NULL) return -1;
    if (add_fields(state->_AnnAssign_type, AnnAssign_fields, 4) < 0) return -1;
    if (PyObject_SetAttr(state->_AnnAssign_type, state->value, Py_None) == -1)
        return -1;
    state->For_type = make_type(state, "For", state->stmt_type, For_fields, 5,
        "For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)");
    if (!state->For_type) return -1;
    if (PyObject_SetAttr(state->For_type, state->type_comment, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_For_type_spec, state->_stmt_type);
    state->_For_type = t;
    if (state->_For_type == NULL) return -1;
    if (add_fields(state->_For_type, For_fields, 5) < 0) return -1;
    if (PyObject_SetAttr(state->_For_type, state->type_comment, Py_None) == -1)
        return -1;
    state->AsyncFor_type = make_type(state, "AsyncFor", state->stmt_type,
                                     AsyncFor_fields, 5,
        "AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)");
    if (!state->AsyncFor_type) return -1;
    if (PyObject_SetAttr(state->AsyncFor_type, state->type_comment, Py_None) ==
        -1)
        return -1;
    t = PyType_FromSpecWithBases(&_AsyncFor_type_spec, state->_stmt_type);
    state->_AsyncFor_type = t;
    if (state->_AsyncFor_type == NULL) return -1;
    if (add_fields(state->_AsyncFor_type, AsyncFor_fields, 5) < 0) return -1;
    if (PyObject_SetAttr(state->_AsyncFor_type, state->type_comment, Py_None)
        == -1)
        return -1;
    state->While_type = make_type(state, "While", state->stmt_type,
                                  While_fields, 3,
        "While(expr test, stmt* body, stmt* orelse)");
    if (!state->While_type) return -1;
    t = PyType_FromSpecWithBases(&_While_type_spec, state->_stmt_type);
    state->_While_type = t;
    if (state->_While_type == NULL) return -1;
    if (add_fields(state->_While_type, While_fields, 3) < 0) return -1;
    state->If_type = make_type(state, "If", state->stmt_type, If_fields, 3,
        "If(expr test, stmt* body, stmt* orelse)");
    if (!state->If_type) return -1;
    t = PyType_FromSpecWithBases(&_If_type_spec, state->_stmt_type);
    state->_If_type = t;
    if (state->_If_type == NULL) return -1;
    if (add_fields(state->_If_type, If_fields, 3) < 0) return -1;
    state->With_type = make_type(state, "With", state->stmt_type, With_fields,
                                 3,
        "With(withitem* items, stmt* body, string? type_comment)");
    if (!state->With_type) return -1;
    if (PyObject_SetAttr(state->With_type, state->type_comment, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_With_type_spec, state->_stmt_type);
    state->_With_type = t;
    if (state->_With_type == NULL) return -1;
    if (add_fields(state->_With_type, With_fields, 3) < 0) return -1;
    if (PyObject_SetAttr(state->_With_type, state->type_comment, Py_None) == -1)
        return -1;
    state->AsyncWith_type = make_type(state, "AsyncWith", state->stmt_type,
                                      AsyncWith_fields, 3,
        "AsyncWith(withitem* items, stmt* body, string? type_comment)");
    if (!state->AsyncWith_type) return -1;
    if (PyObject_SetAttr(state->AsyncWith_type, state->type_comment, Py_None)
        == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_AsyncWith_type_spec, state->_stmt_type);
    state->_AsyncWith_type = t;
    if (state->_AsyncWith_type == NULL) return -1;
    if (add_fields(state->_AsyncWith_type, AsyncWith_fields, 3) < 0) return -1;
    if (PyObject_SetAttr(state->_AsyncWith_type, state->type_comment, Py_None)
        == -1)
        return -1;
    state->Match_type = make_type(state, "Match", state->stmt_type,
                                  Match_fields, 2,
        "Match(expr subject, match_case* cases)");
    if (!state->Match_type) return -1;
    t = PyType_FromSpecWithBases(&_Match_type_spec, state->_stmt_type);
    state->_Match_type = t;
    if (state->_Match_type == NULL) return -1;
    if (add_fields(state->_Match_type, Match_fields, 2) < 0) return -1;
    state->Raise_type = make_type(state, "Raise", state->stmt_type,
                                  Raise_fields, 2,
        "Raise(expr? exc, expr? cause)");
    if (!state->Raise_type) return -1;
    if (PyObject_SetAttr(state->Raise_type, state->exc, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->Raise_type, state->cause, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_Raise_type_spec, state->_stmt_type);
    state->_Raise_type = t;
    if (state->_Raise_type == NULL) return -1;
    if (add_fields(state->_Raise_type, Raise_fields, 2) < 0) return -1;
    if (PyObject_SetAttr(state->_Raise_type, state->exc, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_Raise_type, state->cause, Py_None) == -1)
        return -1;
    state->Try_type = make_type(state, "Try", state->stmt_type, Try_fields, 4,
        "Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)");
    if (!state->Try_type) return -1;
    t = PyType_FromSpecWithBases(&_Try_type_spec, state->_stmt_type);
    state->_Try_type = t;
    if (state->_Try_type == NULL) return -1;
    if (add_fields(state->_Try_type, Try_fields, 4) < 0) return -1;
    state->TryStar_type = make_type(state, "TryStar", state->stmt_type,
                                    TryStar_fields, 4,
        "TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)");
    if (!state->TryStar_type) return -1;
    t = PyType_FromSpecWithBases(&_TryStar_type_spec, state->_stmt_type);
    state->_TryStar_type = t;
    if (state->_TryStar_type == NULL) return -1;
    if (add_fields(state->_TryStar_type, TryStar_fields, 4) < 0) return -1;
    state->Assert_type = make_type(state, "Assert", state->stmt_type,
                                   Assert_fields, 2,
        "Assert(expr test, expr? msg)");
    if (!state->Assert_type) return -1;
    if (PyObject_SetAttr(state->Assert_type, state->msg, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_Assert_type_spec, state->_stmt_type);
    state->_Assert_type = t;
    if (state->_Assert_type == NULL) return -1;
    if (add_fields(state->_Assert_type, Assert_fields, 2) < 0) return -1;
    if (PyObject_SetAttr(state->_Assert_type, state->msg, Py_None) == -1)
        return -1;
    state->Import_type = make_type(state, "Import", state->stmt_type,
                                   Import_fields, 1,
        "Import(alias* names)");
    if (!state->Import_type) return -1;
    t = PyType_FromSpecWithBases(&_Import_type_spec, state->_stmt_type);
    state->_Import_type = t;
    if (state->_Import_type == NULL) return -1;
    if (add_fields(state->_Import_type, Import_fields, 1) < 0) return -1;
    state->ImportFrom_type = make_type(state, "ImportFrom", state->stmt_type,
                                       ImportFrom_fields, 3,
        "ImportFrom(identifier? module, alias* names, int? level)");
    if (!state->ImportFrom_type) return -1;
    if (PyObject_SetAttr(state->ImportFrom_type, state->module, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->ImportFrom_type, state->level, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_ImportFrom_type_spec, state->_stmt_type);
    state->_ImportFrom_type = t;
    if (state->_ImportFrom_type == NULL) return -1;
    if (add_fields(state->_ImportFrom_type, ImportFrom_fields, 3) < 0) return
        -1;
    if (PyObject_SetAttr(state->_ImportFrom_type, state->module, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_ImportFrom_type, state->level, Py_None) == -1)
        return -1;
    state->Global_type = make_type(state, "Global", state->stmt_type,
                                   Global_fields, 1,
        "Global(identifier* names)");
    if (!state->Global_type) return -1;
    t = PyType_FromSpecWithBases(&_Global_type_spec, state->_stmt_type);
    state->_Global_type = t;
    if (state->_Global_type == NULL) return -1;
    if (add_fields(state->_Global_type, Global_fields, 1) < 0) return -1;
    state->Nonlocal_type = make_type(state, "Nonlocal", state->stmt_type,
                                     Nonlocal_fields, 1,
        "Nonlocal(identifier* names)");
    if (!state->Nonlocal_type) return -1;
    t = PyType_FromSpecWithBases(&_Nonlocal_type_spec, state->_stmt_type);
    state->_Nonlocal_type = t;
    if (state->_Nonlocal_type == NULL) return -1;
    if (add_fields(state->_Nonlocal_type, Nonlocal_fields, 1) < 0) return -1;
    state->Expr_type = make_type(state, "Expr", state->stmt_type, Expr_fields,
                                 1,
        "Expr(expr value)");
    if (!state->Expr_type) return -1;
    t = PyType_FromSpecWithBases(&_Expr_type_spec, state->_stmt_type);
    state->_Expr_type = t;
    if (state->_Expr_type == NULL) return -1;
    if (add_fields(state->_Expr_type, Expr_fields, 1) < 0) return -1;
    state->Pass_type = make_type(state, "Pass", state->stmt_type, NULL, 0,
        "Pass");
    if (!state->Pass_type) return -1;
    t = PyType_FromSpecWithBases(&_Pass_type_spec, state->_stmt_type);
    state->_Pass_type = t;
    if (state->_Pass_type == NULL) return -1;
    if (add_fields(state->_Pass_type, NULL, 0) < 0) return -1;
    state->Break_type = make_type(state, "Break", state->stmt_type, NULL, 0,
        "Break");
    if (!state->Break_type) return -1;
    t = PyType_FromSpecWithBases(&_Break_type_spec, state->_stmt_type);
    state->_Break_type = t;
    if (state->_Break_type == NULL) return -1;
    if (add_fields(state->_Break_type, NULL, 0) < 0) return -1;
    state->Continue_type = make_type(state, "Continue", state->stmt_type, NULL,
                                     0,
        "Continue");
    if (!state->Continue_type) return -1;
    t = PyType_FromSpecWithBases(&_Continue_type_spec, state->_stmt_type);
    state->_Continue_type = t;
    if (state->_Continue_type == NULL) return -1;
    if (add_fields(state->_Continue_type, NULL, 0) < 0) return -1;
    state->expr_type = make_type(state, "expr", state->AST_type, NULL, 0,
        "expr = BoolOp(boolop op, expr* values)\n"
        "     | NamedExpr(expr target, expr value)\n"
        "     | BinOp(expr left, operator op, expr right)\n"
        "     | UnaryOp(unaryop op, expr operand)\n"
        "     | Lambda(arguments args, expr body)\n"
        "     | IfExp(expr test, expr body, expr orelse)\n"
        "     | Dict(expr?* keys, expr* values)\n"
        "     | Set(expr* elts)\n"
        "     | ListComp(expr elt, comprehension* generators)\n"
        "     | SetComp(expr elt, comprehension* generators)\n"
        "     | DictComp(expr key, expr value, comprehension* generators)\n"
        "     | GeneratorExp(expr elt, comprehension* generators)\n"
        "     | Await(expr value)\n"
        "     | Yield(expr? value)\n"
        "     | YieldFrom(expr value)\n"
        "     | Compare(expr left, cmpop* ops, expr* comparators)\n"
        "     | Call(expr func, expr* args, keyword* keywords)\n"
        "     | FormattedValue(expr value, int conversion, expr? format_spec)\n"
        "     | Interpolation(expr value, constant str, int conversion, expr? format_spec)\n"
        "     | JoinedStr(expr* values)\n"
        "     | TemplateStr(expr* values)\n"
        "     | Constant(constant value, string? kind)\n"
        "     | Attribute(expr value, identifier attr, expr_context ctx)\n"
        "     | Subscript(expr value, expr slice, expr_context ctx)\n"
        "     | Starred(expr value, expr_context ctx)\n"
        "     | Name(identifier id, expr_context ctx)\n"
        "     | List(expr* elts, expr_context ctx)\n"
        "     | Tuple(expr* elts, expr_context ctx)\n"
        "     | Slice(expr? lower, expr? upper, expr? step)");
    if (!state->expr_type) return -1;
    if (add_attributes(state, state->expr_type, expr_attributes, 4) < 0) return
        -1;
    if (PyObject_SetAttr(state->expr_type, state->end_lineno, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->expr_type, state->end_col_offset, Py_None) ==
        -1)
        return -1;
    t = PyType_FromSpecWithBases(&_expr_type_spec, state->_AST_type);
    state->_expr_type = t;
    if (state->_expr_type == NULL) return -1;
    if (add_attributes(state, state->_expr_type, expr_attributes, 4) < 0)
        return -1;
    if (PyObject_SetAttr(state->_expr_type, state->end_lineno, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_expr_type, state->end_col_offset, Py_None) ==
        -1)
        return -1;
    t = PyType_FromSpecWithBases(&_expr_seq_type_spec, state->_AST_type);
    state->_expr_seq_type = t;
    if (state->_expr_seq_type == NULL) return -1;
    state->BoolOp_type = make_type(state, "BoolOp", state->expr_type,
                                   BoolOp_fields, 2,
        "BoolOp(boolop op, expr* values)");
    if (!state->BoolOp_type) return -1;
    t = PyType_FromSpecWithBases(&_BoolOp_type_spec, state->_expr_type);
    state->_BoolOp_type = t;
    if (state->_BoolOp_type == NULL) return -1;
    if (add_fields(state->_BoolOp_type, BoolOp_fields, 2) < 0) return -1;
    state->NamedExpr_type = make_type(state, "NamedExpr", state->expr_type,
                                      NamedExpr_fields, 2,
        "NamedExpr(expr target, expr value)");
    if (!state->NamedExpr_type) return -1;
    t = PyType_FromSpecWithBases(&_NamedExpr_type_spec, state->_expr_type);
    state->_NamedExpr_type = t;
    if (state->_NamedExpr_type == NULL) return -1;
    if (add_fields(state->_NamedExpr_type, NamedExpr_fields, 2) < 0) return -1;
    state->BinOp_type = make_type(state, "BinOp", state->expr_type,
                                  BinOp_fields, 3,
        "BinOp(expr left, operator op, expr right)");
    if (!state->BinOp_type) return -1;
    t = PyType_FromSpecWithBases(&_BinOp_type_spec, state->_expr_type);
    state->_BinOp_type = t;
    if (state->_BinOp_type == NULL) return -1;
    if (add_fields(state->_BinOp_type, BinOp_fields, 3) < 0) return -1;
    state->UnaryOp_type = make_type(state, "UnaryOp", state->expr_type,
                                    UnaryOp_fields, 2,
        "UnaryOp(unaryop op, expr operand)");
    if (!state->UnaryOp_type) return -1;
    t = PyType_FromSpecWithBases(&_UnaryOp_type_spec, state->_expr_type);
    state->_UnaryOp_type = t;
    if (state->_UnaryOp_type == NULL) return -1;
    if (add_fields(state->_UnaryOp_type, UnaryOp_fields, 2) < 0) return -1;
    state->Lambda_type = make_type(state, "Lambda", state->expr_type,
                                   Lambda_fields, 2,
        "Lambda(arguments args, expr body)");
    if (!state->Lambda_type) return -1;
    t = PyType_FromSpecWithBases(&_Lambda_type_spec, state->_expr_type);
    state->_Lambda_type = t;
    if (state->_Lambda_type == NULL) return -1;
    if (add_fields(state->_Lambda_type, Lambda_fields, 2) < 0) return -1;
    state->IfExp_type = make_type(state, "IfExp", state->expr_type,
                                  IfExp_fields, 3,
        "IfExp(expr test, expr body, expr orelse)");
    if (!state->IfExp_type) return -1;
    t = PyType_FromSpecWithBases(&_IfExp_type_spec, state->_expr_type);
    state->_IfExp_type = t;
    if (state->_IfExp_type == NULL) return -1;
    if (add_fields(state->_IfExp_type, IfExp_fields, 3) < 0) return -1;
    state->Dict_type = make_type(state, "Dict", state->expr_type, Dict_fields,
                                 2,
        "Dict(expr?* keys, expr* values)");
    if (!state->Dict_type) return -1;
    t = PyType_FromSpecWithBases(&_Dict_type_spec, state->_expr_type);
    state->_Dict_type = t;
    if (state->_Dict_type == NULL) return -1;
    if (add_fields(state->_Dict_type, Dict_fields, 2) < 0) return -1;
    state->Set_type = make_type(state, "Set", state->expr_type, Set_fields, 1,
        "Set(expr* elts)");
    if (!state->Set_type) return -1;
    t = PyType_FromSpecWithBases(&_Set_type_spec, state->_expr_type);
    state->_Set_type = t;
    if (state->_Set_type == NULL) return -1;
    if (add_fields(state->_Set_type, Set_fields, 1) < 0) return -1;
    state->ListComp_type = make_type(state, "ListComp", state->expr_type,
                                     ListComp_fields, 2,
        "ListComp(expr elt, comprehension* generators)");
    if (!state->ListComp_type) return -1;
    t = PyType_FromSpecWithBases(&_ListComp_type_spec, state->_expr_type);
    state->_ListComp_type = t;
    if (state->_ListComp_type == NULL) return -1;
    if (add_fields(state->_ListComp_type, ListComp_fields, 2) < 0) return -1;
    state->SetComp_type = make_type(state, "SetComp", state->expr_type,
                                    SetComp_fields, 2,
        "SetComp(expr elt, comprehension* generators)");
    if (!state->SetComp_type) return -1;
    t = PyType_FromSpecWithBases(&_SetComp_type_spec, state->_expr_type);
    state->_SetComp_type = t;
    if (state->_SetComp_type == NULL) return -1;
    if (add_fields(state->_SetComp_type, SetComp_fields, 2) < 0) return -1;
    state->DictComp_type = make_type(state, "DictComp", state->expr_type,
                                     DictComp_fields, 3,
        "DictComp(expr key, expr value, comprehension* generators)");
    if (!state->DictComp_type) return -1;
    t = PyType_FromSpecWithBases(&_DictComp_type_spec, state->_expr_type);
    state->_DictComp_type = t;
    if (state->_DictComp_type == NULL) return -1;
    if (add_fields(state->_DictComp_type, DictComp_fields, 3) < 0) return -1;
    state->GeneratorExp_type = make_type(state, "GeneratorExp",
                                         state->expr_type, GeneratorExp_fields,
                                         2,
        "GeneratorExp(expr elt, comprehension* generators)");
    if (!state->GeneratorExp_type) return -1;
    t = PyType_FromSpecWithBases(&_GeneratorExp_type_spec, state->_expr_type);
    state->_GeneratorExp_type = t;
    if (state->_GeneratorExp_type == NULL) return -1;
    if (add_fields(state->_GeneratorExp_type, GeneratorExp_fields, 2) < 0)
        return -1;
    state->Await_type = make_type(state, "Await", state->expr_type,
                                  Await_fields, 1,
        "Await(expr value)");
    if (!state->Await_type) return -1;
    t = PyType_FromSpecWithBases(&_Await_type_spec, state->_expr_type);
    state->_Await_type = t;
    if (state->_Await_type == NULL) return -1;
    if (add_fields(state->_Await_type, Await_fields, 1) < 0) return -1;
    state->Yield_type = make_type(state, "Yield", state->expr_type,
                                  Yield_fields, 1,
        "Yield(expr? value)");
    if (!state->Yield_type) return -1;
    if (PyObject_SetAttr(state->Yield_type, state->value, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_Yield_type_spec, state->_expr_type);
    state->_Yield_type = t;
    if (state->_Yield_type == NULL) return -1;
    if (add_fields(state->_Yield_type, Yield_fields, 1) < 0) return -1;
    if (PyObject_SetAttr(state->_Yield_type, state->value, Py_None) == -1)
        return -1;
    state->YieldFrom_type = make_type(state, "YieldFrom", state->expr_type,
                                      YieldFrom_fields, 1,
        "YieldFrom(expr value)");
    if (!state->YieldFrom_type) return -1;
    t = PyType_FromSpecWithBases(&_YieldFrom_type_spec, state->_expr_type);
    state->_YieldFrom_type = t;
    if (state->_YieldFrom_type == NULL) return -1;
    if (add_fields(state->_YieldFrom_type, YieldFrom_fields, 1) < 0) return -1;
    state->Compare_type = make_type(state, "Compare", state->expr_type,
                                    Compare_fields, 3,
        "Compare(expr left, cmpop* ops, expr* comparators)");
    if (!state->Compare_type) return -1;
    t = PyType_FromSpecWithBases(&_Compare_type_spec, state->_expr_type);
    state->_Compare_type = t;
    if (state->_Compare_type == NULL) return -1;
    if (add_fields(state->_Compare_type, Compare_fields, 3) < 0) return -1;
    state->Call_type = make_type(state, "Call", state->expr_type, Call_fields,
                                 3,
        "Call(expr func, expr* args, keyword* keywords)");
    if (!state->Call_type) return -1;
    t = PyType_FromSpecWithBases(&_Call_type_spec, state->_expr_type);
    state->_Call_type = t;
    if (state->_Call_type == NULL) return -1;
    if (add_fields(state->_Call_type, Call_fields, 3) < 0) return -1;
    state->FormattedValue_type = make_type(state, "FormattedValue",
                                           state->expr_type,
                                           FormattedValue_fields, 3,
        "FormattedValue(expr value, int conversion, expr? format_spec)");
    if (!state->FormattedValue_type) return -1;
    if (PyObject_SetAttr(state->FormattedValue_type, state->format_spec,
        Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_FormattedValue_type_spec, state->_expr_type);
    state->_FormattedValue_type = t;
    if (state->_FormattedValue_type == NULL) return -1;
    if (add_fields(state->_FormattedValue_type, FormattedValue_fields, 3) < 0)
        return -1;
    if (PyObject_SetAttr(state->_FormattedValue_type, state->format_spec,
        Py_None) == -1)
        return -1;
    state->Interpolation_type = make_type(state, "Interpolation",
                                          state->expr_type,
                                          Interpolation_fields, 4,
        "Interpolation(expr value, constant str, int conversion, expr? format_spec)");
    if (!state->Interpolation_type) return -1;
    if (PyObject_SetAttr(state->Interpolation_type, state->format_spec,
        Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_Interpolation_type_spec, state->_expr_type);
    state->_Interpolation_type = t;
    if (state->_Interpolation_type == NULL) return -1;
    if (add_fields(state->_Interpolation_type, Interpolation_fields, 4) < 0)
        return -1;
    if (PyObject_SetAttr(state->_Interpolation_type, state->format_spec,
        Py_None) == -1)
        return -1;
    state->JoinedStr_type = make_type(state, "JoinedStr", state->expr_type,
                                      JoinedStr_fields, 1,
        "JoinedStr(expr* values)");
    if (!state->JoinedStr_type) return -1;
    t = PyType_FromSpecWithBases(&_JoinedStr_type_spec, state->_expr_type);
    state->_JoinedStr_type = t;
    if (state->_JoinedStr_type == NULL) return -1;
    if (add_fields(state->_JoinedStr_type, JoinedStr_fields, 1) < 0) return -1;
    state->TemplateStr_type = make_type(state, "TemplateStr", state->expr_type,
                                        TemplateStr_fields, 1,
        "TemplateStr(expr* values)");
    if (!state->TemplateStr_type) return -1;
    t = PyType_FromSpecWithBases(&_TemplateStr_type_spec, state->_expr_type);
    state->_TemplateStr_type = t;
    if (state->_TemplateStr_type == NULL) return -1;
    if (add_fields(state->_TemplateStr_type, TemplateStr_fields, 1) < 0) return
        -1;
    state->Constant_type = make_type(state, "Constant", state->expr_type,
                                     Constant_fields, 2,
        "Constant(constant value, string? kind)");
    if (!state->Constant_type) return -1;
    if (PyObject_SetAttr(state->Constant_type, state->kind, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_Constant_type_spec, state->_expr_type);
    state->_Constant_type = t;
    if (state->_Constant_type == NULL) return -1;
    if (add_fields(state->_Constant_type, Constant_fields, 2) < 0) return -1;
    if (PyObject_SetAttr(state->_Constant_type, state->kind, Py_None) == -1)
        return -1;
    state->Attribute_type = make_type(state, "Attribute", state->expr_type,
                                      Attribute_fields, 3,
        "Attribute(expr value, identifier attr, expr_context ctx)");
    if (!state->Attribute_type) return -1;
    t = PyType_FromSpecWithBases(&_Attribute_type_spec, state->_expr_type);
    state->_Attribute_type = t;
    if (state->_Attribute_type == NULL) return -1;
    if (add_fields(state->_Attribute_type, Attribute_fields, 3) < 0) return -1;
    state->Subscript_type = make_type(state, "Subscript", state->expr_type,
                                      Subscript_fields, 3,
        "Subscript(expr value, expr slice, expr_context ctx)");
    if (!state->Subscript_type) return -1;
    t = PyType_FromSpecWithBases(&_Subscript_type_spec, state->_expr_type);
    state->_Subscript_type = t;
    if (state->_Subscript_type == NULL) return -1;
    if (add_fields(state->_Subscript_type, Subscript_fields, 3) < 0) return -1;
    state->Starred_type = make_type(state, "Starred", state->expr_type,
                                    Starred_fields, 2,
        "Starred(expr value, expr_context ctx)");
    if (!state->Starred_type) return -1;
    t = PyType_FromSpecWithBases(&_Starred_type_spec, state->_expr_type);
    state->_Starred_type = t;
    if (state->_Starred_type == NULL) return -1;
    if (add_fields(state->_Starred_type, Starred_fields, 2) < 0) return -1;
    state->Name_type = make_type(state, "Name", state->expr_type, Name_fields,
                                 2,
        "Name(identifier id, expr_context ctx)");
    if (!state->Name_type) return -1;
    t = PyType_FromSpecWithBases(&_Name_type_spec, state->_expr_type);
    state->_Name_type = t;
    if (state->_Name_type == NULL) return -1;
    if (add_fields(state->_Name_type, Name_fields, 2) < 0) return -1;
    state->List_type = make_type(state, "List", state->expr_type, List_fields,
                                 2,
        "List(expr* elts, expr_context ctx)");
    if (!state->List_type) return -1;
    t = PyType_FromSpecWithBases(&_List_type_spec, state->_expr_type);
    state->_List_type = t;
    if (state->_List_type == NULL) return -1;
    if (add_fields(state->_List_type, List_fields, 2) < 0) return -1;
    state->Tuple_type = make_type(state, "Tuple", state->expr_type,
                                  Tuple_fields, 2,
        "Tuple(expr* elts, expr_context ctx)");
    if (!state->Tuple_type) return -1;
    t = PyType_FromSpecWithBases(&_Tuple_type_spec, state->_expr_type);
    state->_Tuple_type = t;
    if (state->_Tuple_type == NULL) return -1;
    if (add_fields(state->_Tuple_type, Tuple_fields, 2) < 0) return -1;
    state->Slice_type = make_type(state, "Slice", state->expr_type,
                                  Slice_fields, 3,
        "Slice(expr? lower, expr? upper, expr? step)");
    if (!state->Slice_type) return -1;
    if (PyObject_SetAttr(state->Slice_type, state->lower, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->Slice_type, state->upper, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->Slice_type, state->step, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_Slice_type_spec, state->_expr_type);
    state->_Slice_type = t;
    if (state->_Slice_type == NULL) return -1;
    if (add_fields(state->_Slice_type, Slice_fields, 3) < 0) return -1;
    if (PyObject_SetAttr(state->_Slice_type, state->lower, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_Slice_type, state->upper, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_Slice_type, state->step, Py_None) == -1)
        return -1;
    state->expr_context_type = make_type(state, "expr_context",
                                         state->AST_type, NULL, 0,
        "expr_context = Load | Store | Del");
    if (!state->expr_context_type) return -1;
    if (add_attributes(state, state->expr_context_type, NULL, 0) < 0) return -1;
    t = PyType_FromSpecWithBases(&_expr_context_type_spec, state->_AST_type);
    state->_expr_context_type = t;
    if (state->_expr_context_type == NULL) return -1;
    state->Load_type = make_type(state, "Load", state->expr_context_type, NULL,
                                 0,
        "Load");
    if (!state->Load_type) return -1;
    t = PyType_FromSpecWithBases(&_Load_type_spec, state->_expr_context_type);
    state->_Load_type = t;
    if (state->_Load_type == NULL) return -1;
    if (add_fields(state->_Load_type, NULL, 0) < 0) return -1;
    state->Load_singleton = PyType_GenericNew((PyTypeObject *)state->Load_type,
                                              NULL, NULL);
    if (!state->Load_singleton) return -1;
    state->_Load_singleton = PyType_GenericNew((PyTypeObject
                                               *)state->_Load_type, NULL, NULL);
    if (!state->_Load_singleton) return -1;
    state->Store_type = make_type(state, "Store", state->expr_context_type,
                                  NULL, 0,
        "Store");
    if (!state->Store_type) return -1;
    t = PyType_FromSpecWithBases(&_Store_type_spec, state->_expr_context_type);
    state->_Store_type = t;
    if (state->_Store_type == NULL) return -1;
    if (add_fields(state->_Store_type, NULL, 0) < 0) return -1;
    state->Store_singleton = PyType_GenericNew((PyTypeObject
                                               *)state->Store_type, NULL, NULL);
    if (!state->Store_singleton) return -1;
    state->_Store_singleton = PyType_GenericNew((PyTypeObject
                                                *)state->_Store_type, NULL,
                                                NULL);
    if (!state->_Store_singleton) return -1;
    state->Del_type = make_type(state, "Del", state->expr_context_type, NULL, 0,
        "Del");
    if (!state->Del_type) return -1;
    t = PyType_FromSpecWithBases(&_Del_type_spec, state->_expr_context_type);
    state->_Del_type = t;
    if (state->_Del_type == NULL) return -1;
    if (add_fields(state->_Del_type, NULL, 0) < 0) return -1;
    state->Del_singleton = PyType_GenericNew((PyTypeObject *)state->Del_type,
                                             NULL, NULL);
    if (!state->Del_singleton) return -1;
    state->_Del_singleton = PyType_GenericNew((PyTypeObject *)state->_Del_type,
                                              NULL, NULL);
    if (!state->_Del_singleton) return -1;
    state->boolop_type = make_type(state, "boolop", state->AST_type, NULL, 0,
        "boolop = And | Or");
    if (!state->boolop_type) return -1;
    if (add_attributes(state, state->boolop_type, NULL, 0) < 0) return -1;
    t = PyType_FromSpecWithBases(&_boolop_type_spec, state->_AST_type);
    state->_boolop_type = t;
    if (state->_boolop_type == NULL) return -1;
    state->And_type = make_type(state, "And", state->boolop_type, NULL, 0,
        "And");
    if (!state->And_type) return -1;
    t = PyType_FromSpecWithBases(&_And_type_spec, state->_boolop_type);
    state->_And_type = t;
    if (state->_And_type == NULL) return -1;
    if (add_fields(state->_And_type, NULL, 0) < 0) return -1;
    state->And_singleton = PyType_GenericNew((PyTypeObject *)state->And_type,
                                             NULL, NULL);
    if (!state->And_singleton) return -1;
    state->_And_singleton = PyType_GenericNew((PyTypeObject *)state->_And_type,
                                              NULL, NULL);
    if (!state->_And_singleton) return -1;
    state->Or_type = make_type(state, "Or", state->boolop_type, NULL, 0,
        "Or");
    if (!state->Or_type) return -1;
    t = PyType_FromSpecWithBases(&_Or_type_spec, state->_boolop_type);
    state->_Or_type = t;
    if (state->_Or_type == NULL) return -1;
    if (add_fields(state->_Or_type, NULL, 0) < 0) return -1;
    state->Or_singleton = PyType_GenericNew((PyTypeObject *)state->Or_type,
                                            NULL, NULL);
    if (!state->Or_singleton) return -1;
    state->_Or_singleton = PyType_GenericNew((PyTypeObject *)state->_Or_type,
                                             NULL, NULL);
    if (!state->_Or_singleton) return -1;
    state->operator_type = make_type(state, "operator", state->AST_type, NULL,
                                     0,
        "operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift | RShift | BitOr | BitXor | BitAnd | FloorDiv");
    if (!state->operator_type) return -1;
    if (add_attributes(state, state->operator_type, NULL, 0) < 0) return -1;
    t = PyType_FromSpecWithBases(&_operator_type_spec, state->_AST_type);
    state->_operator_type = t;
    if (state->_operator_type == NULL) return -1;
    state->Add_type = make_type(state, "Add", state->operator_type, NULL, 0,
        "Add");
    if (!state->Add_type) return -1;
    t = PyType_FromSpecWithBases(&_Add_type_spec, state->_operator_type);
    state->_Add_type = t;
    if (state->_Add_type == NULL) return -1;
    if (add_fields(state->_Add_type, NULL, 0) < 0) return -1;
    state->Add_singleton = PyType_GenericNew((PyTypeObject *)state->Add_type,
                                             NULL, NULL);
    if (!state->Add_singleton) return -1;
    state->_Add_singleton = PyType_GenericNew((PyTypeObject *)state->_Add_type,
                                              NULL, NULL);
    if (!state->_Add_singleton) return -1;
    state->Sub_type = make_type(state, "Sub", state->operator_type, NULL, 0,
        "Sub");
    if (!state->Sub_type) return -1;
    t = PyType_FromSpecWithBases(&_Sub_type_spec, state->_operator_type);
    state->_Sub_type = t;
    if (state->_Sub_type == NULL) return -1;
    if (add_fields(state->_Sub_type, NULL, 0) < 0) return -1;
    state->Sub_singleton = PyType_GenericNew((PyTypeObject *)state->Sub_type,
                                             NULL, NULL);
    if (!state->Sub_singleton) return -1;
    state->_Sub_singleton = PyType_GenericNew((PyTypeObject *)state->_Sub_type,
                                              NULL, NULL);
    if (!state->_Sub_singleton) return -1;
    state->Mult_type = make_type(state, "Mult", state->operator_type, NULL, 0,
        "Mult");
    if (!state->Mult_type) return -1;
    t = PyType_FromSpecWithBases(&_Mult_type_spec, state->_operator_type);
    state->_Mult_type = t;
    if (state->_Mult_type == NULL) return -1;
    if (add_fields(state->_Mult_type, NULL, 0) < 0) return -1;
    state->Mult_singleton = PyType_GenericNew((PyTypeObject *)state->Mult_type,
                                              NULL, NULL);
    if (!state->Mult_singleton) return -1;
    state->_Mult_singleton = PyType_GenericNew((PyTypeObject
                                               *)state->_Mult_type, NULL, NULL);
    if (!state->_Mult_singleton) return -1;
    state->MatMult_type = make_type(state, "MatMult", state->operator_type,
                                    NULL, 0,
        "MatMult");
    if (!state->MatMult_type) return -1;
    t = PyType_FromSpecWithBases(&_MatMult_type_spec, state->_operator_type);
    state->_MatMult_type = t;
    if (state->_MatMult_type == NULL) return -1;
    if (add_fields(state->_MatMult_type, NULL, 0) < 0) return -1;
    state->MatMult_singleton = PyType_GenericNew((PyTypeObject
                                                 *)state->MatMult_type, NULL,
                                                 NULL);
    if (!state->MatMult_singleton) return -1;
    state->_MatMult_singleton = PyType_GenericNew((PyTypeObject
                                                  *)state->_MatMult_type, NULL,
                                                  NULL);
    if (!state->_MatMult_singleton) return -1;
    state->Div_type = make_type(state, "Div", state->operator_type, NULL, 0,
        "Div");
    if (!state->Div_type) return -1;
    t = PyType_FromSpecWithBases(&_Div_type_spec, state->_operator_type);
    state->_Div_type = t;
    if (state->_Div_type == NULL) return -1;
    if (add_fields(state->_Div_type, NULL, 0) < 0) return -1;
    state->Div_singleton = PyType_GenericNew((PyTypeObject *)state->Div_type,
                                             NULL, NULL);
    if (!state->Div_singleton) return -1;
    state->_Div_singleton = PyType_GenericNew((PyTypeObject *)state->_Div_type,
                                              NULL, NULL);
    if (!state->_Div_singleton) return -1;
    state->Mod_type = make_type(state, "Mod", state->operator_type, NULL, 0,
        "Mod");
    if (!state->Mod_type) return -1;
    t = PyType_FromSpecWithBases(&_Mod_type_spec, state->_operator_type);
    state->_Mod_type = t;
    if (state->_Mod_type == NULL) return -1;
    if (add_fields(state->_Mod_type, NULL, 0) < 0) return -1;
    state->Mod_singleton = PyType_GenericNew((PyTypeObject *)state->Mod_type,
                                             NULL, NULL);
    if (!state->Mod_singleton) return -1;
    state->_Mod_singleton = PyType_GenericNew((PyTypeObject *)state->_Mod_type,
                                              NULL, NULL);
    if (!state->_Mod_singleton) return -1;
    state->Pow_type = make_type(state, "Pow", state->operator_type, NULL, 0,
        "Pow");
    if (!state->Pow_type) return -1;
    t = PyType_FromSpecWithBases(&_Pow_type_spec, state->_operator_type);
    state->_Pow_type = t;
    if (state->_Pow_type == NULL) return -1;
    if (add_fields(state->_Pow_type, NULL, 0) < 0) return -1;
    state->Pow_singleton = PyType_GenericNew((PyTypeObject *)state->Pow_type,
                                             NULL, NULL);
    if (!state->Pow_singleton) return -1;
    state->_Pow_singleton = PyType_GenericNew((PyTypeObject *)state->_Pow_type,
                                              NULL, NULL);
    if (!state->_Pow_singleton) return -1;
    state->LShift_type = make_type(state, "LShift", state->operator_type, NULL,
                                   0,
        "LShift");
    if (!state->LShift_type) return -1;
    t = PyType_FromSpecWithBases(&_LShift_type_spec, state->_operator_type);
    state->_LShift_type = t;
    if (state->_LShift_type == NULL) return -1;
    if (add_fields(state->_LShift_type, NULL, 0) < 0) return -1;
    state->LShift_singleton = PyType_GenericNew((PyTypeObject
                                                *)state->LShift_type, NULL,
                                                NULL);
    if (!state->LShift_singleton) return -1;
    state->_LShift_singleton = PyType_GenericNew((PyTypeObject
                                                 *)state->_LShift_type, NULL,
                                                 NULL);
    if (!state->_LShift_singleton) return -1;
    state->RShift_type = make_type(state, "RShift", state->operator_type, NULL,
                                   0,
        "RShift");
    if (!state->RShift_type) return -1;
    t = PyType_FromSpecWithBases(&_RShift_type_spec, state->_operator_type);
    state->_RShift_type = t;
    if (state->_RShift_type == NULL) return -1;
    if (add_fields(state->_RShift_type, NULL, 0) < 0) return -1;
    state->RShift_singleton = PyType_GenericNew((PyTypeObject
                                                *)state->RShift_type, NULL,
                                                NULL);
    if (!state->RShift_singleton) return -1;
    state->_RShift_singleton = PyType_GenericNew((PyTypeObject
                                                 *)state->_RShift_type, NULL,
                                                 NULL);
    if (!state->_RShift_singleton) return -1;
    state->BitOr_type = make_type(state, "BitOr", state->operator_type, NULL, 0,
        "BitOr");
    if (!state->BitOr_type) return -1;
    t = PyType_FromSpecWithBases(&_BitOr_type_spec, state->_operator_type);
    state->_BitOr_type = t;
    if (state->_BitOr_type == NULL) return -1;
    if (add_fields(state->_BitOr_type, NULL, 0) < 0) return -1;
    state->BitOr_singleton = PyType_GenericNew((PyTypeObject
                                               *)state->BitOr_type, NULL, NULL);
    if (!state->BitOr_singleton) return -1;
    state->_BitOr_singleton = PyType_GenericNew((PyTypeObject
                                                *)state->_BitOr_type, NULL,
                                                NULL);
    if (!state->_BitOr_singleton) return -1;
    state->BitXor_type = make_type(state, "BitXor", state->operator_type, NULL,
                                   0,
        "BitXor");
    if (!state->BitXor_type) return -1;
    t = PyType_FromSpecWithBases(&_BitXor_type_spec, state->_operator_type);
    state->_BitXor_type = t;
    if (state->_BitXor_type == NULL) return -1;
    if (add_fields(state->_BitXor_type, NULL, 0) < 0) return -1;
    state->BitXor_singleton = PyType_GenericNew((PyTypeObject
                                                *)state->BitXor_type, NULL,
                                                NULL);
    if (!state->BitXor_singleton) return -1;
    state->_BitXor_singleton = PyType_GenericNew((PyTypeObject
                                                 *)state->_BitXor_type, NULL,
                                                 NULL);
    if (!state->_BitXor_singleton) return -1;
    state->BitAnd_type = make_type(state, "BitAnd", state->operator_type, NULL,
                                   0,
        "BitAnd");
    if (!state->BitAnd_type) return -1;
    t = PyType_FromSpecWithBases(&_BitAnd_type_spec, state->_operator_type);
    state->_BitAnd_type = t;
    if (state->_BitAnd_type == NULL) return -1;
    if (add_fields(state->_BitAnd_type, NULL, 0) < 0) return -1;
    state->BitAnd_singleton = PyType_GenericNew((PyTypeObject
                                                *)state->BitAnd_type, NULL,
                                                NULL);
    if (!state->BitAnd_singleton) return -1;
    state->_BitAnd_singleton = PyType_GenericNew((PyTypeObject
                                                 *)state->_BitAnd_type, NULL,
                                                 NULL);
    if (!state->_BitAnd_singleton) return -1;
    state->FloorDiv_type = make_type(state, "FloorDiv", state->operator_type,
                                     NULL, 0,
        "FloorDiv");
    if (!state->FloorDiv_type) return -1;
    t = PyType_FromSpecWithBases(&_FloorDiv_type_spec, state->_operator_type);
    state->_FloorDiv_type = t;
    if (state->_FloorDiv_type == NULL) return -1;
    if (add_fields(state->_FloorDiv_type, NULL, 0) < 0) return -1;
    state->FloorDiv_singleton = PyType_GenericNew((PyTypeObject
                                                  *)state->FloorDiv_type, NULL,
                                                  NULL);
    if (!state->FloorDiv_singleton) return -1;
    state->_FloorDiv_singleton = PyType_GenericNew((PyTypeObject
                                                   *)state->_FloorDiv_type,
                                                   NULL, NULL);
    if (!state->_FloorDiv_singleton) return -1;
    state->unaryop_type = make_type(state, "unaryop", state->AST_type, NULL, 0,
        "unaryop = Invert | Not | UAdd | USub");
    if (!state->unaryop_type) return -1;
    if (add_attributes(state, state->unaryop_type, NULL, 0) < 0) return -1;
    t = PyType_FromSpecWithBases(&_unaryop_type_spec, state->_AST_type);
    state->_unaryop_type = t;
    if (state->_unaryop_type == NULL) return -1;
    state->Invert_type = make_type(state, "Invert", state->unaryop_type, NULL,
                                   0,
        "Invert");
    if (!state->Invert_type) return -1;
    t = PyType_FromSpecWithBases(&_Invert_type_spec, state->_unaryop_type);
    state->_Invert_type = t;
    if (state->_Invert_type == NULL) return -1;
    if (add_fields(state->_Invert_type, NULL, 0) < 0) return -1;
    state->Invert_singleton = PyType_GenericNew((PyTypeObject
                                                *)state->Invert_type, NULL,
                                                NULL);
    if (!state->Invert_singleton) return -1;
    state->_Invert_singleton = PyType_GenericNew((PyTypeObject
                                                 *)state->_Invert_type, NULL,
                                                 NULL);
    if (!state->_Invert_singleton) return -1;
    state->Not_type = make_type(state, "Not", state->unaryop_type, NULL, 0,
        "Not");
    if (!state->Not_type) return -1;
    t = PyType_FromSpecWithBases(&_Not_type_spec, state->_unaryop_type);
    state->_Not_type = t;
    if (state->_Not_type == NULL) return -1;
    if (add_fields(state->_Not_type, NULL, 0) < 0) return -1;
    state->Not_singleton = PyType_GenericNew((PyTypeObject *)state->Not_type,
                                             NULL, NULL);
    if (!state->Not_singleton) return -1;
    state->_Not_singleton = PyType_GenericNew((PyTypeObject *)state->_Not_type,
                                              NULL, NULL);
    if (!state->_Not_singleton) return -1;
    state->UAdd_type = make_type(state, "UAdd", state->unaryop_type, NULL, 0,
        "UAdd");
    if (!state->UAdd_type) return -1;
    t = PyType_FromSpecWithBases(&_UAdd_type_spec, state->_unaryop_type);
    state->_UAdd_type = t;
    if (state->_UAdd_type == NULL) return -1;
    if (add_fields(state->_UAdd_type, NULL, 0) < 0) return -1;
    state->UAdd_singleton = PyType_GenericNew((PyTypeObject *)state->UAdd_type,
                                              NULL, NULL);
    if (!state->UAdd_singleton) return -1;
    state->_UAdd_singleton = PyType_GenericNew((PyTypeObject
                                               *)state->_UAdd_type, NULL, NULL);
    if (!state->_UAdd_singleton) return -1;
    state->USub_type = make_type(state, "USub", state->unaryop_type, NULL, 0,
        "USub");
    if (!state->USub_type) return -1;
    t = PyType_FromSpecWithBases(&_USub_type_spec, state->_unaryop_type);
    state->_USub_type = t;
    if (state->_USub_type == NULL) return -1;
    if (add_fields(state->_USub_type, NULL, 0) < 0) return -1;
    state->USub_singleton = PyType_GenericNew((PyTypeObject *)state->USub_type,
                                              NULL, NULL);
    if (!state->USub_singleton) return -1;
    state->_USub_singleton = PyType_GenericNew((PyTypeObject
                                               *)state->_USub_type, NULL, NULL);
    if (!state->_USub_singleton) return -1;
    state->cmpop_type = make_type(state, "cmpop", state->AST_type, NULL, 0,
        "cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn");
    if (!state->cmpop_type) return -1;
    if (add_attributes(state, state->cmpop_type, NULL, 0) < 0) return -1;
    t = PyType_FromSpecWithBases(&_cmpop_type_spec, state->_AST_type);
    state->_cmpop_type = t;
    if (state->_cmpop_type == NULL) return -1;
    state->Eq_type = make_type(state, "Eq", state->cmpop_type, NULL, 0,
        "Eq");
    if (!state->Eq_type) return -1;
    t = PyType_FromSpecWithBases(&_Eq_type_spec, state->_cmpop_type);
    state->_Eq_type = t;
    if (state->_Eq_type == NULL) return -1;
    if (add_fields(state->_Eq_type, NULL, 0) < 0) return -1;
    state->Eq_singleton = PyType_GenericNew((PyTypeObject *)state->Eq_type,
                                            NULL, NULL);
    if (!state->Eq_singleton) return -1;
    state->_Eq_singleton = PyType_GenericNew((PyTypeObject *)state->_Eq_type,
                                             NULL, NULL);
    if (!state->_Eq_singleton) return -1;
    state->NotEq_type = make_type(state, "NotEq", state->cmpop_type, NULL, 0,
        "NotEq");
    if (!state->NotEq_type) return -1;
    t = PyType_FromSpecWithBases(&_NotEq_type_spec, state->_cmpop_type);
    state->_NotEq_type = t;
    if (state->_NotEq_type == NULL) return -1;
    if (add_fields(state->_NotEq_type, NULL, 0) < 0) return -1;
    state->NotEq_singleton = PyType_GenericNew((PyTypeObject
                                               *)state->NotEq_type, NULL, NULL);
    if (!state->NotEq_singleton) return -1;
    state->_NotEq_singleton = PyType_GenericNew((PyTypeObject
                                                *)state->_NotEq_type, NULL,
                                                NULL);
    if (!state->_NotEq_singleton) return -1;
    state->Lt_type = make_type(state, "Lt", state->cmpop_type, NULL, 0,
        "Lt");
    if (!state->Lt_type) return -1;
    t = PyType_FromSpecWithBases(&_Lt_type_spec, state->_cmpop_type);
    state->_Lt_type = t;
    if (state->_Lt_type == NULL) return -1;
    if (add_fields(state->_Lt_type, NULL, 0) < 0) return -1;
    state->Lt_singleton = PyType_GenericNew((PyTypeObject *)state->Lt_type,
                                            NULL, NULL);
    if (!state->Lt_singleton) return -1;
    state->_Lt_singleton = PyType_GenericNew((PyTypeObject *)state->_Lt_type,
                                             NULL, NULL);
    if (!state->_Lt_singleton) return -1;
    state->LtE_type = make_type(state, "LtE", state->cmpop_type, NULL, 0,
        "LtE");
    if (!state->LtE_type) return -1;
    t = PyType_FromSpecWithBases(&_LtE_type_spec, state->_cmpop_type);
    state->_LtE_type = t;
    if (state->_LtE_type == NULL) return -1;
    if (add_fields(state->_LtE_type, NULL, 0) < 0) return -1;
    state->LtE_singleton = PyType_GenericNew((PyTypeObject *)state->LtE_type,
                                             NULL, NULL);
    if (!state->LtE_singleton) return -1;
    state->_LtE_singleton = PyType_GenericNew((PyTypeObject *)state->_LtE_type,
                                              NULL, NULL);
    if (!state->_LtE_singleton) return -1;
    state->Gt_type = make_type(state, "Gt", state->cmpop_type, NULL, 0,
        "Gt");
    if (!state->Gt_type) return -1;
    t = PyType_FromSpecWithBases(&_Gt_type_spec, state->_cmpop_type);
    state->_Gt_type = t;
    if (state->_Gt_type == NULL) return -1;
    if (add_fields(state->_Gt_type, NULL, 0) < 0) return -1;
    state->Gt_singleton = PyType_GenericNew((PyTypeObject *)state->Gt_type,
                                            NULL, NULL);
    if (!state->Gt_singleton) return -1;
    state->_Gt_singleton = PyType_GenericNew((PyTypeObject *)state->_Gt_type,
                                             NULL, NULL);
    if (!state->_Gt_singleton) return -1;
    state->GtE_type = make_type(state, "GtE", state->cmpop_type, NULL, 0,
        "GtE");
    if (!state->GtE_type) return -1;
    t = PyType_FromSpecWithBases(&_GtE_type_spec, state->_cmpop_type);
    state->_GtE_type = t;
    if (state->_GtE_type == NULL) return -1;
    if (add_fields(state->_GtE_type, NULL, 0) < 0) return -1;
    state->GtE_singleton = PyType_GenericNew((PyTypeObject *)state->GtE_type,
                                             NULL, NULL);
    if (!state->GtE_singleton) return -1;
    state->_GtE_singleton = PyType_GenericNew((PyTypeObject *)state->_GtE_type,
                                              NULL, NULL);
    if (!state->_GtE_singleton) return -1;
    state->Is_type = make_type(state, "Is", state->cmpop_type, NULL, 0,
        "Is");
    if (!state->Is_type) return -1;
    t = PyType_FromSpecWithBases(&_Is_type_spec, state->_cmpop_type);
    state->_Is_type = t;
    if (state->_Is_type == NULL) return -1;
    if (add_fields(state->_Is_type, NULL, 0) < 0) return -1;
    state->Is_singleton = PyType_GenericNew((PyTypeObject *)state->Is_type,
                                            NULL, NULL);
    if (!state->Is_singleton) return -1;
    state->_Is_singleton = PyType_GenericNew((PyTypeObject *)state->_Is_type,
                                             NULL, NULL);
    if (!state->_Is_singleton) return -1;
    state->IsNot_type = make_type(state, "IsNot", state->cmpop_type, NULL, 0,
        "IsNot");
    if (!state->IsNot_type) return -1;
    t = PyType_FromSpecWithBases(&_IsNot_type_spec, state->_cmpop_type);
    state->_IsNot_type = t;
    if (state->_IsNot_type == NULL) return -1;
    if (add_fields(state->_IsNot_type, NULL, 0) < 0) return -1;
    state->IsNot_singleton = PyType_GenericNew((PyTypeObject
                                               *)state->IsNot_type, NULL, NULL);
    if (!state->IsNot_singleton) return -1;
    state->_IsNot_singleton = PyType_GenericNew((PyTypeObject
                                                *)state->_IsNot_type, NULL,
                                                NULL);
    if (!state->_IsNot_singleton) return -1;
    state->In_type = make_type(state, "In", state->cmpop_type, NULL, 0,
        "In");
    if (!state->In_type) return -1;
    t = PyType_FromSpecWithBases(&_In_type_spec, state->_cmpop_type);
    state->_In_type = t;
    if (state->_In_type == NULL) return -1;
    if (add_fields(state->_In_type, NULL, 0) < 0) return -1;
    state->In_singleton = PyType_GenericNew((PyTypeObject *)state->In_type,
                                            NULL, NULL);
    if (!state->In_singleton) return -1;
    state->_In_singleton = PyType_GenericNew((PyTypeObject *)state->_In_type,
                                             NULL, NULL);
    if (!state->_In_singleton) return -1;
    state->NotIn_type = make_type(state, "NotIn", state->cmpop_type, NULL, 0,
        "NotIn");
    if (!state->NotIn_type) return -1;
    t = PyType_FromSpecWithBases(&_NotIn_type_spec, state->_cmpop_type);
    state->_NotIn_type = t;
    if (state->_NotIn_type == NULL) return -1;
    if (add_fields(state->_NotIn_type, NULL, 0) < 0) return -1;
    state->NotIn_singleton = PyType_GenericNew((PyTypeObject
                                               *)state->NotIn_type, NULL, NULL);
    if (!state->NotIn_singleton) return -1;
    state->_NotIn_singleton = PyType_GenericNew((PyTypeObject
                                                *)state->_NotIn_type, NULL,
                                                NULL);
    if (!state->_NotIn_singleton) return -1;
    state->comprehension_type = make_type(state, "comprehension",
                                          state->AST_type,
                                          comprehension_fields, 4,
        "comprehension(expr target, expr iter, expr* ifs, int is_async)");
    if (!state->comprehension_type) return -1;
    if (add_attributes(state, state->comprehension_type, NULL, 0) < 0) return
        -1;
    t = PyType_FromSpecWithBases(&_comprehension_type_spec, state->_AST_type);
    state->_comprehension_type = t;
    if (state->_comprehension_type == NULL) return -1;
    if (add_fields(state->_comprehension_type, comprehension_fields, 4) < 0)
        return -1;
    t = PyType_FromSpecWithBases(&_comprehension_seq_type_spec,
                                 state->_AST_type);
    state->_comprehension_seq_type = t;
    if (state->_comprehension_seq_type == NULL) return -1;
    state->excepthandler_type = make_type(state, "excepthandler",
                                          state->AST_type, NULL, 0,
        "excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)");
    if (!state->excepthandler_type) return -1;
    if (add_attributes(state, state->excepthandler_type,
        excepthandler_attributes, 4) < 0) return -1;
    if (PyObject_SetAttr(state->excepthandler_type, state->end_lineno, Py_None)
        == -1)
        return -1;
    if (PyObject_SetAttr(state->excepthandler_type, state->end_col_offset,
        Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_excepthandler_type_spec, state->_AST_type);
    state->_excepthandler_type = t;
    if (state->_excepthandler_type == NULL) return -1;
    if (add_attributes(state, state->_excepthandler_type,
        excepthandler_attributes, 4) < 0) return -1;
    if (PyObject_SetAttr(state->_excepthandler_type, state->end_lineno,
        Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_excepthandler_type, state->end_col_offset,
        Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_excepthandler_seq_type_spec,
                                 state->_AST_type);
    state->_excepthandler_seq_type = t;
    if (state->_excepthandler_seq_type == NULL) return -1;
    state->ExceptHandler_type = make_type(state, "ExceptHandler",
                                          state->excepthandler_type,
                                          ExceptHandler_fields, 3,
        "ExceptHandler(expr? type, identifier? name, stmt* body)");
    if (!state->ExceptHandler_type) return -1;
    if (PyObject_SetAttr(state->ExceptHandler_type, state->type, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->ExceptHandler_type, state->name, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_ExceptHandler_type_spec,
                                 state->_excepthandler_type);
    state->_ExceptHandler_type = t;
    if (state->_ExceptHandler_type == NULL) return -1;
    if (add_fields(state->_ExceptHandler_type, ExceptHandler_fields, 3) < 0)
        return -1;
    if (PyObject_SetAttr(state->_ExceptHandler_type, state->type, Py_None) ==
        -1)
        return -1;
    if (PyObject_SetAttr(state->_ExceptHandler_type, state->name, Py_None) ==
        -1)
        return -1;
    state->arguments_type = make_type(state, "arguments", state->AST_type,
                                      arguments_fields, 7,
        "arguments(arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs, expr* kw_defaults, arg? kwarg, expr* defaults)");
    if (!state->arguments_type) return -1;
    if (add_attributes(state, state->arguments_type, NULL, 0) < 0) return -1;
    if (PyObject_SetAttr(state->arguments_type, state->vararg, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->arguments_type, state->kwarg, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_arguments_type_spec, state->_AST_type);
    state->_arguments_type = t;
    if (state->_arguments_type == NULL) return -1;
    if (add_fields(state->_arguments_type, arguments_fields, 7) < 0) return -1;
    if (PyObject_SetAttr(state->_arguments_type, state->vararg, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_arguments_type, state->kwarg, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_arguments_seq_type_spec, state->_AST_type);
    state->_arguments_seq_type = t;
    if (state->_arguments_seq_type == NULL) return -1;
    state->arg_type = make_type(state, "arg", state->AST_type, arg_fields, 3,
        "arg(identifier arg, expr? annotation, string? type_comment)");
    if (!state->arg_type) return -1;
    if (add_attributes(state, state->arg_type, arg_attributes, 4) < 0) return
        -1;
    if (PyObject_SetAttr(state->arg_type, state->annotation, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->arg_type, state->type_comment, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->arg_type, state->end_lineno, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->arg_type, state->end_col_offset, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_arg_type_spec, state->_AST_type);
    state->_arg_type = t;
    if (state->_arg_type == NULL) return -1;
    if (add_fields(state->_arg_type, arg_fields, 3) < 0) return -1;
    if (add_attributes(state, state->_arg_type, arg_attributes, 4) < 0) return
        -1;
    if (PyObject_SetAttr(state->_arg_type, state->annotation, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_arg_type, state->type_comment, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_arg_type, state->end_lineno, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_arg_type, state->end_col_offset, Py_None) ==
        -1)
        return -1;
    t = PyType_FromSpecWithBases(&_arg_seq_type_spec, state->_AST_type);
    state->_arg_seq_type = t;
    if (state->_arg_seq_type == NULL) return -1;
    state->keyword_type = make_type(state, "keyword", state->AST_type,
                                    keyword_fields, 2,
        "keyword(identifier? arg, expr value)");
    if (!state->keyword_type) return -1;
    if (add_attributes(state, state->keyword_type, keyword_attributes, 4) < 0)
        return -1;
    if (PyObject_SetAttr(state->keyword_type, state->arg, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->keyword_type, state->end_lineno, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->keyword_type, state->end_col_offset, Py_None)
        == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_keyword_type_spec, state->_AST_type);
    state->_keyword_type = t;
    if (state->_keyword_type == NULL) return -1;
    if (add_fields(state->_keyword_type, keyword_fields, 2) < 0) return -1;
    if (add_attributes(state, state->_keyword_type, keyword_attributes, 4) < 0)
        return -1;
    if (PyObject_SetAttr(state->_keyword_type, state->arg, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_keyword_type, state->end_lineno, Py_None) ==
        -1)
        return -1;
    if (PyObject_SetAttr(state->_keyword_type, state->end_col_offset, Py_None)
        == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_keyword_seq_type_spec, state->_AST_type);
    state->_keyword_seq_type = t;
    if (state->_keyword_seq_type == NULL) return -1;
    state->alias_type = make_type(state, "alias", state->AST_type,
                                  alias_fields, 2,
        "alias(identifier name, identifier? asname)");
    if (!state->alias_type) return -1;
    if (add_attributes(state, state->alias_type, alias_attributes, 4) < 0)
        return -1;
    if (PyObject_SetAttr(state->alias_type, state->asname, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->alias_type, state->end_lineno, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->alias_type, state->end_col_offset, Py_None) ==
        -1)
        return -1;
    t = PyType_FromSpecWithBases(&_alias_type_spec, state->_AST_type);
    state->_alias_type = t;
    if (state->_alias_type == NULL) return -1;
    if (add_fields(state->_alias_type, alias_fields, 2) < 0) return -1;
    if (add_attributes(state, state->_alias_type, alias_attributes, 4) < 0)
        return -1;
    if (PyObject_SetAttr(state->_alias_type, state->asname, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_alias_type, state->end_lineno, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_alias_type, state->end_col_offset, Py_None) ==
        -1)
        return -1;
    t = PyType_FromSpecWithBases(&_alias_seq_type_spec, state->_AST_type);
    state->_alias_seq_type = t;
    if (state->_alias_seq_type == NULL) return -1;
    state->withitem_type = make_type(state, "withitem", state->AST_type,
                                     withitem_fields, 2,
        "withitem(expr context_expr, expr? optional_vars)");
    if (!state->withitem_type) return -1;
    if (add_attributes(state, state->withitem_type, NULL, 0) < 0) return -1;
    if (PyObject_SetAttr(state->withitem_type, state->optional_vars, Py_None)
        == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_withitem_type_spec, state->_AST_type);
    state->_withitem_type = t;
    if (state->_withitem_type == NULL) return -1;
    if (add_fields(state->_withitem_type, withitem_fields, 2) < 0) return -1;
    if (PyObject_SetAttr(state->_withitem_type, state->optional_vars, Py_None)
        == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_withitem_seq_type_spec, state->_AST_type);
    state->_withitem_seq_type = t;
    if (state->_withitem_seq_type == NULL) return -1;
    state->match_case_type = make_type(state, "match_case", state->AST_type,
                                       match_case_fields, 3,
        "match_case(pattern pattern, expr? guard, stmt* body)");
    if (!state->match_case_type) return -1;
    if (add_attributes(state, state->match_case_type, NULL, 0) < 0) return -1;
    if (PyObject_SetAttr(state->match_case_type, state->guard, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_match_case_type_spec, state->_AST_type);
    state->_match_case_type = t;
    if (state->_match_case_type == NULL) return -1;
    if (add_fields(state->_match_case_type, match_case_fields, 3) < 0) return
        -1;
    if (PyObject_SetAttr(state->_match_case_type, state->guard, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_match_case_seq_type_spec, state->_AST_type);
    state->_match_case_seq_type = t;
    if (state->_match_case_seq_type == NULL) return -1;
    state->pattern_type = make_type(state, "pattern", state->AST_type, NULL, 0,
        "pattern = MatchValue(expr value)\n"
        "        | MatchSingleton(constant value)\n"
        "        | MatchSequence(pattern* patterns)\n"
        "        | MatchMapping(expr* keys, pattern* patterns, identifier? rest)\n"
        "        | MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, pattern* kwd_patterns)\n"
        "        | MatchStar(identifier? name)\n"
        "        | MatchAs(pattern? pattern, identifier? name)\n"
        "        | MatchOr(pattern* patterns)");
    if (!state->pattern_type) return -1;
    if (add_attributes(state, state->pattern_type, pattern_attributes, 4) < 0)
        return -1;
    t = PyType_FromSpecWithBases(&_pattern_type_spec, state->_AST_type);
    state->_pattern_type = t;
    if (state->_pattern_type == NULL) return -1;
    if (add_attributes(state, state->_pattern_type, pattern_attributes, 4) < 0)
        return -1;
    t = PyType_FromSpecWithBases(&_pattern_seq_type_spec, state->_AST_type);
    state->_pattern_seq_type = t;
    if (state->_pattern_seq_type == NULL) return -1;
    state->MatchValue_type = make_type(state, "MatchValue",
                                       state->pattern_type, MatchValue_fields,
                                       1,
        "MatchValue(expr value)");
    if (!state->MatchValue_type) return -1;
    t = PyType_FromSpecWithBases(&_MatchValue_type_spec, state->_pattern_type);
    state->_MatchValue_type = t;
    if (state->_MatchValue_type == NULL) return -1;
    if (add_fields(state->_MatchValue_type, MatchValue_fields, 1) < 0) return
        -1;
    state->MatchSingleton_type = make_type(state, "MatchSingleton",
                                           state->pattern_type,
                                           MatchSingleton_fields, 1,
        "MatchSingleton(constant value)");
    if (!state->MatchSingleton_type) return -1;
    t = PyType_FromSpecWithBases(&_MatchSingleton_type_spec,
                                 state->_pattern_type);
    state->_MatchSingleton_type = t;
    if (state->_MatchSingleton_type == NULL) return -1;
    if (add_fields(state->_MatchSingleton_type, MatchSingleton_fields, 1) < 0)
        return -1;
    state->MatchSequence_type = make_type(state, "MatchSequence",
                                          state->pattern_type,
                                          MatchSequence_fields, 1,
        "MatchSequence(pattern* patterns)");
    if (!state->MatchSequence_type) return -1;
    t = PyType_FromSpecWithBases(&_MatchSequence_type_spec,
                                 state->_pattern_type);
    state->_MatchSequence_type = t;
    if (state->_MatchSequence_type == NULL) return -1;
    if (add_fields(state->_MatchSequence_type, MatchSequence_fields, 1) < 0)
        return -1;
    state->MatchMapping_type = make_type(state, "MatchMapping",
                                         state->pattern_type,
                                         MatchMapping_fields, 3,
        "MatchMapping(expr* keys, pattern* patterns, identifier? rest)");
    if (!state->MatchMapping_type) return -1;
    if (PyObject_SetAttr(state->MatchMapping_type, state->rest, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_MatchMapping_type_spec,
                                 state->_pattern_type);
    state->_MatchMapping_type = t;
    if (state->_MatchMapping_type == NULL) return -1;
    if (add_fields(state->_MatchMapping_type, MatchMapping_fields, 3) < 0)
        return -1;
    if (PyObject_SetAttr(state->_MatchMapping_type, state->rest, Py_None) == -1)
        return -1;
    state->MatchClass_type = make_type(state, "MatchClass",
                                       state->pattern_type, MatchClass_fields,
                                       4,
        "MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, pattern* kwd_patterns)");
    if (!state->MatchClass_type) return -1;
    t = PyType_FromSpecWithBases(&_MatchClass_type_spec, state->_pattern_type);
    state->_MatchClass_type = t;
    if (state->_MatchClass_type == NULL) return -1;
    if (add_fields(state->_MatchClass_type, MatchClass_fields, 4) < 0) return
        -1;
    state->MatchStar_type = make_type(state, "MatchStar", state->pattern_type,
                                      MatchStar_fields, 1,
        "MatchStar(identifier? name)");
    if (!state->MatchStar_type) return -1;
    if (PyObject_SetAttr(state->MatchStar_type, state->name, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_MatchStar_type_spec, state->_pattern_type);
    state->_MatchStar_type = t;
    if (state->_MatchStar_type == NULL) return -1;
    if (add_fields(state->_MatchStar_type, MatchStar_fields, 1) < 0) return -1;
    if (PyObject_SetAttr(state->_MatchStar_type, state->name, Py_None) == -1)
        return -1;
    state->MatchAs_type = make_type(state, "MatchAs", state->pattern_type,
                                    MatchAs_fields, 2,
        "MatchAs(pattern? pattern, identifier? name)");
    if (!state->MatchAs_type) return -1;
    if (PyObject_SetAttr(state->MatchAs_type, state->pattern, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->MatchAs_type, state->name, Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_MatchAs_type_spec, state->_pattern_type);
    state->_MatchAs_type = t;
    if (state->_MatchAs_type == NULL) return -1;
    if (add_fields(state->_MatchAs_type, MatchAs_fields, 2) < 0) return -1;
    if (PyObject_SetAttr(state->_MatchAs_type, state->pattern, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_MatchAs_type, state->name, Py_None) == -1)
        return -1;
    state->MatchOr_type = make_type(state, "MatchOr", state->pattern_type,
                                    MatchOr_fields, 1,
        "MatchOr(pattern* patterns)");
    if (!state->MatchOr_type) return -1;
    t = PyType_FromSpecWithBases(&_MatchOr_type_spec, state->_pattern_type);
    state->_MatchOr_type = t;
    if (state->_MatchOr_type == NULL) return -1;
    if (add_fields(state->_MatchOr_type, MatchOr_fields, 1) < 0) return -1;
    state->type_ignore_type = make_type(state, "type_ignore", state->AST_type,
                                        NULL, 0,
        "type_ignore = TypeIgnore(int lineno, string tag)");
    if (!state->type_ignore_type) return -1;
    if (add_attributes(state, state->type_ignore_type, NULL, 0) < 0) return -1;
    t = PyType_FromSpecWithBases(&_type_ignore_type_spec, state->_AST_type);
    state->_type_ignore_type = t;
    if (state->_type_ignore_type == NULL) return -1;
    t = PyType_FromSpecWithBases(&_type_ignore_seq_type_spec, state->_AST_type);
    state->_type_ignore_seq_type = t;
    if (state->_type_ignore_seq_type == NULL) return -1;
    state->TypeIgnore_type = make_type(state, "TypeIgnore",
                                       state->type_ignore_type,
                                       TypeIgnore_fields, 2,
        "TypeIgnore(int lineno, string tag)");
    if (!state->TypeIgnore_type) return -1;
    t = PyType_FromSpecWithBases(&_TypeIgnore_type_spec,
                                 state->_type_ignore_type);
    state->_TypeIgnore_type = t;
    if (state->_TypeIgnore_type == NULL) return -1;
    if (add_fields(state->_TypeIgnore_type, TypeIgnore_fields, 2) < 0) return
        -1;
    state->type_param_type = make_type(state, "type_param", state->AST_type,
                                       NULL, 0,
        "type_param = TypeVar(identifier name, expr? bound, expr? default_value)\n"
        "           | ParamSpec(identifier name, expr? default_value)\n"
        "           | TypeVarTuple(identifier name, expr? default_value)");
    if (!state->type_param_type) return -1;
    if (add_attributes(state, state->type_param_type, type_param_attributes, 4)
        < 0) return -1;
    t = PyType_FromSpecWithBases(&_type_param_type_spec, state->_AST_type);
    state->_type_param_type = t;
    if (state->_type_param_type == NULL) return -1;
    if (add_attributes(state, state->_type_param_type, type_param_attributes,
        4) < 0) return -1;
    t = PyType_FromSpecWithBases(&_type_param_seq_type_spec, state->_AST_type);
    state->_type_param_seq_type = t;
    if (state->_type_param_seq_type == NULL) return -1;
    state->TypeVar_type = make_type(state, "TypeVar", state->type_param_type,
                                    TypeVar_fields, 3,
        "TypeVar(identifier name, expr? bound, expr? default_value)");
    if (!state->TypeVar_type) return -1;
    if (PyObject_SetAttr(state->TypeVar_type, state->bound, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->TypeVar_type, state->default_value, Py_None) ==
        -1)
        return -1;
    t = PyType_FromSpecWithBases(&_TypeVar_type_spec, state->_type_param_type);
    state->_TypeVar_type = t;
    if (state->_TypeVar_type == NULL) return -1;
    if (add_fields(state->_TypeVar_type, TypeVar_fields, 3) < 0) return -1;
    if (PyObject_SetAttr(state->_TypeVar_type, state->bound, Py_None) == -1)
        return -1;
    if (PyObject_SetAttr(state->_TypeVar_type, state->default_value, Py_None)
        == -1)
        return -1;
    state->ParamSpec_type = make_type(state, "ParamSpec",
                                      state->type_param_type, ParamSpec_fields,
                                      2,
        "ParamSpec(identifier name, expr? default_value)");
    if (!state->ParamSpec_type) return -1;
    if (PyObject_SetAttr(state->ParamSpec_type, state->default_value, Py_None)
        == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_ParamSpec_type_spec,
                                 state->_type_param_type);
    state->_ParamSpec_type = t;
    if (state->_ParamSpec_type == NULL) return -1;
    if (add_fields(state->_ParamSpec_type, ParamSpec_fields, 2) < 0) return -1;
    if (PyObject_SetAttr(state->_ParamSpec_type, state->default_value, Py_None)
        == -1)
        return -1;
    state->TypeVarTuple_type = make_type(state, "TypeVarTuple",
                                         state->type_param_type,
                                         TypeVarTuple_fields, 2,
        "TypeVarTuple(identifier name, expr? default_value)");
    if (!state->TypeVarTuple_type) return -1;
    if (PyObject_SetAttr(state->TypeVarTuple_type, state->default_value,
        Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_TypeVarTuple_type_spec,
                                 state->_type_param_type);
    state->_TypeVarTuple_type = t;
    if (state->_TypeVarTuple_type == NULL) return -1;
    if (add_fields(state->_TypeVarTuple_type, TypeVarTuple_fields, 2) < 0)
        return -1;
    if (PyObject_SetAttr(state->_TypeVarTuple_type, state->default_value,
        Py_None) == -1)
        return -1;
    t = PyType_FromSpecWithBases(&_int_seq_type_spec, state->_AST_type);
    state->_int_seq_type = t;
    if (state->_int_seq_type == NULL) return -1;
    t = PyType_FromSpecWithBases(&_identifier_seq_type_spec, state->_AST_type);
    state->_identifier_seq_type = t;
    if (state->_identifier_seq_type == NULL) return -1;

    if (!add_ast_annotations(state)) {
        return -1;
    }
    return 0;
}

mod_ty
_PyAST_Module(asdl_stmt_seq * body, asdl_type_ignore_seq * type_ignores,
              PyArena *arena)
{
    mod_ty p;
    p = (mod_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Module_kind;
    p->v.Module.body = body;
    p->v.Module.type_ignores = type_ignores;
    return p;
}

mod_ty
_PyAST_Interactive(asdl_stmt_seq * body, PyArena *arena)
{
    mod_ty p;
    p = (mod_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Interactive_kind;
    p->v.Interactive.body = body;
    return p;
}

mod_ty
_PyAST_Expression(expr_ty body, PyArena *arena)
{
    mod_ty p;
    if (!body) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'body' is required for Expression");
        return NULL;
    }
    p = (mod_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Expression_kind;
    p->v.Expression.body = body;
    return p;
}

mod_ty
_PyAST_FunctionType(asdl_expr_seq * argtypes, expr_ty returns, PyArena *arena)
{
    mod_ty p;
    if (!returns) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'returns' is required for FunctionType");
        return NULL;
    }
    p = (mod_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = FunctionType_kind;
    p->v.FunctionType.argtypes = argtypes;
    p->v.FunctionType.returns = returns;
    return p;
}

stmt_ty
_PyAST_FunctionDef(identifier name, arguments_ty args, asdl_stmt_seq * body,
                   asdl_expr_seq * decorator_list, expr_ty returns, string
                   type_comment, asdl_type_param_seq * type_params, int lineno,
                   int col_offset, int end_lineno, int end_col_offset, PyArena
                   *arena)
{
    stmt_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for FunctionDef");
        return NULL;
    }
    if (!args) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'args' is required for FunctionDef");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = FunctionDef_kind;
    p->v.FunctionDef.name = name;
    p->v.FunctionDef.args = args;
    p->v.FunctionDef.body = body;
    p->v.FunctionDef.decorator_list = decorator_list;
    p->v.FunctionDef.returns = returns;
    p->v.FunctionDef.type_comment = type_comment;
    p->v.FunctionDef.type_params = type_params;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_AsyncFunctionDef(identifier name, arguments_ty args, asdl_stmt_seq *
                        body, asdl_expr_seq * decorator_list, expr_ty returns,
                        string type_comment, asdl_type_param_seq * type_params,
                        int lineno, int col_offset, int end_lineno, int
                        end_col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for AsyncFunctionDef");
        return NULL;
    }
    if (!args) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'args' is required for AsyncFunctionDef");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = AsyncFunctionDef_kind;
    p->v.AsyncFunctionDef.name = name;
    p->v.AsyncFunctionDef.args = args;
    p->v.AsyncFunctionDef.body = body;
    p->v.AsyncFunctionDef.decorator_list = decorator_list;
    p->v.AsyncFunctionDef.returns = returns;
    p->v.AsyncFunctionDef.type_comment = type_comment;
    p->v.AsyncFunctionDef.type_params = type_params;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_ClassDef(identifier name, asdl_expr_seq * bases, asdl_keyword_seq *
                keywords, asdl_stmt_seq * body, asdl_expr_seq * decorator_list,
                asdl_type_param_seq * type_params, int lineno, int col_offset,
                int end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for ClassDef");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = ClassDef_kind;
    p->v.ClassDef.name = name;
    p->v.ClassDef.bases = bases;
    p->v.ClassDef.keywords = keywords;
    p->v.ClassDef.body = body;
    p->v.ClassDef.decorator_list = decorator_list;
    p->v.ClassDef.type_params = type_params;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Return(expr_ty value, int lineno, int col_offset, int end_lineno, int
              end_col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Return_kind;
    p->v.Return.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Delete(asdl_expr_seq * targets, int lineno, int col_offset, int
              end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Delete_kind;
    p->v.Delete.targets = targets;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Assign(asdl_expr_seq * targets, expr_ty value, string type_comment, int
              lineno, int col_offset, int end_lineno, int end_col_offset,
              PyArena *arena)
{
    stmt_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Assign");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Assign_kind;
    p->v.Assign.targets = targets;
    p->v.Assign.value = value;
    p->v.Assign.type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_TypeAlias(expr_ty name, asdl_type_param_seq * type_params, expr_ty
                 value, int lineno, int col_offset, int end_lineno, int
                 end_col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for TypeAlias");
        return NULL;
    }
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for TypeAlias");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = TypeAlias_kind;
    p->v.TypeAlias.name = name;
    p->v.TypeAlias.type_params = type_params;
    p->v.TypeAlias.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_AugAssign(expr_ty target, operator_ty op, expr_ty value, int lineno, int
                 col_offset, int end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'target' is required for AugAssign");
        return NULL;
    }
    if (!op) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'op' is required for AugAssign");
        return NULL;
    }
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for AugAssign");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = AugAssign_kind;
    p->v.AugAssign.target = target;
    p->v.AugAssign.op = op;
    p->v.AugAssign.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_AnnAssign(expr_ty target, expr_ty annotation, expr_ty value, int simple,
                 int lineno, int col_offset, int end_lineno, int
                 end_col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'target' is required for AnnAssign");
        return NULL;
    }
    if (!annotation) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'annotation' is required for AnnAssign");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = AnnAssign_kind;
    p->v.AnnAssign.target = target;
    p->v.AnnAssign.annotation = annotation;
    p->v.AnnAssign.value = value;
    p->v.AnnAssign.simple = simple;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_For(expr_ty target, expr_ty iter, asdl_stmt_seq * body, asdl_stmt_seq *
           orelse, string type_comment, int lineno, int col_offset, int
           end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'target' is required for For");
        return NULL;
    }
    if (!iter) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'iter' is required for For");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = For_kind;
    p->v.For.target = target;
    p->v.For.iter = iter;
    p->v.For.body = body;
    p->v.For.orelse = orelse;
    p->v.For.type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_AsyncFor(expr_ty target, expr_ty iter, asdl_stmt_seq * body,
                asdl_stmt_seq * orelse, string type_comment, int lineno, int
                col_offset, int end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'target' is required for AsyncFor");
        return NULL;
    }
    if (!iter) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'iter' is required for AsyncFor");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = AsyncFor_kind;
    p->v.AsyncFor.target = target;
    p->v.AsyncFor.iter = iter;
    p->v.AsyncFor.body = body;
    p->v.AsyncFor.orelse = orelse;
    p->v.AsyncFor.type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_While(expr_ty test, asdl_stmt_seq * body, asdl_stmt_seq * orelse, int
             lineno, int col_offset, int end_lineno, int end_col_offset,
             PyArena *arena)
{
    stmt_ty p;
    if (!test) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'test' is required for While");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = While_kind;
    p->v.While.test = test;
    p->v.While.body = body;
    p->v.While.orelse = orelse;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_If(expr_ty test, asdl_stmt_seq * body, asdl_stmt_seq * orelse, int
          lineno, int col_offset, int end_lineno, int end_col_offset, PyArena
          *arena)
{
    stmt_ty p;
    if (!test) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'test' is required for If");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = If_kind;
    p->v.If.test = test;
    p->v.If.body = body;
    p->v.If.orelse = orelse;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_With(asdl_withitem_seq * items, asdl_stmt_seq * body, string
            type_comment, int lineno, int col_offset, int end_lineno, int
            end_col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = With_kind;
    p->v.With.items = items;
    p->v.With.body = body;
    p->v.With.type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_AsyncWith(asdl_withitem_seq * items, asdl_stmt_seq * body, string
                 type_comment, int lineno, int col_offset, int end_lineno, int
                 end_col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = AsyncWith_kind;
    p->v.AsyncWith.items = items;
    p->v.AsyncWith.body = body;
    p->v.AsyncWith.type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Match(expr_ty subject, asdl_match_case_seq * cases, int lineno, int
             col_offset, int end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!subject) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'subject' is required for Match");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Match_kind;
    p->v.Match.subject = subject;
    p->v.Match.cases = cases;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Raise(expr_ty exc, expr_ty cause, int lineno, int col_offset, int
             end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Raise_kind;
    p->v.Raise.exc = exc;
    p->v.Raise.cause = cause;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Try(asdl_stmt_seq * body, asdl_excepthandler_seq * handlers,
           asdl_stmt_seq * orelse, asdl_stmt_seq * finalbody, int lineno, int
           col_offset, int end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Try_kind;
    p->v.Try.body = body;
    p->v.Try.handlers = handlers;
    p->v.Try.orelse = orelse;
    p->v.Try.finalbody = finalbody;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_TryStar(asdl_stmt_seq * body, asdl_excepthandler_seq * handlers,
               asdl_stmt_seq * orelse, asdl_stmt_seq * finalbody, int lineno,
               int col_offset, int end_lineno, int end_col_offset, PyArena
               *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = TryStar_kind;
    p->v.TryStar.body = body;
    p->v.TryStar.handlers = handlers;
    p->v.TryStar.orelse = orelse;
    p->v.TryStar.finalbody = finalbody;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Assert(expr_ty test, expr_ty msg, int lineno, int col_offset, int
              end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!test) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'test' is required for Assert");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Assert_kind;
    p->v.Assert.test = test;
    p->v.Assert.msg = msg;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Import(asdl_alias_seq * names, int lineno, int col_offset, int
              end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Import_kind;
    p->v.Import.names = names;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_ImportFrom(identifier module, asdl_alias_seq * names, int level, int
                  lineno, int col_offset, int end_lineno, int end_col_offset,
                  PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = ImportFrom_kind;
    p->v.ImportFrom.module = module;
    p->v.ImportFrom.names = names;
    p->v.ImportFrom.level = level;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Global(asdl_identifier_seq * names, int lineno, int col_offset, int
              end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Global_kind;
    p->v.Global.names = names;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Nonlocal(asdl_identifier_seq * names, int lineno, int col_offset, int
                end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Nonlocal_kind;
    p->v.Nonlocal.names = names;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Expr(expr_ty value, int lineno, int col_offset, int end_lineno, int
            end_col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Expr");
        return NULL;
    }
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Expr_kind;
    p->v.Expr.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Pass(int lineno, int col_offset, int end_lineno, int end_col_offset,
            PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Pass_kind;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Break(int lineno, int col_offset, int end_lineno, int end_col_offset,
             PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Break_kind;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_Continue(int lineno, int col_offset, int end_lineno, int end_col_offset,
                PyArena *arena)
{
    stmt_ty p;
    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Continue_kind;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_BoolOp(boolop_ty op, asdl_expr_seq * values, int lineno, int col_offset,
              int end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!op) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'op' is required for BoolOp");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = BoolOp_kind;
    p->v.BoolOp.op = op;
    p->v.BoolOp.values = values;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_NamedExpr(expr_ty target, expr_ty value, int lineno, int col_offset, int
                 end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'target' is required for NamedExpr");
        return NULL;
    }
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for NamedExpr");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = NamedExpr_kind;
    p->v.NamedExpr.target = target;
    p->v.NamedExpr.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_BinOp(expr_ty left, operator_ty op, expr_ty right, int lineno, int
             col_offset, int end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!left) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'left' is required for BinOp");
        return NULL;
    }
    if (!op) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'op' is required for BinOp");
        return NULL;
    }
    if (!right) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'right' is required for BinOp");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = BinOp_kind;
    p->v.BinOp.left = left;
    p->v.BinOp.op = op;
    p->v.BinOp.right = right;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_UnaryOp(unaryop_ty op, expr_ty operand, int lineno, int col_offset, int
               end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!op) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'op' is required for UnaryOp");
        return NULL;
    }
    if (!operand) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'operand' is required for UnaryOp");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = UnaryOp_kind;
    p->v.UnaryOp.op = op;
    p->v.UnaryOp.operand = operand;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Lambda(arguments_ty args, expr_ty body, int lineno, int col_offset, int
              end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!args) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'args' is required for Lambda");
        return NULL;
    }
    if (!body) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'body' is required for Lambda");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Lambda_kind;
    p->v.Lambda.args = args;
    p->v.Lambda.body = body;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_IfExp(expr_ty test, expr_ty body, expr_ty orelse, int lineno, int
             col_offset, int end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!test) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'test' is required for IfExp");
        return NULL;
    }
    if (!body) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'body' is required for IfExp");
        return NULL;
    }
    if (!orelse) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'orelse' is required for IfExp");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = IfExp_kind;
    p->v.IfExp.test = test;
    p->v.IfExp.body = body;
    p->v.IfExp.orelse = orelse;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Dict(asdl_expr_seq * keys, asdl_expr_seq * values, int lineno, int
            col_offset, int end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Dict_kind;
    p->v.Dict.keys = keys;
    p->v.Dict.values = values;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Set(asdl_expr_seq * elts, int lineno, int col_offset, int end_lineno,
           int end_col_offset, PyArena *arena)
{
    expr_ty p;
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Set_kind;
    p->v.Set.elts = elts;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_ListComp(expr_ty elt, asdl_comprehension_seq * generators, int lineno,
                int col_offset, int end_lineno, int end_col_offset, PyArena
                *arena)
{
    expr_ty p;
    if (!elt) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'elt' is required for ListComp");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = ListComp_kind;
    p->v.ListComp.elt = elt;
    p->v.ListComp.generators = generators;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_SetComp(expr_ty elt, asdl_comprehension_seq * generators, int lineno,
               int col_offset, int end_lineno, int end_col_offset, PyArena
               *arena)
{
    expr_ty p;
    if (!elt) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'elt' is required for SetComp");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = SetComp_kind;
    p->v.SetComp.elt = elt;
    p->v.SetComp.generators = generators;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_DictComp(expr_ty key, expr_ty value, asdl_comprehension_seq *
                generators, int lineno, int col_offset, int end_lineno, int
                end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!key) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'key' is required for DictComp");
        return NULL;
    }
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for DictComp");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = DictComp_kind;
    p->v.DictComp.key = key;
    p->v.DictComp.value = value;
    p->v.DictComp.generators = generators;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_GeneratorExp(expr_ty elt, asdl_comprehension_seq * generators, int
                    lineno, int col_offset, int end_lineno, int end_col_offset,
                    PyArena *arena)
{
    expr_ty p;
    if (!elt) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'elt' is required for GeneratorExp");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = GeneratorExp_kind;
    p->v.GeneratorExp.elt = elt;
    p->v.GeneratorExp.generators = generators;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Await(expr_ty value, int lineno, int col_offset, int end_lineno, int
             end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Await");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Await_kind;
    p->v.Await.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Yield(expr_ty value, int lineno, int col_offset, int end_lineno, int
             end_col_offset, PyArena *arena)
{
    expr_ty p;
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Yield_kind;
    p->v.Yield.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_YieldFrom(expr_ty value, int lineno, int col_offset, int end_lineno, int
                 end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for YieldFrom");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = YieldFrom_kind;
    p->v.YieldFrom.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Compare(expr_ty left, asdl_int_seq * ops, asdl_expr_seq * comparators,
               int lineno, int col_offset, int end_lineno, int end_col_offset,
               PyArena *arena)
{
    expr_ty p;
    if (!left) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'left' is required for Compare");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Compare_kind;
    p->v.Compare.left = left;
    p->v.Compare.ops = ops;
    p->v.Compare.comparators = comparators;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Call(expr_ty func, asdl_expr_seq * args, asdl_keyword_seq * keywords,
            int lineno, int col_offset, int end_lineno, int end_col_offset,
            PyArena *arena)
{
    expr_ty p;
    if (!func) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'func' is required for Call");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Call_kind;
    p->v.Call.func = func;
    p->v.Call.args = args;
    p->v.Call.keywords = keywords;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_FormattedValue(expr_ty value, int conversion, expr_ty format_spec, int
                      lineno, int col_offset, int end_lineno, int
                      end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for FormattedValue");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = FormattedValue_kind;
    p->v.FormattedValue.value = value;
    p->v.FormattedValue.conversion = conversion;
    p->v.FormattedValue.format_spec = format_spec;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Interpolation(expr_ty value, constant str, int conversion, expr_ty
                     format_spec, int lineno, int col_offset, int end_lineno,
                     int end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Interpolation");
        return NULL;
    }
    if (!str) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'str' is required for Interpolation");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Interpolation_kind;
    p->v.Interpolation.value = value;
    p->v.Interpolation.str = str;
    p->v.Interpolation.conversion = conversion;
    p->v.Interpolation.format_spec = format_spec;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_JoinedStr(asdl_expr_seq * values, int lineno, int col_offset, int
                 end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = JoinedStr_kind;
    p->v.JoinedStr.values = values;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_TemplateStr(asdl_expr_seq * values, int lineno, int col_offset, int
                   end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = TemplateStr_kind;
    p->v.TemplateStr.values = values;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Constant(constant value, string kind, int lineno, int col_offset, int
                end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Constant");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Constant_kind;
    p->v.Constant.value = value;
    p->v.Constant.kind = kind;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Attribute(expr_ty value, identifier attr, expr_context_ty ctx, int
                 lineno, int col_offset, int end_lineno, int end_col_offset,
                 PyArena *arena)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Attribute");
        return NULL;
    }
    if (!attr) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'attr' is required for Attribute");
        return NULL;
    }
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'ctx' is required for Attribute");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Attribute_kind;
    p->v.Attribute.value = value;
    p->v.Attribute.attr = attr;
    p->v.Attribute.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Subscript(expr_ty value, expr_ty slice, expr_context_ty ctx, int lineno,
                 int col_offset, int end_lineno, int end_col_offset, PyArena
                 *arena)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Subscript");
        return NULL;
    }
    if (!slice) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'slice' is required for Subscript");
        return NULL;
    }
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'ctx' is required for Subscript");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Subscript_kind;
    p->v.Subscript.value = value;
    p->v.Subscript.slice = slice;
    p->v.Subscript.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Starred(expr_ty value, expr_context_ty ctx, int lineno, int col_offset,
               int end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Starred");
        return NULL;
    }
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'ctx' is required for Starred");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Starred_kind;
    p->v.Starred.value = value;
    p->v.Starred.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Name(identifier id, expr_context_ty ctx, int lineno, int col_offset, int
            end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!id) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'id' is required for Name");
        return NULL;
    }
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'ctx' is required for Name");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Name_kind;
    p->v.Name.id = id;
    p->v.Name.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_List(asdl_expr_seq * elts, expr_context_ty ctx, int lineno, int
            col_offset, int end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'ctx' is required for List");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = List_kind;
    p->v.List.elts = elts;
    p->v.List.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Tuple(asdl_expr_seq * elts, expr_context_ty ctx, int lineno, int
             col_offset, int end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'ctx' is required for Tuple");
        return NULL;
    }
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Tuple_kind;
    p->v.Tuple.elts = elts;
    p->v.Tuple.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_Slice(expr_ty lower, expr_ty upper, expr_ty step, int lineno, int
             col_offset, int end_lineno, int end_col_offset, PyArena *arena)
{
    expr_ty p;
    p = (expr_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Slice_kind;
    p->v.Slice.lower = lower;
    p->v.Slice.upper = upper;
    p->v.Slice.step = step;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

comprehension_ty
_PyAST_comprehension(expr_ty target, expr_ty iter, asdl_expr_seq * ifs, int
                     is_async, PyArena *arena)
{
    comprehension_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'target' is required for comprehension");
        return NULL;
    }
    if (!iter) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'iter' is required for comprehension");
        return NULL;
    }
    p = (comprehension_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->target = target;
    p->iter = iter;
    p->ifs = ifs;
    p->is_async = is_async;
    return p;
}

excepthandler_ty
_PyAST_ExceptHandler(expr_ty type, identifier name, asdl_stmt_seq * body, int
                     lineno, int col_offset, int end_lineno, int
                     end_col_offset, PyArena *arena)
{
    excepthandler_ty p;
    p = (excepthandler_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = ExceptHandler_kind;
    p->v.ExceptHandler.type = type;
    p->v.ExceptHandler.name = name;
    p->v.ExceptHandler.body = body;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

arguments_ty
_PyAST_arguments(asdl_arg_seq * posonlyargs, asdl_arg_seq * args, arg_ty
                 vararg, asdl_arg_seq * kwonlyargs, asdl_expr_seq *
                 kw_defaults, arg_ty kwarg, asdl_expr_seq * defaults, PyArena
                 *arena)
{
    arguments_ty p;
    p = (arguments_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->posonlyargs = posonlyargs;
    p->args = args;
    p->vararg = vararg;
    p->kwonlyargs = kwonlyargs;
    p->kw_defaults = kw_defaults;
    p->kwarg = kwarg;
    p->defaults = defaults;
    return p;
}

arg_ty
_PyAST_arg(identifier arg, expr_ty annotation, string type_comment, int lineno,
           int col_offset, int end_lineno, int end_col_offset, PyArena *arena)
{
    arg_ty p;
    if (!arg) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'arg' is required for arg");
        return NULL;
    }
    p = (arg_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->arg = arg;
    p->annotation = annotation;
    p->type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

keyword_ty
_PyAST_keyword(identifier arg, expr_ty value, int lineno, int col_offset, int
               end_lineno, int end_col_offset, PyArena *arena)
{
    keyword_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for keyword");
        return NULL;
    }
    p = (keyword_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->arg = arg;
    p->value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

alias_ty
_PyAST_alias(identifier name, identifier asname, int lineno, int col_offset,
             int end_lineno, int end_col_offset, PyArena *arena)
{
    alias_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for alias");
        return NULL;
    }
    p = (alias_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->name = name;
    p->asname = asname;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

withitem_ty
_PyAST_withitem(expr_ty context_expr, expr_ty optional_vars, PyArena *arena)
{
    withitem_ty p;
    if (!context_expr) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'context_expr' is required for withitem");
        return NULL;
    }
    p = (withitem_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->context_expr = context_expr;
    p->optional_vars = optional_vars;
    return p;
}

match_case_ty
_PyAST_match_case(pattern_ty pattern, expr_ty guard, asdl_stmt_seq * body,
                  PyArena *arena)
{
    match_case_ty p;
    if (!pattern) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'pattern' is required for match_case");
        return NULL;
    }
    p = (match_case_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->pattern = pattern;
    p->guard = guard;
    p->body = body;
    return p;
}

pattern_ty
_PyAST_MatchValue(expr_ty value, int lineno, int col_offset, int end_lineno,
                  int end_col_offset, PyArena *arena)
{
    pattern_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for MatchValue");
        return NULL;
    }
    p = (pattern_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = MatchValue_kind;
    p->v.MatchValue.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchSingleton(constant value, int lineno, int col_offset, int
                      end_lineno, int end_col_offset, PyArena *arena)
{
    pattern_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for MatchSingleton");
        return NULL;
    }
    p = (pattern_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = MatchSingleton_kind;
    p->v.MatchSingleton.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchSequence(asdl_pattern_seq * patterns, int lineno, int col_offset,
                     int end_lineno, int end_col_offset, PyArena *arena)
{
    pattern_ty p;
    p = (pattern_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = MatchSequence_kind;
    p->v.MatchSequence.patterns = patterns;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchMapping(asdl_expr_seq * keys, asdl_pattern_seq * patterns,
                    identifier rest, int lineno, int col_offset, int
                    end_lineno, int end_col_offset, PyArena *arena)
{
    pattern_ty p;
    p = (pattern_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = MatchMapping_kind;
    p->v.MatchMapping.keys = keys;
    p->v.MatchMapping.patterns = patterns;
    p->v.MatchMapping.rest = rest;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchClass(expr_ty cls, asdl_pattern_seq * patterns, asdl_identifier_seq
                  * kwd_attrs, asdl_pattern_seq * kwd_patterns, int lineno, int
                  col_offset, int end_lineno, int end_col_offset, PyArena
                  *arena)
{
    pattern_ty p;
    if (!cls) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'cls' is required for MatchClass");
        return NULL;
    }
    p = (pattern_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = MatchClass_kind;
    p->v.MatchClass.cls = cls;
    p->v.MatchClass.patterns = patterns;
    p->v.MatchClass.kwd_attrs = kwd_attrs;
    p->v.MatchClass.kwd_patterns = kwd_patterns;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchStar(identifier name, int lineno, int col_offset, int end_lineno,
                 int end_col_offset, PyArena *arena)
{
    pattern_ty p;
    p = (pattern_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = MatchStar_kind;
    p->v.MatchStar.name = name;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchAs(pattern_ty pattern, identifier name, int lineno, int col_offset,
               int end_lineno, int end_col_offset, PyArena *arena)
{
    pattern_ty p;
    p = (pattern_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = MatchAs_kind;
    p->v.MatchAs.pattern = pattern;
    p->v.MatchAs.name = name;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchOr(asdl_pattern_seq * patterns, int lineno, int col_offset, int
               end_lineno, int end_col_offset, PyArena *arena)
{
    pattern_ty p;
    p = (pattern_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = MatchOr_kind;
    p->v.MatchOr.patterns = patterns;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

type_ignore_ty
_PyAST_TypeIgnore(int lineno, string tag, PyArena *arena)
{
    type_ignore_ty p;
    if (!tag) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'tag' is required for TypeIgnore");
        return NULL;
    }
    p = (type_ignore_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = TypeIgnore_kind;
    p->v.TypeIgnore.lineno = lineno;
    p->v.TypeIgnore.tag = tag;
    return p;
}

type_param_ty
_PyAST_TypeVar(identifier name, expr_ty bound, expr_ty default_value, int
               lineno, int col_offset, int end_lineno, int end_col_offset,
               PyArena *arena)
{
    type_param_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for TypeVar");
        return NULL;
    }
    p = (type_param_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = TypeVar_kind;
    p->v.TypeVar.name = name;
    p->v.TypeVar.bound = bound;
    p->v.TypeVar.default_value = default_value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

type_param_ty
_PyAST_ParamSpec(identifier name, expr_ty default_value, int lineno, int
                 col_offset, int end_lineno, int end_col_offset, PyArena *arena)
{
    type_param_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for ParamSpec");
        return NULL;
    }
    p = (type_param_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = ParamSpec_kind;
    p->v.ParamSpec.name = name;
    p->v.ParamSpec.default_value = default_value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

type_param_ty
_PyAST_TypeVarTuple(identifier name, expr_ty default_value, int lineno, int
                    col_offset, int end_lineno, int end_col_offset, PyArena
                    *arena)
{
    type_param_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for TypeVarTuple");
        return NULL;
    }
    p = (type_param_ty)_PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = TypeVarTuple_kind;
    p->v.TypeVarTuple.name = name;
    p->v.TypeVarTuple.default_value = default_value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}


mod_ty
_PyAST_ModuleHeap(struct ast_state* state, asdl_stmt_seq * body,
                  asdl_type_ignore_seq * type_ignores)
{
    mod_ty p;
    p = (mod_ty)_PyObject_New((PyTypeObject *)state->_Module_type);
    if (!p)
        return NULL;
    p->kind = Module_kind;
    p->v.Module.body = body;
    p->v.Module.type_ignores = type_ignores;
    return p;
}

mod_ty
_PyAST_InteractiveHeap(struct ast_state* state, asdl_stmt_seq * body)
{
    mod_ty p;
    p = (mod_ty)_PyObject_New((PyTypeObject *)state->_Interactive_type);
    if (!p)
        return NULL;
    p->kind = Interactive_kind;
    p->v.Interactive.body = body;
    return p;
}

mod_ty
_PyAST_ExpressionHeap(struct ast_state* state, expr_ty body)
{
    mod_ty p;
    if (!body) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'body' is required for Expression");
        return NULL;
    }
    p = (mod_ty)_PyObject_New((PyTypeObject *)state->_Expression_type);
    if (!p)
        return NULL;
    p->kind = Expression_kind;
    p->v.Expression.body = body;
    return p;
}

mod_ty
_PyAST_FunctionTypeHeap(struct ast_state* state, asdl_expr_seq * argtypes,
                        expr_ty returns)
{
    mod_ty p;
    if (!returns) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'returns' is required for FunctionType");
        return NULL;
    }
    p = (mod_ty)_PyObject_New((PyTypeObject *)state->_FunctionType_type);
    if (!p)
        return NULL;
    p->kind = FunctionType_kind;
    p->v.FunctionType.argtypes = argtypes;
    p->v.FunctionType.returns = returns;
    return p;
}

stmt_ty
_PyAST_FunctionDefHeap(struct ast_state* state, identifier name, arguments_ty
                       args, asdl_stmt_seq * body, asdl_expr_seq *
                       decorator_list, expr_ty returns, string type_comment,
                       asdl_type_param_seq * type_params, int lineno, int
                       col_offset, int end_lineno, int end_col_offset)
{
    stmt_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for FunctionDef");
        return NULL;
    }
    if (!args) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'args' is required for FunctionDef");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_FunctionDef_type);
    if (!p)
        return NULL;
    p->kind = FunctionDef_kind;
    p->v.FunctionDef.name = name;
    p->v.FunctionDef.args = args;
    p->v.FunctionDef.body = body;
    p->v.FunctionDef.decorator_list = decorator_list;
    p->v.FunctionDef.returns = returns;
    p->v.FunctionDef.type_comment = type_comment;
    p->v.FunctionDef.type_params = type_params;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_AsyncFunctionDefHeap(struct ast_state* state, identifier name,
                            arguments_ty args, asdl_stmt_seq * body,
                            asdl_expr_seq * decorator_list, expr_ty returns,
                            string type_comment, asdl_type_param_seq *
                            type_params, int lineno, int col_offset, int
                            end_lineno, int end_col_offset)
{
    stmt_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for AsyncFunctionDef");
        return NULL;
    }
    if (!args) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'args' is required for AsyncFunctionDef");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_AsyncFunctionDef_type);
    if (!p)
        return NULL;
    p->kind = AsyncFunctionDef_kind;
    p->v.AsyncFunctionDef.name = name;
    p->v.AsyncFunctionDef.args = args;
    p->v.AsyncFunctionDef.body = body;
    p->v.AsyncFunctionDef.decorator_list = decorator_list;
    p->v.AsyncFunctionDef.returns = returns;
    p->v.AsyncFunctionDef.type_comment = type_comment;
    p->v.AsyncFunctionDef.type_params = type_params;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_ClassDefHeap(struct ast_state* state, identifier name, asdl_expr_seq *
                    bases, asdl_keyword_seq * keywords, asdl_stmt_seq * body,
                    asdl_expr_seq * decorator_list, asdl_type_param_seq *
                    type_params, int lineno, int col_offset, int end_lineno,
                    int end_col_offset)
{
    stmt_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for ClassDef");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_ClassDef_type);
    if (!p)
        return NULL;
    p->kind = ClassDef_kind;
    p->v.ClassDef.name = name;
    p->v.ClassDef.bases = bases;
    p->v.ClassDef.keywords = keywords;
    p->v.ClassDef.body = body;
    p->v.ClassDef.decorator_list = decorator_list;
    p->v.ClassDef.type_params = type_params;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_ReturnHeap(struct ast_state* state, expr_ty value, int lineno, int
                  col_offset, int end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Return_type);
    if (!p)
        return NULL;
    p->kind = Return_kind;
    p->v.Return.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_DeleteHeap(struct ast_state* state, asdl_expr_seq * targets, int lineno,
                  int col_offset, int end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Delete_type);
    if (!p)
        return NULL;
    p->kind = Delete_kind;
    p->v.Delete.targets = targets;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_AssignHeap(struct ast_state* state, asdl_expr_seq * targets, expr_ty
                  value, string type_comment, int lineno, int col_offset, int
                  end_lineno, int end_col_offset)
{
    stmt_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Assign");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Assign_type);
    if (!p)
        return NULL;
    p->kind = Assign_kind;
    p->v.Assign.targets = targets;
    p->v.Assign.value = value;
    p->v.Assign.type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_TypeAliasHeap(struct ast_state* state, expr_ty name, asdl_type_param_seq
                     * type_params, expr_ty value, int lineno, int col_offset,
                     int end_lineno, int end_col_offset)
{
    stmt_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for TypeAlias");
        return NULL;
    }
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for TypeAlias");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_TypeAlias_type);
    if (!p)
        return NULL;
    p->kind = TypeAlias_kind;
    p->v.TypeAlias.name = name;
    p->v.TypeAlias.type_params = type_params;
    p->v.TypeAlias.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_AugAssignHeap(struct ast_state* state, expr_ty target, operator_ty op,
                     expr_ty value, int lineno, int col_offset, int end_lineno,
                     int end_col_offset)
{
    stmt_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'target' is required for AugAssign");
        return NULL;
    }
    if (!op) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'op' is required for AugAssign");
        return NULL;
    }
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for AugAssign");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_AugAssign_type);
    if (!p)
        return NULL;
    p->kind = AugAssign_kind;
    p->v.AugAssign.target = target;
    p->v.AugAssign.op = op;
    p->v.AugAssign.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_AnnAssignHeap(struct ast_state* state, expr_ty target, expr_ty
                     annotation, expr_ty value, int simple, int lineno, int
                     col_offset, int end_lineno, int end_col_offset)
{
    stmt_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'target' is required for AnnAssign");
        return NULL;
    }
    if (!annotation) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'annotation' is required for AnnAssign");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_AnnAssign_type);
    if (!p)
        return NULL;
    p->kind = AnnAssign_kind;
    p->v.AnnAssign.target = target;
    p->v.AnnAssign.annotation = annotation;
    p->v.AnnAssign.value = value;
    p->v.AnnAssign.simple = simple;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_ForHeap(struct ast_state* state, expr_ty target, expr_ty iter,
               asdl_stmt_seq * body, asdl_stmt_seq * orelse, string
               type_comment, int lineno, int col_offset, int end_lineno, int
               end_col_offset)
{
    stmt_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'target' is required for For");
        return NULL;
    }
    if (!iter) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'iter' is required for For");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_For_type);
    if (!p)
        return NULL;
    p->kind = For_kind;
    p->v.For.target = target;
    p->v.For.iter = iter;
    p->v.For.body = body;
    p->v.For.orelse = orelse;
    p->v.For.type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_AsyncForHeap(struct ast_state* state, expr_ty target, expr_ty iter,
                    asdl_stmt_seq * body, asdl_stmt_seq * orelse, string
                    type_comment, int lineno, int col_offset, int end_lineno,
                    int end_col_offset)
{
    stmt_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'target' is required for AsyncFor");
        return NULL;
    }
    if (!iter) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'iter' is required for AsyncFor");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_AsyncFor_type);
    if (!p)
        return NULL;
    p->kind = AsyncFor_kind;
    p->v.AsyncFor.target = target;
    p->v.AsyncFor.iter = iter;
    p->v.AsyncFor.body = body;
    p->v.AsyncFor.orelse = orelse;
    p->v.AsyncFor.type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_WhileHeap(struct ast_state* state, expr_ty test, asdl_stmt_seq * body,
                 asdl_stmt_seq * orelse, int lineno, int col_offset, int
                 end_lineno, int end_col_offset)
{
    stmt_ty p;
    if (!test) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'test' is required for While");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_While_type);
    if (!p)
        return NULL;
    p->kind = While_kind;
    p->v.While.test = test;
    p->v.While.body = body;
    p->v.While.orelse = orelse;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_IfHeap(struct ast_state* state, expr_ty test, asdl_stmt_seq * body,
              asdl_stmt_seq * orelse, int lineno, int col_offset, int
              end_lineno, int end_col_offset)
{
    stmt_ty p;
    if (!test) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'test' is required for If");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_If_type);
    if (!p)
        return NULL;
    p->kind = If_kind;
    p->v.If.test = test;
    p->v.If.body = body;
    p->v.If.orelse = orelse;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_WithHeap(struct ast_state* state, asdl_withitem_seq * items,
                asdl_stmt_seq * body, string type_comment, int lineno, int
                col_offset, int end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_With_type);
    if (!p)
        return NULL;
    p->kind = With_kind;
    p->v.With.items = items;
    p->v.With.body = body;
    p->v.With.type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_AsyncWithHeap(struct ast_state* state, asdl_withitem_seq * items,
                     asdl_stmt_seq * body, string type_comment, int lineno, int
                     col_offset, int end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_AsyncWith_type);
    if (!p)
        return NULL;
    p->kind = AsyncWith_kind;
    p->v.AsyncWith.items = items;
    p->v.AsyncWith.body = body;
    p->v.AsyncWith.type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_MatchHeap(struct ast_state* state, expr_ty subject, asdl_match_case_seq
                 * cases, int lineno, int col_offset, int end_lineno, int
                 end_col_offset)
{
    stmt_ty p;
    if (!subject) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'subject' is required for Match");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Match_type);
    if (!p)
        return NULL;
    p->kind = Match_kind;
    p->v.Match.subject = subject;
    p->v.Match.cases = cases;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_RaiseHeap(struct ast_state* state, expr_ty exc, expr_ty cause, int
                 lineno, int col_offset, int end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Raise_type);
    if (!p)
        return NULL;
    p->kind = Raise_kind;
    p->v.Raise.exc = exc;
    p->v.Raise.cause = cause;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_TryHeap(struct ast_state* state, asdl_stmt_seq * body,
               asdl_excepthandler_seq * handlers, asdl_stmt_seq * orelse,
               asdl_stmt_seq * finalbody, int lineno, int col_offset, int
               end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Try_type);
    if (!p)
        return NULL;
    p->kind = Try_kind;
    p->v.Try.body = body;
    p->v.Try.handlers = handlers;
    p->v.Try.orelse = orelse;
    p->v.Try.finalbody = finalbody;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_TryStarHeap(struct ast_state* state, asdl_stmt_seq * body,
                   asdl_excepthandler_seq * handlers, asdl_stmt_seq * orelse,
                   asdl_stmt_seq * finalbody, int lineno, int col_offset, int
                   end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_TryStar_type);
    if (!p)
        return NULL;
    p->kind = TryStar_kind;
    p->v.TryStar.body = body;
    p->v.TryStar.handlers = handlers;
    p->v.TryStar.orelse = orelse;
    p->v.TryStar.finalbody = finalbody;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_AssertHeap(struct ast_state* state, expr_ty test, expr_ty msg, int
                  lineno, int col_offset, int end_lineno, int end_col_offset)
{
    stmt_ty p;
    if (!test) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'test' is required for Assert");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Assert_type);
    if (!p)
        return NULL;
    p->kind = Assert_kind;
    p->v.Assert.test = test;
    p->v.Assert.msg = msg;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_ImportHeap(struct ast_state* state, asdl_alias_seq * names, int lineno,
                  int col_offset, int end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Import_type);
    if (!p)
        return NULL;
    p->kind = Import_kind;
    p->v.Import.names = names;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_ImportFromHeap(struct ast_state* state, identifier module,
                      asdl_alias_seq * names, int level, int lineno, int
                      col_offset, int end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_ImportFrom_type);
    if (!p)
        return NULL;
    p->kind = ImportFrom_kind;
    p->v.ImportFrom.module = module;
    p->v.ImportFrom.names = names;
    p->v.ImportFrom.level = level;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_GlobalHeap(struct ast_state* state, asdl_identifier_seq * names, int
                  lineno, int col_offset, int end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Global_type);
    if (!p)
        return NULL;
    p->kind = Global_kind;
    p->v.Global.names = names;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_NonlocalHeap(struct ast_state* state, asdl_identifier_seq * names, int
                    lineno, int col_offset, int end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Nonlocal_type);
    if (!p)
        return NULL;
    p->kind = Nonlocal_kind;
    p->v.Nonlocal.names = names;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_ExprHeap(struct ast_state* state, expr_ty value, int lineno, int
                col_offset, int end_lineno, int end_col_offset)
{
    stmt_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Expr");
        return NULL;
    }
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Expr_type);
    if (!p)
        return NULL;
    p->kind = Expr_kind;
    p->v.Expr.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_PassHeap(struct ast_state* state, int lineno, int col_offset, int
                end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Pass_type);
    if (!p)
        return NULL;
    p->kind = Pass_kind;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_BreakHeap(struct ast_state* state, int lineno, int col_offset, int
                 end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Break_type);
    if (!p)
        return NULL;
    p->kind = Break_kind;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

stmt_ty
_PyAST_ContinueHeap(struct ast_state* state, int lineno, int col_offset, int
                    end_lineno, int end_col_offset)
{
    stmt_ty p;
    p = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Continue_type);
    if (!p)
        return NULL;
    p->kind = Continue_kind;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_BoolOpHeap(struct ast_state* state, boolop_ty op, asdl_expr_seq *
                  values, int lineno, int col_offset, int end_lineno, int
                  end_col_offset)
{
    expr_ty p;
    if (!op) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'op' is required for BoolOp");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_BoolOp_type);
    if (!p)
        return NULL;
    p->kind = BoolOp_kind;
    p->v.BoolOp.op = op;
    p->v.BoolOp.values = values;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_NamedExprHeap(struct ast_state* state, expr_ty target, expr_ty value,
                     int lineno, int col_offset, int end_lineno, int
                     end_col_offset)
{
    expr_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'target' is required for NamedExpr");
        return NULL;
    }
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for NamedExpr");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_NamedExpr_type);
    if (!p)
        return NULL;
    p->kind = NamedExpr_kind;
    p->v.NamedExpr.target = target;
    p->v.NamedExpr.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_BinOpHeap(struct ast_state* state, expr_ty left, operator_ty op, expr_ty
                 right, int lineno, int col_offset, int end_lineno, int
                 end_col_offset)
{
    expr_ty p;
    if (!left) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'left' is required for BinOp");
        return NULL;
    }
    if (!op) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'op' is required for BinOp");
        return NULL;
    }
    if (!right) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'right' is required for BinOp");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_BinOp_type);
    if (!p)
        return NULL;
    p->kind = BinOp_kind;
    p->v.BinOp.left = left;
    p->v.BinOp.op = op;
    p->v.BinOp.right = right;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_UnaryOpHeap(struct ast_state* state, unaryop_ty op, expr_ty operand, int
                   lineno, int col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!op) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'op' is required for UnaryOp");
        return NULL;
    }
    if (!operand) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'operand' is required for UnaryOp");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_UnaryOp_type);
    if (!p)
        return NULL;
    p->kind = UnaryOp_kind;
    p->v.UnaryOp.op = op;
    p->v.UnaryOp.operand = operand;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_LambdaHeap(struct ast_state* state, arguments_ty args, expr_ty body, int
                  lineno, int col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!args) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'args' is required for Lambda");
        return NULL;
    }
    if (!body) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'body' is required for Lambda");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Lambda_type);
    if (!p)
        return NULL;
    p->kind = Lambda_kind;
    p->v.Lambda.args = args;
    p->v.Lambda.body = body;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_IfExpHeap(struct ast_state* state, expr_ty test, expr_ty body, expr_ty
                 orelse, int lineno, int col_offset, int end_lineno, int
                 end_col_offset)
{
    expr_ty p;
    if (!test) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'test' is required for IfExp");
        return NULL;
    }
    if (!body) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'body' is required for IfExp");
        return NULL;
    }
    if (!orelse) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'orelse' is required for IfExp");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_IfExp_type);
    if (!p)
        return NULL;
    p->kind = IfExp_kind;
    p->v.IfExp.test = test;
    p->v.IfExp.body = body;
    p->v.IfExp.orelse = orelse;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_DictHeap(struct ast_state* state, asdl_expr_seq * keys, asdl_expr_seq *
                values, int lineno, int col_offset, int end_lineno, int
                end_col_offset)
{
    expr_ty p;
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Dict_type);
    if (!p)
        return NULL;
    p->kind = Dict_kind;
    p->v.Dict.keys = keys;
    p->v.Dict.values = values;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_SetHeap(struct ast_state* state, asdl_expr_seq * elts, int lineno, int
               col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Set_type);
    if (!p)
        return NULL;
    p->kind = Set_kind;
    p->v.Set.elts = elts;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_ListCompHeap(struct ast_state* state, expr_ty elt,
                    asdl_comprehension_seq * generators, int lineno, int
                    col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!elt) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'elt' is required for ListComp");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_ListComp_type);
    if (!p)
        return NULL;
    p->kind = ListComp_kind;
    p->v.ListComp.elt = elt;
    p->v.ListComp.generators = generators;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_SetCompHeap(struct ast_state* state, expr_ty elt, asdl_comprehension_seq
                   * generators, int lineno, int col_offset, int end_lineno,
                   int end_col_offset)
{
    expr_ty p;
    if (!elt) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'elt' is required for SetComp");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_SetComp_type);
    if (!p)
        return NULL;
    p->kind = SetComp_kind;
    p->v.SetComp.elt = elt;
    p->v.SetComp.generators = generators;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_DictCompHeap(struct ast_state* state, expr_ty key, expr_ty value,
                    asdl_comprehension_seq * generators, int lineno, int
                    col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!key) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'key' is required for DictComp");
        return NULL;
    }
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for DictComp");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_DictComp_type);
    if (!p)
        return NULL;
    p->kind = DictComp_kind;
    p->v.DictComp.key = key;
    p->v.DictComp.value = value;
    p->v.DictComp.generators = generators;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_GeneratorExpHeap(struct ast_state* state, expr_ty elt,
                        asdl_comprehension_seq * generators, int lineno, int
                        col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!elt) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'elt' is required for GeneratorExp");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_GeneratorExp_type);
    if (!p)
        return NULL;
    p->kind = GeneratorExp_kind;
    p->v.GeneratorExp.elt = elt;
    p->v.GeneratorExp.generators = generators;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_AwaitHeap(struct ast_state* state, expr_ty value, int lineno, int
                 col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Await");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Await_type);
    if (!p)
        return NULL;
    p->kind = Await_kind;
    p->v.Await.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_YieldHeap(struct ast_state* state, expr_ty value, int lineno, int
                 col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Yield_type);
    if (!p)
        return NULL;
    p->kind = Yield_kind;
    p->v.Yield.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_YieldFromHeap(struct ast_state* state, expr_ty value, int lineno, int
                     col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for YieldFrom");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_YieldFrom_type);
    if (!p)
        return NULL;
    p->kind = YieldFrom_kind;
    p->v.YieldFrom.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_CompareHeap(struct ast_state* state, expr_ty left, asdl_int_seq * ops,
                   asdl_expr_seq * comparators, int lineno, int col_offset, int
                   end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!left) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'left' is required for Compare");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Compare_type);
    if (!p)
        return NULL;
    p->kind = Compare_kind;
    p->v.Compare.left = left;
    p->v.Compare.ops = ops;
    p->v.Compare.comparators = comparators;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_CallHeap(struct ast_state* state, expr_ty func, asdl_expr_seq * args,
                asdl_keyword_seq * keywords, int lineno, int col_offset, int
                end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!func) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'func' is required for Call");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Call_type);
    if (!p)
        return NULL;
    p->kind = Call_kind;
    p->v.Call.func = func;
    p->v.Call.args = args;
    p->v.Call.keywords = keywords;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_FormattedValueHeap(struct ast_state* state, expr_ty value, int
                          conversion, expr_ty format_spec, int lineno, int
                          col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for FormattedValue");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_FormattedValue_type);
    if (!p)
        return NULL;
    p->kind = FormattedValue_kind;
    p->v.FormattedValue.value = value;
    p->v.FormattedValue.conversion = conversion;
    p->v.FormattedValue.format_spec = format_spec;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_InterpolationHeap(struct ast_state* state, expr_ty value, constant str,
                         int conversion, expr_ty format_spec, int lineno, int
                         col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Interpolation");
        return NULL;
    }
    if (!str) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'str' is required for Interpolation");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Interpolation_type);
    if (!p)
        return NULL;
    p->kind = Interpolation_kind;
    p->v.Interpolation.value = value;
    p->v.Interpolation.str = str;
    p->v.Interpolation.conversion = conversion;
    p->v.Interpolation.format_spec = format_spec;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_JoinedStrHeap(struct ast_state* state, asdl_expr_seq * values, int
                     lineno, int col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_JoinedStr_type);
    if (!p)
        return NULL;
    p->kind = JoinedStr_kind;
    p->v.JoinedStr.values = values;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_TemplateStrHeap(struct ast_state* state, asdl_expr_seq * values, int
                       lineno, int col_offset, int end_lineno, int
                       end_col_offset)
{
    expr_ty p;
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_TemplateStr_type);
    if (!p)
        return NULL;
    p->kind = TemplateStr_kind;
    p->v.TemplateStr.values = values;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_ConstantHeap(struct ast_state* state, constant value, string kind, int
                    lineno, int col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Constant");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Constant_type);
    if (!p)
        return NULL;
    p->kind = Constant_kind;
    p->v.Constant.value = value;
    p->v.Constant.kind = kind;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_AttributeHeap(struct ast_state* state, expr_ty value, identifier attr,
                     expr_context_ty ctx, int lineno, int col_offset, int
                     end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Attribute");
        return NULL;
    }
    if (!attr) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'attr' is required for Attribute");
        return NULL;
    }
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'ctx' is required for Attribute");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Attribute_type);
    if (!p)
        return NULL;
    p->kind = Attribute_kind;
    p->v.Attribute.value = value;
    p->v.Attribute.attr = attr;
    p->v.Attribute.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_SubscriptHeap(struct ast_state* state, expr_ty value, expr_ty slice,
                     expr_context_ty ctx, int lineno, int col_offset, int
                     end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Subscript");
        return NULL;
    }
    if (!slice) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'slice' is required for Subscript");
        return NULL;
    }
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'ctx' is required for Subscript");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Subscript_type);
    if (!p)
        return NULL;
    p->kind = Subscript_kind;
    p->v.Subscript.value = value;
    p->v.Subscript.slice = slice;
    p->v.Subscript.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_StarredHeap(struct ast_state* state, expr_ty value, expr_context_ty ctx,
                   int lineno, int col_offset, int end_lineno, int
                   end_col_offset)
{
    expr_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for Starred");
        return NULL;
    }
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'ctx' is required for Starred");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Starred_type);
    if (!p)
        return NULL;
    p->kind = Starred_kind;
    p->v.Starred.value = value;
    p->v.Starred.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_NameHeap(struct ast_state* state, identifier id, expr_context_ty ctx,
                int lineno, int col_offset, int end_lineno, int end_col_offset)
{
    expr_ty p;
    if (!id) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'id' is required for Name");
        return NULL;
    }
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'ctx' is required for Name");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Name_type);
    if (!p)
        return NULL;
    p->kind = Name_kind;
    p->v.Name.id = id;
    p->v.Name.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_ListHeap(struct ast_state* state, asdl_expr_seq * elts, expr_context_ty
                ctx, int lineno, int col_offset, int end_lineno, int
                end_col_offset)
{
    expr_ty p;
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'ctx' is required for List");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_List_type);
    if (!p)
        return NULL;
    p->kind = List_kind;
    p->v.List.elts = elts;
    p->v.List.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_TupleHeap(struct ast_state* state, asdl_expr_seq * elts, expr_context_ty
                 ctx, int lineno, int col_offset, int end_lineno, int
                 end_col_offset)
{
    expr_ty p;
    if (!ctx) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'ctx' is required for Tuple");
        return NULL;
    }
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Tuple_type);
    if (!p)
        return NULL;
    p->kind = Tuple_kind;
    p->v.Tuple.elts = elts;
    p->v.Tuple.ctx = ctx;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

expr_ty
_PyAST_SliceHeap(struct ast_state* state, expr_ty lower, expr_ty upper, expr_ty
                 step, int lineno, int col_offset, int end_lineno, int
                 end_col_offset)
{
    expr_ty p;
    p = (expr_ty)_PyObject_New((PyTypeObject *)state->_Slice_type);
    if (!p)
        return NULL;
    p->kind = Slice_kind;
    p->v.Slice.lower = lower;
    p->v.Slice.upper = upper;
    p->v.Slice.step = step;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

comprehension_ty
_PyAST_comprehensionHeap(struct ast_state* state, expr_ty target, expr_ty iter,
                         asdl_expr_seq * ifs, int is_async)
{
    comprehension_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'target' is required for comprehension");
        return NULL;
    }
    if (!iter) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'iter' is required for comprehension");
        return NULL;
    }
    p = (comprehension_ty)_PyObject_New((PyTypeObject
         *)state->_comprehension_type);
    if (!p)
        return NULL;
    p->target = target;
    p->iter = iter;
    p->ifs = ifs;
    p->is_async = is_async;
    return p;
}

excepthandler_ty
_PyAST_ExceptHandlerHeap(struct ast_state* state, expr_ty type, identifier
                         name, asdl_stmt_seq * body, int lineno, int
                         col_offset, int end_lineno, int end_col_offset)
{
    excepthandler_ty p;
    p = (excepthandler_ty)_PyObject_New((PyTypeObject
         *)state->_ExceptHandler_type);
    if (!p)
        return NULL;
    p->kind = ExceptHandler_kind;
    p->v.ExceptHandler.type = type;
    p->v.ExceptHandler.name = name;
    p->v.ExceptHandler.body = body;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

arguments_ty
_PyAST_argumentsHeap(struct ast_state* state, asdl_arg_seq * posonlyargs,
                     asdl_arg_seq * args, arg_ty vararg, asdl_arg_seq *
                     kwonlyargs, asdl_expr_seq * kw_defaults, arg_ty kwarg,
                     asdl_expr_seq * defaults)
{
    arguments_ty p;
    p = (arguments_ty)_PyObject_New((PyTypeObject *)state->_arguments_type);
    if (!p)
        return NULL;
    p->posonlyargs = posonlyargs;
    p->args = args;
    p->vararg = vararg;
    p->kwonlyargs = kwonlyargs;
    p->kw_defaults = kw_defaults;
    p->kwarg = kwarg;
    p->defaults = defaults;
    return p;
}

arg_ty
_PyAST_argHeap(struct ast_state* state, identifier arg, expr_ty annotation,
               string type_comment, int lineno, int col_offset, int end_lineno,
               int end_col_offset)
{
    arg_ty p;
    if (!arg) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'arg' is required for arg");
        return NULL;
    }
    p = (arg_ty)_PyObject_New((PyTypeObject *)state->_arg_type);
    if (!p)
        return NULL;
    p->arg = arg;
    p->annotation = annotation;
    p->type_comment = type_comment;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

keyword_ty
_PyAST_keywordHeap(struct ast_state* state, identifier arg, expr_ty value, int
                   lineno, int col_offset, int end_lineno, int end_col_offset)
{
    keyword_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for keyword");
        return NULL;
    }
    p = (keyword_ty)_PyObject_New((PyTypeObject *)state->_keyword_type);
    if (!p)
        return NULL;
    p->arg = arg;
    p->value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

alias_ty
_PyAST_aliasHeap(struct ast_state* state, identifier name, identifier asname,
                 int lineno, int col_offset, int end_lineno, int end_col_offset)
{
    alias_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for alias");
        return NULL;
    }
    p = (alias_ty)_PyObject_New((PyTypeObject *)state->_alias_type);
    if (!p)
        return NULL;
    p->name = name;
    p->asname = asname;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

withitem_ty
_PyAST_withitemHeap(struct ast_state* state, expr_ty context_expr, expr_ty
                    optional_vars)
{
    withitem_ty p;
    if (!context_expr) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'context_expr' is required for withitem");
        return NULL;
    }
    p = (withitem_ty)_PyObject_New((PyTypeObject *)state->_withitem_type);
    if (!p)
        return NULL;
    p->context_expr = context_expr;
    p->optional_vars = optional_vars;
    return p;
}

match_case_ty
_PyAST_match_caseHeap(struct ast_state* state, pattern_ty pattern, expr_ty
                      guard, asdl_stmt_seq * body)
{
    match_case_ty p;
    if (!pattern) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'pattern' is required for match_case");
        return NULL;
    }
    p = (match_case_ty)_PyObject_New((PyTypeObject *)state->_match_case_type);
    if (!p)
        return NULL;
    p->pattern = pattern;
    p->guard = guard;
    p->body = body;
    return p;
}

pattern_ty
_PyAST_MatchValueHeap(struct ast_state* state, expr_ty value, int lineno, int
                      col_offset, int end_lineno, int end_col_offset)
{
    pattern_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for MatchValue");
        return NULL;
    }
    p = (pattern_ty)_PyObject_New((PyTypeObject *)state->_MatchValue_type);
    if (!p)
        return NULL;
    p->kind = MatchValue_kind;
    p->v.MatchValue.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchSingletonHeap(struct ast_state* state, constant value, int lineno,
                          int col_offset, int end_lineno, int end_col_offset)
{
    pattern_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'value' is required for MatchSingleton");
        return NULL;
    }
    p = (pattern_ty)_PyObject_New((PyTypeObject *)state->_MatchSingleton_type);
    if (!p)
        return NULL;
    p->kind = MatchSingleton_kind;
    p->v.MatchSingleton.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchSequenceHeap(struct ast_state* state, asdl_pattern_seq * patterns,
                         int lineno, int col_offset, int end_lineno, int
                         end_col_offset)
{
    pattern_ty p;
    p = (pattern_ty)_PyObject_New((PyTypeObject *)state->_MatchSequence_type);
    if (!p)
        return NULL;
    p->kind = MatchSequence_kind;
    p->v.MatchSequence.patterns = patterns;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchMappingHeap(struct ast_state* state, asdl_expr_seq * keys,
                        asdl_pattern_seq * patterns, identifier rest, int
                        lineno, int col_offset, int end_lineno, int
                        end_col_offset)
{
    pattern_ty p;
    p = (pattern_ty)_PyObject_New((PyTypeObject *)state->_MatchMapping_type);
    if (!p)
        return NULL;
    p->kind = MatchMapping_kind;
    p->v.MatchMapping.keys = keys;
    p->v.MatchMapping.patterns = patterns;
    p->v.MatchMapping.rest = rest;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchClassHeap(struct ast_state* state, expr_ty cls, asdl_pattern_seq *
                      patterns, asdl_identifier_seq * kwd_attrs,
                      asdl_pattern_seq * kwd_patterns, int lineno, int
                      col_offset, int end_lineno, int end_col_offset)
{
    pattern_ty p;
    if (!cls) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'cls' is required for MatchClass");
        return NULL;
    }
    p = (pattern_ty)_PyObject_New((PyTypeObject *)state->_MatchClass_type);
    if (!p)
        return NULL;
    p->kind = MatchClass_kind;
    p->v.MatchClass.cls = cls;
    p->v.MatchClass.patterns = patterns;
    p->v.MatchClass.kwd_attrs = kwd_attrs;
    p->v.MatchClass.kwd_patterns = kwd_patterns;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchStarHeap(struct ast_state* state, identifier name, int lineno, int
                     col_offset, int end_lineno, int end_col_offset)
{
    pattern_ty p;
    p = (pattern_ty)_PyObject_New((PyTypeObject *)state->_MatchStar_type);
    if (!p)
        return NULL;
    p->kind = MatchStar_kind;
    p->v.MatchStar.name = name;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchAsHeap(struct ast_state* state, pattern_ty pattern, identifier
                   name, int lineno, int col_offset, int end_lineno, int
                   end_col_offset)
{
    pattern_ty p;
    p = (pattern_ty)_PyObject_New((PyTypeObject *)state->_MatchAs_type);
    if (!p)
        return NULL;
    p->kind = MatchAs_kind;
    p->v.MatchAs.pattern = pattern;
    p->v.MatchAs.name = name;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

pattern_ty
_PyAST_MatchOrHeap(struct ast_state* state, asdl_pattern_seq * patterns, int
                   lineno, int col_offset, int end_lineno, int end_col_offset)
{
    pattern_ty p;
    p = (pattern_ty)_PyObject_New((PyTypeObject *)state->_MatchOr_type);
    if (!p)
        return NULL;
    p->kind = MatchOr_kind;
    p->v.MatchOr.patterns = patterns;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

type_ignore_ty
_PyAST_TypeIgnoreHeap(struct ast_state* state, int lineno, string tag)
{
    type_ignore_ty p;
    if (!tag) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'tag' is required for TypeIgnore");
        return NULL;
    }
    p = (type_ignore_ty)_PyObject_New((PyTypeObject *)state->_TypeIgnore_type);
    if (!p)
        return NULL;
    p->kind = TypeIgnore_kind;
    p->v.TypeIgnore.lineno = lineno;
    p->v.TypeIgnore.tag = tag;
    return p;
}

type_param_ty
_PyAST_TypeVarHeap(struct ast_state* state, identifier name, expr_ty bound,
                   expr_ty default_value, int lineno, int col_offset, int
                   end_lineno, int end_col_offset)
{
    type_param_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for TypeVar");
        return NULL;
    }
    p = (type_param_ty)_PyObject_New((PyTypeObject *)state->_TypeVar_type);
    if (!p)
        return NULL;
    p->kind = TypeVar_kind;
    p->v.TypeVar.name = name;
    p->v.TypeVar.bound = bound;
    p->v.TypeVar.default_value = default_value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

type_param_ty
_PyAST_ParamSpecHeap(struct ast_state* state, identifier name, expr_ty
                     default_value, int lineno, int col_offset, int end_lineno,
                     int end_col_offset)
{
    type_param_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for ParamSpec");
        return NULL;
    }
    p = (type_param_ty)_PyObject_New((PyTypeObject *)state->_ParamSpec_type);
    if (!p)
        return NULL;
    p->kind = ParamSpec_kind;
    p->v.ParamSpec.name = name;
    p->v.ParamSpec.default_value = default_value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}

type_param_ty
_PyAST_TypeVarTupleHeap(struct ast_state* state, identifier name, expr_ty
                        default_value, int lineno, int col_offset, int
                        end_lineno, int end_col_offset)
{
    type_param_ty p;
    if (!name) {
        PyErr_SetString(PyExc_ValueError,
                        "field 'name' is required for TypeVarTuple");
        return NULL;
    }
    p = (type_param_ty)_PyObject_New((PyTypeObject *)state->_TypeVarTuple_type);
    if (!p)
        return NULL;
    p->kind = TypeVarTuple_kind;
    p->v.TypeVarTuple.name = name;
    p->v.TypeVarTuple.default_value = default_value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}


PyObject*
ast2obj_mod(struct ast_state *state, void* _o)
{
    mod_ty o = (mod_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    switch (o->kind) {
    case Module_kind:
        tp = (PyTypeObject *)state->Module_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.Module.body, ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.Module.type_ignores,
                             ast2obj_type_ignore);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->type_ignores, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Interactive_kind:
        tp = (PyTypeObject *)state->Interactive_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.Interactive.body,
                             ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Expression_kind:
        tp = (PyTypeObject *)state->Expression_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Expression.body);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case FunctionType_kind:
        tp = (PyTypeObject *)state->FunctionType_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.FunctionType.argtypes,
                             ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->argtypes, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.FunctionType.returns);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->returns, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_stmt(struct ast_state *state, void* _o)
{
    stmt_ty o = (stmt_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    switch (o->kind) {
    case FunctionDef_kind:
        tp = (PyTypeObject *)state->FunctionDef_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(state, o->v.FunctionDef.name);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_arguments(state, o->v.FunctionDef.args);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.FunctionDef.body,
                             ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.FunctionDef.decorator_list,
                             ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->decorator_list, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.FunctionDef.returns);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->returns, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(state, o->v.FunctionDef.type_comment);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.FunctionDef.type_params,
                             ast2obj_type_param);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->type_params, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AsyncFunctionDef_kind:
        tp = (PyTypeObject *)state->AsyncFunctionDef_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(state, o->v.AsyncFunctionDef.name);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_arguments(state, o->v.AsyncFunctionDef.args);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.AsyncFunctionDef.body,
                             ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state,
                             (asdl_seq*)o->v.AsyncFunctionDef.decorator_list,
                             ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->decorator_list, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.AsyncFunctionDef.returns);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->returns, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(state, o->v.AsyncFunctionDef.type_comment);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state,
                             (asdl_seq*)o->v.AsyncFunctionDef.type_params,
                             ast2obj_type_param);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->type_params, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ClassDef_kind:
        tp = (PyTypeObject *)state->ClassDef_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(state, o->v.ClassDef.name);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.ClassDef.bases,
                             ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->bases, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.ClassDef.keywords,
                             ast2obj_keyword);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->keywords, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.ClassDef.body,
                             ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.ClassDef.decorator_list,
                             ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->decorator_list, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.ClassDef.type_params,
                             ast2obj_type_param);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->type_params, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Return_kind:
        tp = (PyTypeObject *)state->Return_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Return.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Delete_kind:
        tp = (PyTypeObject *)state->Delete_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.Delete.targets,
                             ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->targets, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Assign_kind:
        tp = (PyTypeObject *)state->Assign_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.Assign.targets,
                             ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->targets, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.Assign.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(state, o->v.Assign.type_comment);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case TypeAlias_kind:
        tp = (PyTypeObject *)state->TypeAlias_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.TypeAlias.name);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.TypeAlias.type_params,
                             ast2obj_type_param);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->type_params, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.TypeAlias.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AugAssign_kind:
        tp = (PyTypeObject *)state->AugAssign_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.AugAssign.target);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_operator(state, o->v.AugAssign.op);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.AugAssign.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AnnAssign_kind:
        tp = (PyTypeObject *)state->AnnAssign_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.AnnAssign.target);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.AnnAssign.annotation);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->annotation, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.AnnAssign.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_int(state, o->v.AnnAssign.simple);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->simple, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case For_kind:
        tp = (PyTypeObject *)state->For_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.For.target);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.For.iter);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->iter, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.For.body, ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.For.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(state, o->v.For.type_comment);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AsyncFor_kind:
        tp = (PyTypeObject *)state->AsyncFor_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.AsyncFor.target);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.AsyncFor.iter);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->iter, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.AsyncFor.body,
                             ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.AsyncFor.orelse,
                             ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(state, o->v.AsyncFor.type_comment);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case While_kind:
        tp = (PyTypeObject *)state->While_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.While.test);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.While.body, ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.While.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case If_kind:
        tp = (PyTypeObject *)state->If_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.If.test);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.If.body, ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.If.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case With_kind:
        tp = (PyTypeObject *)state->With_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.With.items,
                             ast2obj_withitem);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->items, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.With.body, ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(state, o->v.With.type_comment);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case AsyncWith_kind:
        tp = (PyTypeObject *)state->AsyncWith_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.AsyncWith.items,
                             ast2obj_withitem);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->items, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.AsyncWith.body,
                             ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(state, o->v.AsyncWith.type_comment);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->type_comment, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Match_kind:
        tp = (PyTypeObject *)state->Match_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Match.subject);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->subject, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.Match.cases,
                             ast2obj_match_case);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->cases, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Raise_kind:
        tp = (PyTypeObject *)state->Raise_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Raise.exc);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->exc, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.Raise.cause);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->cause, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Try_kind:
        tp = (PyTypeObject *)state->Try_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.Try.body, ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.Try.handlers,
                             ast2obj_excepthandler);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->handlers, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.Try.orelse, ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.Try.finalbody,
                             ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->finalbody, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case TryStar_kind:
        tp = (PyTypeObject *)state->TryStar_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.TryStar.body, ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.TryStar.handlers,
                             ast2obj_excepthandler);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->handlers, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.TryStar.orelse,
                             ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.TryStar.finalbody,
                             ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->finalbody, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Assert_kind:
        tp = (PyTypeObject *)state->Assert_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Assert.test);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.Assert.msg);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->msg, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Import_kind:
        tp = (PyTypeObject *)state->Import_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.Import.names,
                             ast2obj_alias);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->names, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ImportFrom_kind:
        tp = (PyTypeObject *)state->ImportFrom_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(state, o->v.ImportFrom.module);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->module, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.ImportFrom.names,
                             ast2obj_alias);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->names, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_int(state, o->v.ImportFrom.level);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->level, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Global_kind:
        tp = (PyTypeObject *)state->Global_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.Global.names,
                             ast2obj_identifier);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->names, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Nonlocal_kind:
        tp = (PyTypeObject *)state->Nonlocal_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.Nonlocal.names,
                             ast2obj_identifier);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->names, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Expr_kind:
        tp = (PyTypeObject *)state->Expr_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Expr.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Pass_kind:
        tp = (PyTypeObject *)state->Pass_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        break;
    case Break_kind:
        tp = (PyTypeObject *)state->Break_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        break;
    case Continue_kind:
        tp = (PyTypeObject *)state->Continue_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        break;
    }
    value = ast2obj_int(state, o->lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_expr(struct ast_state *state, void* _o)
{
    expr_ty o = (expr_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    switch (o->kind) {
    case BoolOp_kind:
        tp = (PyTypeObject *)state->BoolOp_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_boolop(state, o->v.BoolOp.op);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.BoolOp.values,
                             ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->values, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case NamedExpr_kind:
        tp = (PyTypeObject *)state->NamedExpr_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.NamedExpr.target);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->target, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.NamedExpr.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case BinOp_kind:
        tp = (PyTypeObject *)state->BinOp_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.BinOp.left);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->left, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_operator(state, o->v.BinOp.op);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.BinOp.right);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->right, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case UnaryOp_kind:
        tp = (PyTypeObject *)state->UnaryOp_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_unaryop(state, o->v.UnaryOp.op);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.UnaryOp.operand);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->operand, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Lambda_kind:
        tp = (PyTypeObject *)state->Lambda_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_arguments(state, o->v.Lambda.args);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.Lambda.body);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case IfExp_kind:
        tp = (PyTypeObject *)state->IfExp_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.IfExp.test);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->test, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.IfExp.body);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.IfExp.orelse);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->orelse, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Dict_kind:
        tp = (PyTypeObject *)state->Dict_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.Dict.keys, ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->keys, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.Dict.values, ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->values, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Set_kind:
        tp = (PyTypeObject *)state->Set_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.Set.elts, ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->elts, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ListComp_kind:
        tp = (PyTypeObject *)state->ListComp_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.ListComp.elt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->elt, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.ListComp.generators,
                             ast2obj_comprehension);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case SetComp_kind:
        tp = (PyTypeObject *)state->SetComp_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.SetComp.elt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->elt, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.SetComp.generators,
                             ast2obj_comprehension);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case DictComp_kind:
        tp = (PyTypeObject *)state->DictComp_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.DictComp.key);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->key, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.DictComp.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.DictComp.generators,
                             ast2obj_comprehension);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case GeneratorExp_kind:
        tp = (PyTypeObject *)state->GeneratorExp_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.GeneratorExp.elt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->elt, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.GeneratorExp.generators,
                             ast2obj_comprehension);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->generators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Await_kind:
        tp = (PyTypeObject *)state->Await_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Await.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Yield_kind:
        tp = (PyTypeObject *)state->Yield_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Yield.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case YieldFrom_kind:
        tp = (PyTypeObject *)state->YieldFrom_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.YieldFrom.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Compare_kind:
        tp = (PyTypeObject *)state->Compare_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Compare.left);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->left, value) == -1)
            goto failed;
        Py_DECREF(value);
        {
            Py_ssize_t i, n = asdl_seq_LEN(o->v.Compare.ops);
            value = PyList_New(n);
            if (!value) goto failed;
            for(i = 0; i < n; i++)
                PyList_SET_ITEM(value, i, ast2obj_cmpop(state, (cmpop_ty)asdl_seq_GET(o->v.Compare.ops, i)));
        }
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->ops, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.Compare.comparators,
                             ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->comparators, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Call_kind:
        tp = (PyTypeObject *)state->Call_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Call.func);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->func, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.Call.args, ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->args, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.Call.keywords,
                             ast2obj_keyword);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->keywords, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case FormattedValue_kind:
        tp = (PyTypeObject *)state->FormattedValue_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.FormattedValue.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_int(state, o->v.FormattedValue.conversion);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->conversion, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.FormattedValue.format_spec);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->format_spec, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Interpolation_kind:
        tp = (PyTypeObject *)state->Interpolation_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Interpolation.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_constant(state, o->v.Interpolation.str);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->str, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_int(state, o->v.Interpolation.conversion);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->conversion, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.Interpolation.format_spec);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->format_spec, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case JoinedStr_kind:
        tp = (PyTypeObject *)state->JoinedStr_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.JoinedStr.values,
                             ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->values, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case TemplateStr_kind:
        tp = (PyTypeObject *)state->TemplateStr_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.TemplateStr.values,
                             ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->values, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Constant_kind:
        tp = (PyTypeObject *)state->Constant_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_constant(state, o->v.Constant.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(state, o->v.Constant.kind);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->kind, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Attribute_kind:
        tp = (PyTypeObject *)state->Attribute_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Attribute.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(state, o->v.Attribute.attr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->attr, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(state, o->v.Attribute.ctx);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Subscript_kind:
        tp = (PyTypeObject *)state->Subscript_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Subscript.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.Subscript.slice);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->slice, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(state, o->v.Subscript.ctx);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Starred_kind:
        tp = (PyTypeObject *)state->Starred_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Starred.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(state, o->v.Starred.ctx);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Name_kind:
        tp = (PyTypeObject *)state->Name_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(state, o->v.Name.id);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->id, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(state, o->v.Name.ctx);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case List_kind:
        tp = (PyTypeObject *)state->List_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.List.elts, ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->elts, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(state, o->v.List.ctx);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Tuple_kind:
        tp = (PyTypeObject *)state->Tuple_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.Tuple.elts, ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->elts, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr_context(state, o->v.Tuple.ctx);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->ctx, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Slice_kind:
        tp = (PyTypeObject *)state->Slice_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.Slice.lower);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->lower, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.Slice.upper);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->upper, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.Slice.step);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->step, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    value = ast2obj_int(state, o->lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject* ast2obj_expr_context(struct ast_state *state, expr_context_ty o)
{
    switch(o) {
        case Load:
            return Py_NewRef(state->Load_singleton);
        case Store:
            return Py_NewRef(state->Store_singleton);
        case Del:
            return Py_NewRef(state->Del_singleton);
    }
    Py_UNREACHABLE();
}
PyObject* ast2obj_boolop(struct ast_state *state, boolop_ty o)
{
    switch(o) {
        case And:
            return Py_NewRef(state->And_singleton);
        case Or:
            return Py_NewRef(state->Or_singleton);
    }
    Py_UNREACHABLE();
}
PyObject* ast2obj_operator(struct ast_state *state, operator_ty o)
{
    switch(o) {
        case Add:
            return Py_NewRef(state->Add_singleton);
        case Sub:
            return Py_NewRef(state->Sub_singleton);
        case Mult:
            return Py_NewRef(state->Mult_singleton);
        case MatMult:
            return Py_NewRef(state->MatMult_singleton);
        case Div:
            return Py_NewRef(state->Div_singleton);
        case Mod:
            return Py_NewRef(state->Mod_singleton);
        case Pow:
            return Py_NewRef(state->Pow_singleton);
        case LShift:
            return Py_NewRef(state->LShift_singleton);
        case RShift:
            return Py_NewRef(state->RShift_singleton);
        case BitOr:
            return Py_NewRef(state->BitOr_singleton);
        case BitXor:
            return Py_NewRef(state->BitXor_singleton);
        case BitAnd:
            return Py_NewRef(state->BitAnd_singleton);
        case FloorDiv:
            return Py_NewRef(state->FloorDiv_singleton);
    }
    Py_UNREACHABLE();
}
PyObject* ast2obj_unaryop(struct ast_state *state, unaryop_ty o)
{
    switch(o) {
        case Invert:
            return Py_NewRef(state->Invert_singleton);
        case Not:
            return Py_NewRef(state->Not_singleton);
        case UAdd:
            return Py_NewRef(state->UAdd_singleton);
        case USub:
            return Py_NewRef(state->USub_singleton);
    }
    Py_UNREACHABLE();
}
PyObject* ast2obj_cmpop(struct ast_state *state, cmpop_ty o)
{
    switch(o) {
        case Eq:
            return Py_NewRef(state->Eq_singleton);
        case NotEq:
            return Py_NewRef(state->NotEq_singleton);
        case Lt:
            return Py_NewRef(state->Lt_singleton);
        case LtE:
            return Py_NewRef(state->LtE_singleton);
        case Gt:
            return Py_NewRef(state->Gt_singleton);
        case GtE:
            return Py_NewRef(state->GtE_singleton);
        case Is:
            return Py_NewRef(state->Is_singleton);
        case IsNot:
            return Py_NewRef(state->IsNot_singleton);
        case In:
            return Py_NewRef(state->In_singleton);
        case NotIn:
            return Py_NewRef(state->NotIn_singleton);
    }
    Py_UNREACHABLE();
}
PyObject*
ast2obj_comprehension(struct ast_state *state, void* _o)
{
    comprehension_ty o = (comprehension_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    tp = (PyTypeObject *)state->comprehension_type;
    result = PyType_GenericNew(tp, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_expr(state, o->target);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->target, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(state, o->iter);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->iter, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(state, (asdl_seq*)o->ifs, ast2obj_expr);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->ifs, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->is_async);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->is_async, value) == -1)
        goto failed;
    Py_DECREF(value);
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_excepthandler(struct ast_state *state, void* _o)
{
    excepthandler_ty o = (excepthandler_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    switch (o->kind) {
    case ExceptHandler_kind:
        tp = (PyTypeObject *)state->ExceptHandler_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.ExceptHandler.type);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->type, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(state, o->v.ExceptHandler.name);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.ExceptHandler.body,
                             ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->body, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    value = ast2obj_int(state, o->lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_arguments(struct ast_state *state, void* _o)
{
    arguments_ty o = (arguments_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    tp = (PyTypeObject *)state->arguments_type;
    result = PyType_GenericNew(tp, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_list(state, (asdl_seq*)o->posonlyargs, ast2obj_arg);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->posonlyargs, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(state, (asdl_seq*)o->args, ast2obj_arg);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->args, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_arg(state, o->vararg);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->vararg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(state, (asdl_seq*)o->kwonlyargs, ast2obj_arg);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->kwonlyargs, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(state, (asdl_seq*)o->kw_defaults, ast2obj_expr);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->kw_defaults, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_arg(state, o->kwarg);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->kwarg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(state, (asdl_seq*)o->defaults, ast2obj_expr);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->defaults, value) == -1)
        goto failed;
    Py_DECREF(value);
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_arg(struct ast_state *state, void* _o)
{
    arg_ty o = (arg_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    tp = (PyTypeObject *)state->arg_type;
    result = PyType_GenericNew(tp, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_identifier(state, o->arg);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->arg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(state, o->annotation);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->annotation, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_string(state, o->type_comment);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->type_comment, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_keyword(struct ast_state *state, void* _o)
{
    keyword_ty o = (keyword_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    tp = (PyTypeObject *)state->keyword_type;
    result = PyType_GenericNew(tp, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_identifier(state, o->arg);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->arg, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(state, o->value);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->value, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_alias(struct ast_state *state, void* _o)
{
    alias_ty o = (alias_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    tp = (PyTypeObject *)state->alias_type;
    result = PyType_GenericNew(tp, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_identifier(state, o->name);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->name, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_identifier(state, o->asname);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->asname, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_withitem(struct ast_state *state, void* _o)
{
    withitem_ty o = (withitem_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    tp = (PyTypeObject *)state->withitem_type;
    result = PyType_GenericNew(tp, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_expr(state, o->context_expr);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->context_expr, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(state, o->optional_vars);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->optional_vars, value) == -1)
        goto failed;
    Py_DECREF(value);
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_match_case(struct ast_state *state, void* _o)
{
    match_case_ty o = (match_case_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    tp = (PyTypeObject *)state->match_case_type;
    result = PyType_GenericNew(tp, NULL, NULL);
    if (!result) return NULL;
    value = ast2obj_pattern(state, o->pattern);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->pattern, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_expr(state, o->guard);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->guard, value) == -1)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_list(state, (asdl_seq*)o->body, ast2obj_stmt);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->body, value) == -1)
        goto failed;
    Py_DECREF(value);
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_pattern(struct ast_state *state, void* _o)
{
    pattern_ty o = (pattern_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    switch (o->kind) {
    case MatchValue_kind:
        tp = (PyTypeObject *)state->MatchValue_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.MatchValue.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case MatchSingleton_kind:
        tp = (PyTypeObject *)state->MatchSingleton_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_constant(state, o->v.MatchSingleton.value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case MatchSequence_kind:
        tp = (PyTypeObject *)state->MatchSequence_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.MatchSequence.patterns,
                             ast2obj_pattern);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->patterns, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case MatchMapping_kind:
        tp = (PyTypeObject *)state->MatchMapping_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.MatchMapping.keys,
                             ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->keys, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.MatchMapping.patterns,
                             ast2obj_pattern);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->patterns, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(state, o->v.MatchMapping.rest);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->rest, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case MatchClass_kind:
        tp = (PyTypeObject *)state->MatchClass_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_expr(state, o->v.MatchClass.cls);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->cls, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.MatchClass.patterns,
                             ast2obj_pattern);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->patterns, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.MatchClass.kwd_attrs,
                             ast2obj_identifier);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->kwd_attrs, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_list(state, (asdl_seq*)o->v.MatchClass.kwd_patterns,
                             ast2obj_pattern);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->kwd_patterns, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case MatchStar_kind:
        tp = (PyTypeObject *)state->MatchStar_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(state, o->v.MatchStar.name);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->name, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case MatchAs_kind:
        tp = (PyTypeObject *)state->MatchAs_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_pattern(state, o->v.MatchAs.pattern);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->pattern, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(state, o->v.MatchAs.name);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->name, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case MatchOr_kind:
        tp = (PyTypeObject *)state->MatchOr_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_list(state, (asdl_seq*)o->v.MatchOr.patterns,
                             ast2obj_pattern);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->patterns, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    value = ast2obj_int(state, o->lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_type_ignore(struct ast_state *state, void* _o)
{
    type_ignore_ty o = (type_ignore_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    switch (o->kind) {
    case TypeIgnore_kind:
        tp = (PyTypeObject *)state->TypeIgnore_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_int(state, o->v.TypeIgnore.lineno);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->lineno, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_string(state, o->v.TypeIgnore.tag);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->tag, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_type_param(struct ast_state *state, void* _o)
{
    type_param_ty o = (type_param_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }
    if (Py_EnterRecursiveCall("during  ast construction")) {
        return NULL;
    }
    switch (o->kind) {
    case TypeVar_kind:
        tp = (PyTypeObject *)state->TypeVar_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(state, o->v.TypeVar.name);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.TypeVar.bound);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->bound, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.TypeVar.default_value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->default_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case ParamSpec_kind:
        tp = (PyTypeObject *)state->ParamSpec_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(state, o->v.ParamSpec.name);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.ParamSpec.default_value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->default_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case TypeVarTuple_kind:
        tp = (PyTypeObject *)state->TypeVarTuple_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(state, o->v.TypeVarTuple.name);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->name, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(state, o->v.TypeVarTuple.default_value);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, state->default_value, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    value = ast2obj_int(state, o->lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_lineno);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_lineno, value) < 0)
        goto failed;
    Py_DECREF(value);
    value = ast2obj_int(state, o->end_col_offset);
    if (!value) goto failed;
    if (PyObject_SetAttr(result, state->end_col_offset, value) < 0)
        goto failed;
    Py_DECREF(value);
    Py_LeaveRecursiveCall();
    return result;
failed:
    Py_LeaveRecursiveCall();
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}


static int obj2imm_int_seq(struct ast_state *state, PyObject* obj, const char
                           *container, const char *field, asdl_int_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_int_seq_type) {
        *out = (asdl_int_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_int_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_int_seq, (PyTypeObject *)state->_int_seq_type,
                          len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        int val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'int' node")) {
            goto failed;
        }
        int err = obj2imm_int(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

static int obj2imm_identifier_seq(struct ast_state *state, PyObject* obj, const
                                  char *container, const char *field,
                                  asdl_identifier_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_identifier_seq_type) {
        *out = (asdl_identifier_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_identifier_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_identifier_seq, (PyTypeObject
                          *)state->_identifier_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        identifier val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'identifier' node")) {
            goto failed;
        }
        int err = obj2imm_identifier(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

static int obj2imm_mod_seq(struct ast_state *state, PyObject* obj, const char
                           *container, const char *field, asdl_mod_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_mod_seq_type) {
        *out = (asdl_mod_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_mod_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_mod_seq, (PyTypeObject *)state->_mod_seq_type,
                          len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        mod_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'mod' node")) {
            goto failed;
        }
        int err = obj2imm_mod(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_mod(struct ast_state *state, PyObject* obj, mod_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    PyObject *tp;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    tp = state->Module_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_stmt_seq* body = NULL;
        asdl_type_ignore_seq* type_ignores = NULL;

        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Module field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Module' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Module field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_ignores, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Module field \"type_ignores\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            type_ignores = _Py_asdl_type_ignore_seq_new(len, arena);
            if (type_ignores == NULL) goto failed;
            for (i = 0; i < len; i++) {
                type_ignore_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Module' node")) {
                    goto failed;
                }
                res = obj2ast_type_ignore(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Module field \"type_ignores\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(type_ignores, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Module(body, type_ignores, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Interactive_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_stmt_seq* body = NULL;

        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Interactive field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Interactive' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Interactive field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Interactive(body, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Expression_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty body = NULL;

        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"body\" missing from Expression");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Expression' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &body, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Expression(body, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->FunctionType_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* argtypes = NULL;
        expr_ty returns = NULL;

        if (PyObject_GetOptionalAttr(obj, state->argtypes, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "FunctionType field \"argtypes\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            argtypes = _Py_asdl_expr_seq_new(len, arena);
            if (argtypes == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'FunctionType' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "FunctionType field \"argtypes\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(argtypes, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->returns, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"returns\" missing from FunctionType");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionType' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &returns, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_FunctionType(argtypes, returns, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of mod, but got %R", obj);
    failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_mod(struct ast_state *state, PyObject* obj, mod_ty* out)
{
    int isinstance;

    PyObject *tp;
    PyObject *tmp = NULL;
    if (Py_TYPE(obj) == (PyTypeObject *)state->_Module_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Interactive_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Expression_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_FunctionType_type) {
        *out = (mod_ty)Py_NewRef(obj);
        return 0;
    }
    tp = state->_Module_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_stmt_seq* body = NULL;
        asdl_type_ignore_seq* type_ignores = NULL;

        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Module' node")) {
                goto failed_Module;
            }
            res = obj2imm_stmt_seq(state, tmp, "Module", "body", &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Module;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_ignores, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Module' node")) {
                goto failed_Module;
            }
            res = obj2imm_type_ignore_seq(state, tmp, "Module", "type_ignores",
                                          &type_ignores);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Module;
            Py_CLEAR(tmp);
        }
        mod_ty res = (mod_ty)_PyObject_New((PyTypeObject *)state->_Module_type);
        if (res == NULL) goto failed_Module;
        res->kind = Module_kind;
        res->v.Module.body = body;
        res->v.Module.type_ignores = type_ignores;
        *out = res;
        return 0;
        failed_Module:
        Py_XDECREF(body);
        Py_XDECREF(type_ignores);
    }
    tp = state->_Interactive_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_stmt_seq* body = NULL;

        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Interactive' node")) {
                goto failed_Interactive;
            }
            res = obj2imm_stmt_seq(state, tmp, "Interactive", "body", &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Interactive;
            Py_CLEAR(tmp);
        }
        mod_ty res = (mod_ty)_PyObject_New((PyTypeObject
                      *)state->_Interactive_type);
        if (res == NULL) goto failed_Interactive;
        res->kind = Interactive_kind;
        res->v.Interactive.body = body;
        *out = res;
        return 0;
        failed_Interactive:
        Py_XDECREF(body);
    }
    tp = state->_Expression_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty body = NULL;

        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"body\" missing from Expression");
            goto failed_Expression;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Expression' node")) {
                goto failed_Expression;
            }
            res = obj2imm_expr(state, tmp, &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Expression;
            Py_CLEAR(tmp);
        }
        mod_ty res = (mod_ty)_PyObject_New((PyTypeObject
                      *)state->_Expression_type);
        if (res == NULL) goto failed_Expression;
        res->kind = Expression_kind;
        res->v.Expression.body = body;
        *out = res;
        return 0;
        failed_Expression:
        Py_XDECREF(body);
    }
    tp = state->_FunctionType_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* argtypes = NULL;
        expr_ty returns = NULL;

        if (PyObject_GetOptionalAttr(obj, state->argtypes, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionType' node")) {
                goto failed_FunctionType;
            }
            res = obj2imm_expr_seq(state, tmp, "FunctionType", "argtypes",
                                   &argtypes);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_FunctionType;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->returns, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"returns\" missing from FunctionType");
            goto failed_FunctionType;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionType' node")) {
                goto failed_FunctionType;
            }
            res = obj2imm_expr(state, tmp, &returns);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_FunctionType;
            Py_CLEAR(tmp);
        }
        mod_ty res = (mod_ty)_PyObject_New((PyTypeObject
                      *)state->_FunctionType_type);
        if (res == NULL) goto failed_FunctionType;
        res->kind = FunctionType_kind;
        res->v.FunctionType.argtypes = argtypes;
        res->v.FunctionType.returns = returns;
        *out = res;
        return 0;
        failed_FunctionType:
        Py_XDECREF(argtypes);
        Py_XDECREF(returns);
    }
    *out = (mod_ty)Py_NewRef(obj);
    return 0;
}

static int obj2imm_stmt_seq(struct ast_state *state, PyObject* obj, const char
                            *container, const char *field, asdl_stmt_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_stmt_seq_type) {
        *out = (asdl_stmt_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_stmt_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_stmt_seq, (PyTypeObject *)state->_stmt_seq_type,
                          len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        stmt_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'stmt' node")) {
            goto failed;
        }
        int err = obj2imm_stmt(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_stmt(struct ast_state *state, PyObject* obj, stmt_ty* out, PyArena*
             arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    PyObject *tp;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from stmt");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'stmt' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from stmt");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'stmt' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_lineno = lineno;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'stmt' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_col_offset = col_offset;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'stmt' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    tp = state->FunctionDef_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;
        arguments_ty args = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_expr_seq* decorator_list = NULL;
        expr_ty returns = NULL;
        string type_comment;
        asdl_type_param_seq* type_params = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from FunctionDef");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                goto failed;
            }
            res = obj2ast_identifier(state, tmp, &name, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->args, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"args\" missing from FunctionDef");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                goto failed;
            }
            res = obj2ast_arguments(state, tmp, &args, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "FunctionDef field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "FunctionDef field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->decorator_list, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "FunctionDef field \"decorator_list\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            decorator_list = _Py_asdl_expr_seq_new(len, arena);
            if (decorator_list == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "FunctionDef field \"decorator_list\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(decorator_list, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->returns, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            returns = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &returns, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                goto failed;
            }
            res = obj2ast_string(state, tmp, &type_comment, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_params, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "FunctionDef field \"type_params\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            type_params = _Py_asdl_type_param_seq_new(len, arena);
            if (type_params == NULL) goto failed;
            for (i = 0; i < len; i++) {
                type_param_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                    goto failed;
                }
                res = obj2ast_type_param(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "FunctionDef field \"type_params\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(type_params, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_FunctionDef(name, args, body, decorator_list, returns,
                                  type_comment, type_params, lineno,
                                  col_offset, end_lineno, end_col_offset,
                                  arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->AsyncFunctionDef_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;
        arguments_ty args = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_expr_seq* decorator_list = NULL;
        expr_ty returns = NULL;
        string type_comment;
        asdl_type_param_seq* type_params = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from AsyncFunctionDef");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                goto failed;
            }
            res = obj2ast_identifier(state, tmp, &name, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->args, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"args\" missing from AsyncFunctionDef");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                goto failed;
            }
            res = obj2ast_arguments(state, tmp, &args, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "AsyncFunctionDef field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "AsyncFunctionDef field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->decorator_list, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "AsyncFunctionDef field \"decorator_list\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            decorator_list = _Py_asdl_expr_seq_new(len, arena);
            if (decorator_list == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "AsyncFunctionDef field \"decorator_list\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(decorator_list, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->returns, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            returns = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &returns, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                goto failed;
            }
            res = obj2ast_string(state, tmp, &type_comment, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_params, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "AsyncFunctionDef field \"type_params\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            type_params = _Py_asdl_type_param_seq_new(len, arena);
            if (type_params == NULL) goto failed;
            for (i = 0; i < len; i++) {
                type_param_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                    goto failed;
                }
                res = obj2ast_type_param(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "AsyncFunctionDef field \"type_params\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(type_params, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_AsyncFunctionDef(name, args, body, decorator_list,
                                       returns, type_comment, type_params,
                                       lineno, col_offset, end_lineno,
                                       end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->ClassDef_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;
        asdl_expr_seq* bases = NULL;
        asdl_keyword_seq* keywords = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_expr_seq* decorator_list = NULL;
        asdl_type_param_seq* type_params = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from ClassDef");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ClassDef' node")) {
                goto failed;
            }
            res = obj2ast_identifier(state, tmp, &name, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->bases, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "ClassDef field \"bases\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            bases = _Py_asdl_expr_seq_new(len, arena);
            if (bases == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'ClassDef' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "ClassDef field \"bases\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(bases, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->keywords, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "ClassDef field \"keywords\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            keywords = _Py_asdl_keyword_seq_new(len, arena);
            if (keywords == NULL) goto failed;
            for (i = 0; i < len; i++) {
                keyword_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'ClassDef' node")) {
                    goto failed;
                }
                res = obj2ast_keyword(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "ClassDef field \"keywords\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(keywords, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "ClassDef field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'ClassDef' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "ClassDef field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->decorator_list, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "ClassDef field \"decorator_list\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            decorator_list = _Py_asdl_expr_seq_new(len, arena);
            if (decorator_list == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'ClassDef' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "ClassDef field \"decorator_list\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(decorator_list, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_params, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "ClassDef field \"type_params\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            type_params = _Py_asdl_type_param_seq_new(len, arena);
            if (type_params == NULL) goto failed;
            for (i = 0; i < len; i++) {
                type_param_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'ClassDef' node")) {
                    goto failed;
                }
                res = obj2ast_type_param(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "ClassDef field \"type_params\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(type_params, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_ClassDef(name, bases, keywords, body, decorator_list,
                               type_params, lineno, col_offset, end_lineno,
                               end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Return_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            value = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Return' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Return(value, lineno, col_offset, end_lineno,
                             end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Delete_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* targets = NULL;

        if (PyObject_GetOptionalAttr(obj, state->targets, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Delete field \"targets\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            targets = _Py_asdl_expr_seq_new(len, arena);
            if (targets == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Delete' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Delete field \"targets\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(targets, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Delete(targets, lineno, col_offset, end_lineno,
                             end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Assign_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* targets = NULL;
        expr_ty value = NULL;
        string type_comment;

        if (PyObject_GetOptionalAttr(obj, state->targets, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Assign field \"targets\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            targets = _Py_asdl_expr_seq_new(len, arena);
            if (targets == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Assign' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Assign field \"targets\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(targets, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Assign");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Assign' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Assign' node")) {
                goto failed;
            }
            res = obj2ast_string(state, tmp, &type_comment, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Assign(targets, value, type_comment, lineno, col_offset,
                             end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->TypeAlias_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty name = NULL;
        asdl_type_param_seq* type_params = NULL;
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from TypeAlias");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeAlias' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &name, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_params, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "TypeAlias field \"type_params\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            type_params = _Py_asdl_type_param_seq_new(len, arena);
            if (type_params == NULL) goto failed;
            for (i = 0; i < len; i++) {
                type_param_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'TypeAlias' node")) {
                    goto failed;
                }
                res = obj2ast_type_param(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "TypeAlias field \"type_params\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(type_params, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from TypeAlias");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeAlias' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_TypeAlias(name, type_params, value, lineno, col_offset,
                                end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->AugAssign_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty target = NULL;
        operator_ty op;
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->target, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"target\" missing from AugAssign");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AugAssign' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &target, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->op, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"op\" missing from AugAssign");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AugAssign' node")) {
                goto failed;
            }
            res = obj2ast_operator(state, tmp, &op, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from AugAssign");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AugAssign' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_AugAssign(target, op, value, lineno, col_offset,
                                end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->AnnAssign_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty target = NULL;
        expr_ty annotation = NULL;
        expr_ty value = NULL;
        int simple;

        if (PyObject_GetOptionalAttr(obj, state->target, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"target\" missing from AnnAssign");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AnnAssign' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &target, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->annotation, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"annotation\" missing from AnnAssign");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AnnAssign' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &annotation, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            value = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AnnAssign' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->simple, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"simple\" missing from AnnAssign");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AnnAssign' node")) {
                goto failed;
            }
            res = obj2ast_int(state, tmp, &simple, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_AnnAssign(target, annotation, value, simple, lineno,
                                col_offset, end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->For_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty target = NULL;
        expr_ty iter = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_stmt_seq* orelse = NULL;
        string type_comment;

        if (PyObject_GetOptionalAttr(obj, state->target, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"target\" missing from For");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'For' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &target, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->iter, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"iter\" missing from For");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'For' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &iter, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "For field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'For' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "For field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "For field \"orelse\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            orelse = _Py_asdl_stmt_seq_new(len, arena);
            if (orelse == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'For' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "For field \"orelse\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(orelse, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'For' node")) {
                goto failed;
            }
            res = obj2ast_string(state, tmp, &type_comment, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_For(target, iter, body, orelse, type_comment, lineno,
                          col_offset, end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->AsyncFor_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty target = NULL;
        expr_ty iter = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_stmt_seq* orelse = NULL;
        string type_comment;

        if (PyObject_GetOptionalAttr(obj, state->target, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"target\" missing from AsyncFor");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFor' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &target, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->iter, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"iter\" missing from AsyncFor");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFor' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &iter, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "AsyncFor field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'AsyncFor' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "AsyncFor field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "AsyncFor field \"orelse\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            orelse = _Py_asdl_stmt_seq_new(len, arena);
            if (orelse == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'AsyncFor' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "AsyncFor field \"orelse\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(orelse, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFor' node")) {
                goto failed;
            }
            res = obj2ast_string(state, tmp, &type_comment, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_AsyncFor(target, iter, body, orelse, type_comment,
                               lineno, col_offset, end_lineno, end_col_offset,
                               arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->While_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty test = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_stmt_seq* orelse = NULL;

        if (PyObject_GetOptionalAttr(obj, state->test, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"test\" missing from While");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'While' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &test, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "While field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'While' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "While field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "While field \"orelse\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            orelse = _Py_asdl_stmt_seq_new(len, arena);
            if (orelse == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'While' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "While field \"orelse\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(orelse, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_While(test, body, orelse, lineno, col_offset, end_lineno,
                            end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->If_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty test = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_stmt_seq* orelse = NULL;

        if (PyObject_GetOptionalAttr(obj, state->test, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"test\" missing from If");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'If' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &test, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "If field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'If' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "If field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "If field \"orelse\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            orelse = _Py_asdl_stmt_seq_new(len, arena);
            if (orelse == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'If' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "If field \"orelse\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(orelse, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_If(test, body, orelse, lineno, col_offset, end_lineno,
                         end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->With_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_withitem_seq* items = NULL;
        asdl_stmt_seq* body = NULL;
        string type_comment;

        if (PyObject_GetOptionalAttr(obj, state->items, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "With field \"items\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            items = _Py_asdl_withitem_seq_new(len, arena);
            if (items == NULL) goto failed;
            for (i = 0; i < len; i++) {
                withitem_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'With' node")) {
                    goto failed;
                }
                res = obj2ast_withitem(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "With field \"items\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(items, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "With field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'With' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "With field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'With' node")) {
                goto failed;
            }
            res = obj2ast_string(state, tmp, &type_comment, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_With(items, body, type_comment, lineno, col_offset,
                           end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->AsyncWith_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_withitem_seq* items = NULL;
        asdl_stmt_seq* body = NULL;
        string type_comment;

        if (PyObject_GetOptionalAttr(obj, state->items, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "AsyncWith field \"items\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            items = _Py_asdl_withitem_seq_new(len, arena);
            if (items == NULL) goto failed;
            for (i = 0; i < len; i++) {
                withitem_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'AsyncWith' node")) {
                    goto failed;
                }
                res = obj2ast_withitem(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "AsyncWith field \"items\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(items, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "AsyncWith field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'AsyncWith' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "AsyncWith field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncWith' node")) {
                goto failed;
            }
            res = obj2ast_string(state, tmp, &type_comment, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_AsyncWith(items, body, type_comment, lineno, col_offset,
                                end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Match_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty subject = NULL;
        asdl_match_case_seq* cases = NULL;

        if (PyObject_GetOptionalAttr(obj, state->subject, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"subject\" missing from Match");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Match' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &subject, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->cases, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Match field \"cases\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            cases = _Py_asdl_match_case_seq_new(len, arena);
            if (cases == NULL) goto failed;
            for (i = 0; i < len; i++) {
                match_case_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Match' node")) {
                    goto failed;
                }
                res = obj2ast_match_case(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Match field \"cases\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(cases, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Match(subject, cases, lineno, col_offset, end_lineno,
                            end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Raise_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty exc = NULL;
        expr_ty cause = NULL;

        if (PyObject_GetOptionalAttr(obj, state->exc, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            exc = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Raise' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &exc, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->cause, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            cause = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Raise' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &cause, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Raise(exc, cause, lineno, col_offset, end_lineno,
                            end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Try_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_stmt_seq* body = NULL;
        asdl_excepthandler_seq* handlers = NULL;
        asdl_stmt_seq* orelse = NULL;
        asdl_stmt_seq* finalbody = NULL;

        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Try field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Try' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Try field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->handlers, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Try field \"handlers\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            handlers = _Py_asdl_excepthandler_seq_new(len, arena);
            if (handlers == NULL) goto failed;
            for (i = 0; i < len; i++) {
                excepthandler_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Try' node")) {
                    goto failed;
                }
                res = obj2ast_excepthandler(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Try field \"handlers\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(handlers, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Try field \"orelse\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            orelse = _Py_asdl_stmt_seq_new(len, arena);
            if (orelse == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Try' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Try field \"orelse\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(orelse, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->finalbody, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Try field \"finalbody\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            finalbody = _Py_asdl_stmt_seq_new(len, arena);
            if (finalbody == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Try' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Try field \"finalbody\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(finalbody, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Try(body, handlers, orelse, finalbody, lineno,
                          col_offset, end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->TryStar_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_stmt_seq* body = NULL;
        asdl_excepthandler_seq* handlers = NULL;
        asdl_stmt_seq* orelse = NULL;
        asdl_stmt_seq* finalbody = NULL;

        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "TryStar field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'TryStar' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "TryStar field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->handlers, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "TryStar field \"handlers\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            handlers = _Py_asdl_excepthandler_seq_new(len, arena);
            if (handlers == NULL) goto failed;
            for (i = 0; i < len; i++) {
                excepthandler_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'TryStar' node")) {
                    goto failed;
                }
                res = obj2ast_excepthandler(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "TryStar field \"handlers\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(handlers, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "TryStar field \"orelse\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            orelse = _Py_asdl_stmt_seq_new(len, arena);
            if (orelse == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'TryStar' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "TryStar field \"orelse\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(orelse, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->finalbody, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "TryStar field \"finalbody\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            finalbody = _Py_asdl_stmt_seq_new(len, arena);
            if (finalbody == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'TryStar' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "TryStar field \"finalbody\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(finalbody, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_TryStar(body, handlers, orelse, finalbody, lineno,
                              col_offset, end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Assert_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty test = NULL;
        expr_ty msg = NULL;

        if (PyObject_GetOptionalAttr(obj, state->test, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"test\" missing from Assert");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Assert' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &test, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->msg, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            msg = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Assert' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &msg, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Assert(test, msg, lineno, col_offset, end_lineno,
                             end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Import_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_alias_seq* names = NULL;

        if (PyObject_GetOptionalAttr(obj, state->names, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Import field \"names\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            names = _Py_asdl_alias_seq_new(len, arena);
            if (names == NULL) goto failed;
            for (i = 0; i < len; i++) {
                alias_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Import' node")) {
                    goto failed;
                }
                res = obj2ast_alias(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Import field \"names\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(names, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Import(names, lineno, col_offset, end_lineno,
                             end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->ImportFrom_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier module = NULL;
        asdl_alias_seq* names = NULL;
        int level;

        if (PyObject_GetOptionalAttr(obj, state->module, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            module = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ImportFrom' node")) {
                goto failed;
            }
            res = obj2ast_identifier(state, tmp, &module, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->names, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "ImportFrom field \"names\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            names = _Py_asdl_alias_seq_new(len, arena);
            if (names == NULL) goto failed;
            for (i = 0; i < len; i++) {
                alias_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'ImportFrom' node")) {
                    goto failed;
                }
                res = obj2ast_alias(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "ImportFrom field \"names\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(names, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->level, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            level = 0;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ImportFrom' node")) {
                goto failed;
            }
            res = obj2ast_int(state, tmp, &level, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_ImportFrom(module, names, level, lineno, col_offset,
                                 end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Global_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_identifier_seq* names = NULL;

        if (PyObject_GetOptionalAttr(obj, state->names, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Global field \"names\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            names = _Py_asdl_identifier_seq_new(len, arena);
            if (names == NULL) goto failed;
            for (i = 0; i < len; i++) {
                identifier val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Global' node")) {
                    goto failed;
                }
                res = obj2ast_identifier(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Global field \"names\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(names, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Global(names, lineno, col_offset, end_lineno,
                             end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Nonlocal_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_identifier_seq* names = NULL;

        if (PyObject_GetOptionalAttr(obj, state->names, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Nonlocal field \"names\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            names = _Py_asdl_identifier_seq_new(len, arena);
            if (names == NULL) goto failed;
            for (i = 0; i < len; i++) {
                identifier val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Nonlocal' node")) {
                    goto failed;
                }
                res = obj2ast_identifier(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Nonlocal field \"names\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(names, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Nonlocal(names, lineno, col_offset, end_lineno,
                               end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Expr_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Expr");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Expr' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Expr(value, lineno, col_offset, end_lineno,
                           end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Pass_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {

        *out = _PyAST_Pass(lineno, col_offset, end_lineno, end_col_offset,
                           arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Break_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {

        *out = _PyAST_Break(lineno, col_offset, end_lineno, end_col_offset,
                            arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Continue_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {

        *out = _PyAST_Continue(lineno, col_offset, end_lineno, end_col_offset,
                               arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of stmt, but got %R", obj);
    failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_stmt(struct ast_state *state, PyObject* obj, stmt_ty* out)
{
    int isinstance;

    PyObject *tp;
    PyObject *tmp = NULL;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;
    if (Py_TYPE(obj) == (PyTypeObject *)state->_FunctionDef_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_AsyncFunctionDef_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_ClassDef_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Return_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Delete_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Assign_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_TypeAlias_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_AugAssign_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_AnnAssign_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_For_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_AsyncFor_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_While_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_If_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_With_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_AsyncWith_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Match_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Raise_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Try_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_TryStar_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Assert_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Import_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_ImportFrom_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Global_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Nonlocal_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Expr_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Pass_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Break_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Continue_type) {
        *out = (stmt_ty)Py_NewRef(obj);
        return 0;
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from stmt");
        goto failed_stmt;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'stmt' node")) {
            goto failed_stmt;
        }
        res = obj2imm_int(state, tmp, &lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_stmt;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from stmt");
        goto failed_stmt;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'stmt' node")) {
            goto failed_stmt;
        }
        res = obj2imm_int(state, tmp, &col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_stmt;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_lineno = lineno;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'stmt' node")) {
            goto failed_stmt;
        }
        res = obj2imm_int(state, tmp, &end_lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_stmt;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_col_offset = col_offset;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'stmt' node")) {
            goto failed_stmt;
        }
        res = obj2imm_int(state, tmp, &end_col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_stmt;
        Py_CLEAR(tmp);
    }
    tp = state->_FunctionDef_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;
        arguments_ty args = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_expr_seq* decorator_list = NULL;
        expr_ty returns = NULL;
        string type_comment;
        asdl_type_param_seq* type_params = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from FunctionDef");
            goto failed_FunctionDef;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                goto failed_FunctionDef;
            }
            res = obj2imm_identifier(state, tmp, &name);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_FunctionDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->args, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"args\" missing from FunctionDef");
            goto failed_FunctionDef;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                goto failed_FunctionDef;
            }
            res = obj2imm_arguments(state, tmp, &args);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_FunctionDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                goto failed_FunctionDef;
            }
            res = obj2imm_stmt_seq(state, tmp, "FunctionDef", "body", &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_FunctionDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->decorator_list, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                goto failed_FunctionDef;
            }
            res = obj2imm_expr_seq(state, tmp, "FunctionDef", "decorator_list",
                                   &decorator_list);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_FunctionDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->returns, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            returns = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                goto failed_FunctionDef;
            }
            res = obj2imm_expr(state, tmp, &returns);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_FunctionDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                goto failed_FunctionDef;
            }
            res = obj2imm_string(state, tmp, &type_comment);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_FunctionDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_params, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FunctionDef' node")) {
                goto failed_FunctionDef;
            }
            res = obj2imm_type_param_seq(state, tmp, "FunctionDef",
                                         "type_params", &type_params);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_FunctionDef;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_FunctionDef_type);
        if (res == NULL) goto failed_FunctionDef;
        res->kind = FunctionDef_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.FunctionDef.name = name;
        res->v.FunctionDef.args = args;
        res->v.FunctionDef.body = body;
        res->v.FunctionDef.decorator_list = decorator_list;
        res->v.FunctionDef.returns = returns;
        res->v.FunctionDef.type_comment = type_comment;
        res->v.FunctionDef.type_params = type_params;
        *out = res;
        return 0;
        failed_FunctionDef:
        Py_XDECREF(name);
        Py_XDECREF(args);
        Py_XDECREF(body);
        Py_XDECREF(decorator_list);
        Py_XDECREF(returns);
        Py_XDECREF(type_params);
    }
    tp = state->_AsyncFunctionDef_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;
        arguments_ty args = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_expr_seq* decorator_list = NULL;
        expr_ty returns = NULL;
        string type_comment;
        asdl_type_param_seq* type_params = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from AsyncFunctionDef");
            goto failed_AsyncFunctionDef;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                goto failed_AsyncFunctionDef;
            }
            res = obj2imm_identifier(state, tmp, &name);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncFunctionDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->args, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"args\" missing from AsyncFunctionDef");
            goto failed_AsyncFunctionDef;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                goto failed_AsyncFunctionDef;
            }
            res = obj2imm_arguments(state, tmp, &args);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncFunctionDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                goto failed_AsyncFunctionDef;
            }
            res = obj2imm_stmt_seq(state, tmp, "AsyncFunctionDef", "body",
                                   &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncFunctionDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->decorator_list, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                goto failed_AsyncFunctionDef;
            }
            res = obj2imm_expr_seq(state, tmp, "AsyncFunctionDef",
                                   "decorator_list", &decorator_list);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncFunctionDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->returns, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            returns = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                goto failed_AsyncFunctionDef;
            }
            res = obj2imm_expr(state, tmp, &returns);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncFunctionDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                goto failed_AsyncFunctionDef;
            }
            res = obj2imm_string(state, tmp, &type_comment);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncFunctionDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_params, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFunctionDef' node")) {
                goto failed_AsyncFunctionDef;
            }
            res = obj2imm_type_param_seq(state, tmp, "AsyncFunctionDef",
                                         "type_params", &type_params);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncFunctionDef;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_AsyncFunctionDef_type);
        if (res == NULL) goto failed_AsyncFunctionDef;
        res->kind = AsyncFunctionDef_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.AsyncFunctionDef.name = name;
        res->v.AsyncFunctionDef.args = args;
        res->v.AsyncFunctionDef.body = body;
        res->v.AsyncFunctionDef.decorator_list = decorator_list;
        res->v.AsyncFunctionDef.returns = returns;
        res->v.AsyncFunctionDef.type_comment = type_comment;
        res->v.AsyncFunctionDef.type_params = type_params;
        *out = res;
        return 0;
        failed_AsyncFunctionDef:
        Py_XDECREF(name);
        Py_XDECREF(args);
        Py_XDECREF(body);
        Py_XDECREF(decorator_list);
        Py_XDECREF(returns);
        Py_XDECREF(type_params);
    }
    tp = state->_ClassDef_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;
        asdl_expr_seq* bases = NULL;
        asdl_keyword_seq* keywords = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_expr_seq* decorator_list = NULL;
        asdl_type_param_seq* type_params = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from ClassDef");
            goto failed_ClassDef;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ClassDef' node")) {
                goto failed_ClassDef;
            }
            res = obj2imm_identifier(state, tmp, &name);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ClassDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->bases, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ClassDef' node")) {
                goto failed_ClassDef;
            }
            res = obj2imm_expr_seq(state, tmp, "ClassDef", "bases", &bases);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ClassDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->keywords, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ClassDef' node")) {
                goto failed_ClassDef;
            }
            res = obj2imm_keyword_seq(state, tmp, "ClassDef", "keywords",
                                      &keywords);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ClassDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ClassDef' node")) {
                goto failed_ClassDef;
            }
            res = obj2imm_stmt_seq(state, tmp, "ClassDef", "body", &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ClassDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->decorator_list, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ClassDef' node")) {
                goto failed_ClassDef;
            }
            res = obj2imm_expr_seq(state, tmp, "ClassDef", "decorator_list",
                                   &decorator_list);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ClassDef;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_params, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ClassDef' node")) {
                goto failed_ClassDef;
            }
            res = obj2imm_type_param_seq(state, tmp, "ClassDef", "type_params",
                                         &type_params);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ClassDef;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_ClassDef_type);
        if (res == NULL) goto failed_ClassDef;
        res->kind = ClassDef_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.ClassDef.name = name;
        res->v.ClassDef.bases = bases;
        res->v.ClassDef.keywords = keywords;
        res->v.ClassDef.body = body;
        res->v.ClassDef.decorator_list = decorator_list;
        res->v.ClassDef.type_params = type_params;
        *out = res;
        return 0;
        failed_ClassDef:
        Py_XDECREF(name);
        Py_XDECREF(bases);
        Py_XDECREF(keywords);
        Py_XDECREF(body);
        Py_XDECREF(decorator_list);
        Py_XDECREF(type_params);
    }
    tp = state->_Return_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            value = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Return' node")) {
                goto failed_Return;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Return;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_Return_type);
        if (res == NULL) goto failed_Return;
        res->kind = Return_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Return.value = value;
        *out = res;
        return 0;
        failed_Return:
        Py_XDECREF(value);
    }
    tp = state->_Delete_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* targets = NULL;

        if (PyObject_GetOptionalAttr(obj, state->targets, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Delete' node")) {
                goto failed_Delete;
            }
            res = obj2imm_expr_seq(state, tmp, "Delete", "targets", &targets);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Delete;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_Delete_type);
        if (res == NULL) goto failed_Delete;
        res->kind = Delete_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Delete.targets = targets;
        *out = res;
        return 0;
        failed_Delete:
        Py_XDECREF(targets);
    }
    tp = state->_Assign_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* targets = NULL;
        expr_ty value = NULL;
        string type_comment;

        if (PyObject_GetOptionalAttr(obj, state->targets, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Assign' node")) {
                goto failed_Assign;
            }
            res = obj2imm_expr_seq(state, tmp, "Assign", "targets", &targets);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Assign;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Assign");
            goto failed_Assign;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Assign' node")) {
                goto failed_Assign;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Assign;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Assign' node")) {
                goto failed_Assign;
            }
            res = obj2imm_string(state, tmp, &type_comment);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Assign;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_Assign_type);
        if (res == NULL) goto failed_Assign;
        res->kind = Assign_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Assign.targets = targets;
        res->v.Assign.value = value;
        res->v.Assign.type_comment = type_comment;
        *out = res;
        return 0;
        failed_Assign:
        Py_XDECREF(targets);
        Py_XDECREF(value);
    }
    tp = state->_TypeAlias_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty name = NULL;
        asdl_type_param_seq* type_params = NULL;
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from TypeAlias");
            goto failed_TypeAlias;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeAlias' node")) {
                goto failed_TypeAlias;
            }
            res = obj2imm_expr(state, tmp, &name);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TypeAlias;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_params, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeAlias' node")) {
                goto failed_TypeAlias;
            }
            res = obj2imm_type_param_seq(state, tmp, "TypeAlias",
                                         "type_params", &type_params);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TypeAlias;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from TypeAlias");
            goto failed_TypeAlias;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeAlias' node")) {
                goto failed_TypeAlias;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TypeAlias;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_TypeAlias_type);
        if (res == NULL) goto failed_TypeAlias;
        res->kind = TypeAlias_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.TypeAlias.name = name;
        res->v.TypeAlias.type_params = type_params;
        res->v.TypeAlias.value = value;
        *out = res;
        return 0;
        failed_TypeAlias:
        Py_XDECREF(name);
        Py_XDECREF(type_params);
        Py_XDECREF(value);
    }
    tp = state->_AugAssign_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty target = NULL;
        operator_ty op;
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->target, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"target\" missing from AugAssign");
            goto failed_AugAssign;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AugAssign' node")) {
                goto failed_AugAssign;
            }
            res = obj2imm_expr(state, tmp, &target);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AugAssign;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->op, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"op\" missing from AugAssign");
            goto failed_AugAssign;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AugAssign' node")) {
                goto failed_AugAssign;
            }
            res = obj2imm_operator(state, tmp, &op);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AugAssign;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from AugAssign");
            goto failed_AugAssign;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AugAssign' node")) {
                goto failed_AugAssign;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AugAssign;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_AugAssign_type);
        if (res == NULL) goto failed_AugAssign;
        res->kind = AugAssign_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.AugAssign.target = target;
        res->v.AugAssign.op = op;
        res->v.AugAssign.value = value;
        *out = res;
        return 0;
        failed_AugAssign:
        Py_XDECREF(target);
        Py_XDECREF(value);
    }
    tp = state->_AnnAssign_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty target = NULL;
        expr_ty annotation = NULL;
        expr_ty value = NULL;
        int simple;

        if (PyObject_GetOptionalAttr(obj, state->target, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"target\" missing from AnnAssign");
            goto failed_AnnAssign;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AnnAssign' node")) {
                goto failed_AnnAssign;
            }
            res = obj2imm_expr(state, tmp, &target);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AnnAssign;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->annotation, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"annotation\" missing from AnnAssign");
            goto failed_AnnAssign;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AnnAssign' node")) {
                goto failed_AnnAssign;
            }
            res = obj2imm_expr(state, tmp, &annotation);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AnnAssign;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            value = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AnnAssign' node")) {
                goto failed_AnnAssign;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AnnAssign;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->simple, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"simple\" missing from AnnAssign");
            goto failed_AnnAssign;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AnnAssign' node")) {
                goto failed_AnnAssign;
            }
            res = obj2imm_int(state, tmp, &simple);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AnnAssign;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_AnnAssign_type);
        if (res == NULL) goto failed_AnnAssign;
        res->kind = AnnAssign_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.AnnAssign.target = target;
        res->v.AnnAssign.annotation = annotation;
        res->v.AnnAssign.value = value;
        res->v.AnnAssign.simple = simple;
        *out = res;
        return 0;
        failed_AnnAssign:
        Py_XDECREF(target);
        Py_XDECREF(annotation);
        Py_XDECREF(value);
    }
    tp = state->_For_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty target = NULL;
        expr_ty iter = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_stmt_seq* orelse = NULL;
        string type_comment;

        if (PyObject_GetOptionalAttr(obj, state->target, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"target\" missing from For");
            goto failed_For;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'For' node")) {
                goto failed_For;
            }
            res = obj2imm_expr(state, tmp, &target);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_For;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->iter, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"iter\" missing from For");
            goto failed_For;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'For' node")) {
                goto failed_For;
            }
            res = obj2imm_expr(state, tmp, &iter);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_For;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'For' node")) {
                goto failed_For;
            }
            res = obj2imm_stmt_seq(state, tmp, "For", "body", &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_For;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'For' node")) {
                goto failed_For;
            }
            res = obj2imm_stmt_seq(state, tmp, "For", "orelse", &orelse);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_For;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'For' node")) {
                goto failed_For;
            }
            res = obj2imm_string(state, tmp, &type_comment);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_For;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject *)state->_For_type);
        if (res == NULL) goto failed_For;
        res->kind = For_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.For.target = target;
        res->v.For.iter = iter;
        res->v.For.body = body;
        res->v.For.orelse = orelse;
        res->v.For.type_comment = type_comment;
        *out = res;
        return 0;
        failed_For:
        Py_XDECREF(target);
        Py_XDECREF(iter);
        Py_XDECREF(body);
        Py_XDECREF(orelse);
    }
    tp = state->_AsyncFor_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty target = NULL;
        expr_ty iter = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_stmt_seq* orelse = NULL;
        string type_comment;

        if (PyObject_GetOptionalAttr(obj, state->target, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"target\" missing from AsyncFor");
            goto failed_AsyncFor;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFor' node")) {
                goto failed_AsyncFor;
            }
            res = obj2imm_expr(state, tmp, &target);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncFor;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->iter, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"iter\" missing from AsyncFor");
            goto failed_AsyncFor;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFor' node")) {
                goto failed_AsyncFor;
            }
            res = obj2imm_expr(state, tmp, &iter);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncFor;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFor' node")) {
                goto failed_AsyncFor;
            }
            res = obj2imm_stmt_seq(state, tmp, "AsyncFor", "body", &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncFor;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFor' node")) {
                goto failed_AsyncFor;
            }
            res = obj2imm_stmt_seq(state, tmp, "AsyncFor", "orelse", &orelse);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncFor;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncFor' node")) {
                goto failed_AsyncFor;
            }
            res = obj2imm_string(state, tmp, &type_comment);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncFor;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_AsyncFor_type);
        if (res == NULL) goto failed_AsyncFor;
        res->kind = AsyncFor_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.AsyncFor.target = target;
        res->v.AsyncFor.iter = iter;
        res->v.AsyncFor.body = body;
        res->v.AsyncFor.orelse = orelse;
        res->v.AsyncFor.type_comment = type_comment;
        *out = res;
        return 0;
        failed_AsyncFor:
        Py_XDECREF(target);
        Py_XDECREF(iter);
        Py_XDECREF(body);
        Py_XDECREF(orelse);
    }
    tp = state->_While_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty test = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_stmt_seq* orelse = NULL;

        if (PyObject_GetOptionalAttr(obj, state->test, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"test\" missing from While");
            goto failed_While;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'While' node")) {
                goto failed_While;
            }
            res = obj2imm_expr(state, tmp, &test);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_While;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'While' node")) {
                goto failed_While;
            }
            res = obj2imm_stmt_seq(state, tmp, "While", "body", &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_While;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'While' node")) {
                goto failed_While;
            }
            res = obj2imm_stmt_seq(state, tmp, "While", "orelse", &orelse);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_While;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_While_type);
        if (res == NULL) goto failed_While;
        res->kind = While_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.While.test = test;
        res->v.While.body = body;
        res->v.While.orelse = orelse;
        *out = res;
        return 0;
        failed_While:
        Py_XDECREF(test);
        Py_XDECREF(body);
        Py_XDECREF(orelse);
    }
    tp = state->_If_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty test = NULL;
        asdl_stmt_seq* body = NULL;
        asdl_stmt_seq* orelse = NULL;

        if (PyObject_GetOptionalAttr(obj, state->test, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"test\" missing from If");
            goto failed_If;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'If' node")) {
                goto failed_If;
            }
            res = obj2imm_expr(state, tmp, &test);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_If;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'If' node")) {
                goto failed_If;
            }
            res = obj2imm_stmt_seq(state, tmp, "If", "body", &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_If;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'If' node")) {
                goto failed_If;
            }
            res = obj2imm_stmt_seq(state, tmp, "If", "orelse", &orelse);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_If;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject *)state->_If_type);
        if (res == NULL) goto failed_If;
        res->kind = If_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.If.test = test;
        res->v.If.body = body;
        res->v.If.orelse = orelse;
        *out = res;
        return 0;
        failed_If:
        Py_XDECREF(test);
        Py_XDECREF(body);
        Py_XDECREF(orelse);
    }
    tp = state->_With_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_withitem_seq* items = NULL;
        asdl_stmt_seq* body = NULL;
        string type_comment;

        if (PyObject_GetOptionalAttr(obj, state->items, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'With' node")) {
                goto failed_With;
            }
            res = obj2imm_withitem_seq(state, tmp, "With", "items", &items);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_With;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'With' node")) {
                goto failed_With;
            }
            res = obj2imm_stmt_seq(state, tmp, "With", "body", &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_With;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'With' node")) {
                goto failed_With;
            }
            res = obj2imm_string(state, tmp, &type_comment);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_With;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject *)state->_With_type);
        if (res == NULL) goto failed_With;
        res->kind = With_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.With.items = items;
        res->v.With.body = body;
        res->v.With.type_comment = type_comment;
        *out = res;
        return 0;
        failed_With:
        Py_XDECREF(items);
        Py_XDECREF(body);
    }
    tp = state->_AsyncWith_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_withitem_seq* items = NULL;
        asdl_stmt_seq* body = NULL;
        string type_comment;

        if (PyObject_GetOptionalAttr(obj, state->items, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncWith' node")) {
                goto failed_AsyncWith;
            }
            res = obj2imm_withitem_seq(state, tmp, "AsyncWith", "items",
                                       &items);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncWith;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncWith' node")) {
                goto failed_AsyncWith;
            }
            res = obj2imm_stmt_seq(state, tmp, "AsyncWith", "body", &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncWith;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type_comment = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'AsyncWith' node")) {
                goto failed_AsyncWith;
            }
            res = obj2imm_string(state, tmp, &type_comment);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_AsyncWith;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_AsyncWith_type);
        if (res == NULL) goto failed_AsyncWith;
        res->kind = AsyncWith_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.AsyncWith.items = items;
        res->v.AsyncWith.body = body;
        res->v.AsyncWith.type_comment = type_comment;
        *out = res;
        return 0;
        failed_AsyncWith:
        Py_XDECREF(items);
        Py_XDECREF(body);
    }
    tp = state->_Match_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty subject = NULL;
        asdl_match_case_seq* cases = NULL;

        if (PyObject_GetOptionalAttr(obj, state->subject, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"subject\" missing from Match");
            goto failed_Match;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Match' node")) {
                goto failed_Match;
            }
            res = obj2imm_expr(state, tmp, &subject);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Match;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->cases, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Match' node")) {
                goto failed_Match;
            }
            res = obj2imm_match_case_seq(state, tmp, "Match", "cases", &cases);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Match;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_Match_type);
        if (res == NULL) goto failed_Match;
        res->kind = Match_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Match.subject = subject;
        res->v.Match.cases = cases;
        *out = res;
        return 0;
        failed_Match:
        Py_XDECREF(subject);
        Py_XDECREF(cases);
    }
    tp = state->_Raise_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty exc = NULL;
        expr_ty cause = NULL;

        if (PyObject_GetOptionalAttr(obj, state->exc, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            exc = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Raise' node")) {
                goto failed_Raise;
            }
            res = obj2imm_expr(state, tmp, &exc);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Raise;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->cause, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            cause = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Raise' node")) {
                goto failed_Raise;
            }
            res = obj2imm_expr(state, tmp, &cause);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Raise;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_Raise_type);
        if (res == NULL) goto failed_Raise;
        res->kind = Raise_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Raise.exc = exc;
        res->v.Raise.cause = cause;
        *out = res;
        return 0;
        failed_Raise:
        Py_XDECREF(exc);
        Py_XDECREF(cause);
    }
    tp = state->_Try_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_stmt_seq* body = NULL;
        asdl_excepthandler_seq* handlers = NULL;
        asdl_stmt_seq* orelse = NULL;
        asdl_stmt_seq* finalbody = NULL;

        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Try' node")) {
                goto failed_Try;
            }
            res = obj2imm_stmt_seq(state, tmp, "Try", "body", &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Try;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->handlers, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Try' node")) {
                goto failed_Try;
            }
            res = obj2imm_excepthandler_seq(state, tmp, "Try", "handlers",
                                            &handlers);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Try;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Try' node")) {
                goto failed_Try;
            }
            res = obj2imm_stmt_seq(state, tmp, "Try", "orelse", &orelse);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Try;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->finalbody, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Try' node")) {
                goto failed_Try;
            }
            res = obj2imm_stmt_seq(state, tmp, "Try", "finalbody", &finalbody);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Try;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Try_type);
        if (res == NULL) goto failed_Try;
        res->kind = Try_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Try.body = body;
        res->v.Try.handlers = handlers;
        res->v.Try.orelse = orelse;
        res->v.Try.finalbody = finalbody;
        *out = res;
        return 0;
        failed_Try:
        Py_XDECREF(body);
        Py_XDECREF(handlers);
        Py_XDECREF(orelse);
        Py_XDECREF(finalbody);
    }
    tp = state->_TryStar_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_stmt_seq* body = NULL;
        asdl_excepthandler_seq* handlers = NULL;
        asdl_stmt_seq* orelse = NULL;
        asdl_stmt_seq* finalbody = NULL;

        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TryStar' node")) {
                goto failed_TryStar;
            }
            res = obj2imm_stmt_seq(state, tmp, "TryStar", "body", &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TryStar;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->handlers, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TryStar' node")) {
                goto failed_TryStar;
            }
            res = obj2imm_excepthandler_seq(state, tmp, "TryStar", "handlers",
                                            &handlers);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TryStar;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TryStar' node")) {
                goto failed_TryStar;
            }
            res = obj2imm_stmt_seq(state, tmp, "TryStar", "orelse", &orelse);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TryStar;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->finalbody, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TryStar' node")) {
                goto failed_TryStar;
            }
            res = obj2imm_stmt_seq(state, tmp, "TryStar", "finalbody",
                                   &finalbody);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TryStar;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_TryStar_type);
        if (res == NULL) goto failed_TryStar;
        res->kind = TryStar_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.TryStar.body = body;
        res->v.TryStar.handlers = handlers;
        res->v.TryStar.orelse = orelse;
        res->v.TryStar.finalbody = finalbody;
        *out = res;
        return 0;
        failed_TryStar:
        Py_XDECREF(body);
        Py_XDECREF(handlers);
        Py_XDECREF(orelse);
        Py_XDECREF(finalbody);
    }
    tp = state->_Assert_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty test = NULL;
        expr_ty msg = NULL;

        if (PyObject_GetOptionalAttr(obj, state->test, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"test\" missing from Assert");
            goto failed_Assert;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Assert' node")) {
                goto failed_Assert;
            }
            res = obj2imm_expr(state, tmp, &test);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Assert;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->msg, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            msg = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Assert' node")) {
                goto failed_Assert;
            }
            res = obj2imm_expr(state, tmp, &msg);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Assert;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_Assert_type);
        if (res == NULL) goto failed_Assert;
        res->kind = Assert_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Assert.test = test;
        res->v.Assert.msg = msg;
        *out = res;
        return 0;
        failed_Assert:
        Py_XDECREF(test);
        Py_XDECREF(msg);
    }
    tp = state->_Import_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_alias_seq* names = NULL;

        if (PyObject_GetOptionalAttr(obj, state->names, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Import' node")) {
                goto failed_Import;
            }
            res = obj2imm_alias_seq(state, tmp, "Import", "names", &names);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Import;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_Import_type);
        if (res == NULL) goto failed_Import;
        res->kind = Import_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Import.names = names;
        *out = res;
        return 0;
        failed_Import:
        Py_XDECREF(names);
    }
    tp = state->_ImportFrom_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier module = NULL;
        asdl_alias_seq* names = NULL;
        int level;

        if (PyObject_GetOptionalAttr(obj, state->module, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            module = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ImportFrom' node")) {
                goto failed_ImportFrom;
            }
            res = obj2imm_identifier(state, tmp, &module);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ImportFrom;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->names, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ImportFrom' node")) {
                goto failed_ImportFrom;
            }
            res = obj2imm_alias_seq(state, tmp, "ImportFrom", "names", &names);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ImportFrom;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->level, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            level = 0;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ImportFrom' node")) {
                goto failed_ImportFrom;
            }
            res = obj2imm_int(state, tmp, &level);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ImportFrom;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_ImportFrom_type);
        if (res == NULL) goto failed_ImportFrom;
        res->kind = ImportFrom_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.ImportFrom.module = module;
        res->v.ImportFrom.names = names;
        res->v.ImportFrom.level = level;
        *out = res;
        return 0;
        failed_ImportFrom:
        Py_XDECREF(module);
        Py_XDECREF(names);
    }
    tp = state->_Global_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_identifier_seq* names = NULL;

        if (PyObject_GetOptionalAttr(obj, state->names, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Global' node")) {
                goto failed_Global;
            }
            res = obj2imm_identifier_seq(state, tmp, "Global", "names", &names);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Global;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_Global_type);
        if (res == NULL) goto failed_Global;
        res->kind = Global_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Global.names = names;
        *out = res;
        return 0;
        failed_Global:
        Py_XDECREF(names);
    }
    tp = state->_Nonlocal_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_identifier_seq* names = NULL;

        if (PyObject_GetOptionalAttr(obj, state->names, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Nonlocal' node")) {
                goto failed_Nonlocal;
            }
            res = obj2imm_identifier_seq(state, tmp, "Nonlocal", "names",
                                         &names);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Nonlocal;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_Nonlocal_type);
        if (res == NULL) goto failed_Nonlocal;
        res->kind = Nonlocal_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Nonlocal.names = names;
        *out = res;
        return 0;
        failed_Nonlocal:
        Py_XDECREF(names);
    }
    tp = state->_Expr_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Expr");
            goto failed_Expr;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Expr' node")) {
                goto failed_Expr;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Expr;
            Py_CLEAR(tmp);
        }
        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Expr_type);
        if (res == NULL) goto failed_Expr;
        res->kind = Expr_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Expr.value = value;
        *out = res;
        return 0;
        failed_Expr:
        Py_XDECREF(value);
    }
    tp = state->_Pass_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {

        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject *)state->_Pass_type);
        if (res == NULL) goto failed_Pass;
        res->kind = Pass_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        *out = res;
        return 0;
        failed_Pass:
    }
    tp = state->_Break_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {

        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_Break_type);
        if (res == NULL) goto failed_Break;
        res->kind = Break_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        *out = res;
        return 0;
        failed_Break:
    }
    tp = state->_Continue_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {

        stmt_ty res = (stmt_ty)_PyObject_New((PyTypeObject
                       *)state->_Continue_type);
        if (res == NULL) goto failed_Continue;
        res->kind = Continue_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        *out = res;
        return 0;
        failed_Continue:
    }
    *out = (stmt_ty)Py_NewRef(obj);
    return 0;
failed_stmt:
    return -1;
}

static int obj2imm_expr_seq(struct ast_state *state, PyObject* obj, const char
                            *container, const char *field, asdl_expr_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_expr_seq_type) {
        *out = (asdl_expr_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_expr_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_expr_seq, (PyTypeObject *)state->_expr_seq_type,
                          len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        expr_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'expr' node")) {
            goto failed;
        }
        int err = obj2imm_expr(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_expr(struct ast_state *state, PyObject* obj, expr_ty* out, PyArena*
             arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    PyObject *tp;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from expr");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'expr' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from expr");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'expr' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_lineno = lineno;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'expr' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_col_offset = col_offset;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'expr' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    tp = state->BoolOp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        boolop_ty op;
        asdl_expr_seq* values = NULL;

        if (PyObject_GetOptionalAttr(obj, state->op, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"op\" missing from BoolOp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'BoolOp' node")) {
                goto failed;
            }
            res = obj2ast_boolop(state, tmp, &op, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->values, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "BoolOp field \"values\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Py_asdl_expr_seq_new(len, arena);
            if (values == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'BoolOp' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "BoolOp field \"values\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(values, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_BoolOp(op, values, lineno, col_offset, end_lineno,
                             end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->NamedExpr_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty target = NULL;
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->target, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"target\" missing from NamedExpr");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'NamedExpr' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &target, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from NamedExpr");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'NamedExpr' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_NamedExpr(target, value, lineno, col_offset, end_lineno,
                                end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->BinOp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty left = NULL;
        operator_ty op;
        expr_ty right = NULL;

        if (PyObject_GetOptionalAttr(obj, state->left, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"left\" missing from BinOp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'BinOp' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &left, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->op, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"op\" missing from BinOp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'BinOp' node")) {
                goto failed;
            }
            res = obj2ast_operator(state, tmp, &op, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->right, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"right\" missing from BinOp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'BinOp' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &right, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_BinOp(left, op, right, lineno, col_offset, end_lineno,
                            end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->UnaryOp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        unaryop_ty op;
        expr_ty operand = NULL;

        if (PyObject_GetOptionalAttr(obj, state->op, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"op\" missing from UnaryOp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'UnaryOp' node")) {
                goto failed;
            }
            res = obj2ast_unaryop(state, tmp, &op, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->operand, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"operand\" missing from UnaryOp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'UnaryOp' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &operand, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_UnaryOp(op, operand, lineno, col_offset, end_lineno,
                              end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Lambda_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        arguments_ty args = NULL;
        expr_ty body = NULL;

        if (PyObject_GetOptionalAttr(obj, state->args, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"args\" missing from Lambda");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Lambda' node")) {
                goto failed;
            }
            res = obj2ast_arguments(state, tmp, &args, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"body\" missing from Lambda");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Lambda' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &body, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Lambda(args, body, lineno, col_offset, end_lineno,
                             end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->IfExp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty test = NULL;
        expr_ty body = NULL;
        expr_ty orelse = NULL;

        if (PyObject_GetOptionalAttr(obj, state->test, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"test\" missing from IfExp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'IfExp' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &test, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"body\" missing from IfExp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'IfExp' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &body, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"orelse\" missing from IfExp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'IfExp' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &orelse, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_IfExp(test, body, orelse, lineno, col_offset, end_lineno,
                            end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Dict_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* keys = NULL;
        asdl_expr_seq* values = NULL;

        if (PyObject_GetOptionalAttr(obj, state->keys, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Dict field \"keys\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            keys = _Py_asdl_expr_seq_new(len, arena);
            if (keys == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Dict' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Dict field \"keys\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(keys, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->values, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Dict field \"values\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Py_asdl_expr_seq_new(len, arena);
            if (values == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Dict' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Dict field \"values\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(values, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Dict(keys, values, lineno, col_offset, end_lineno,
                           end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Set_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* elts = NULL;

        if (PyObject_GetOptionalAttr(obj, state->elts, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Set field \"elts\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Py_asdl_expr_seq_new(len, arena);
            if (elts == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Set' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Set field \"elts\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(elts, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Set(elts, lineno, col_offset, end_lineno, end_col_offset,
                          arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->ListComp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty elt = NULL;
        asdl_comprehension_seq* generators = NULL;

        if (PyObject_GetOptionalAttr(obj, state->elt, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"elt\" missing from ListComp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ListComp' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &elt, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->generators, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "ListComp field \"generators\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Py_asdl_comprehension_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'ListComp' node")) {
                    goto failed;
                }
                res = obj2ast_comprehension(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "ListComp field \"generators\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(generators, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_ListComp(elt, generators, lineno, col_offset, end_lineno,
                               end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->SetComp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty elt = NULL;
        asdl_comprehension_seq* generators = NULL;

        if (PyObject_GetOptionalAttr(obj, state->elt, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"elt\" missing from SetComp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'SetComp' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &elt, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->generators, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "SetComp field \"generators\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Py_asdl_comprehension_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'SetComp' node")) {
                    goto failed;
                }
                res = obj2ast_comprehension(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "SetComp field \"generators\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(generators, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_SetComp(elt, generators, lineno, col_offset, end_lineno,
                              end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->DictComp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty key = NULL;
        expr_ty value = NULL;
        asdl_comprehension_seq* generators = NULL;

        if (PyObject_GetOptionalAttr(obj, state->key, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"key\" missing from DictComp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'DictComp' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &key, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from DictComp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'DictComp' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->generators, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "DictComp field \"generators\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Py_asdl_comprehension_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'DictComp' node")) {
                    goto failed;
                }
                res = obj2ast_comprehension(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "DictComp field \"generators\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(generators, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_DictComp(key, value, generators, lineno, col_offset,
                               end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->GeneratorExp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty elt = NULL;
        asdl_comprehension_seq* generators = NULL;

        if (PyObject_GetOptionalAttr(obj, state->elt, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"elt\" missing from GeneratorExp");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'GeneratorExp' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &elt, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->generators, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "GeneratorExp field \"generators\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Py_asdl_comprehension_seq_new(len, arena);
            if (generators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                comprehension_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'GeneratorExp' node")) {
                    goto failed;
                }
                res = obj2ast_comprehension(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "GeneratorExp field \"generators\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(generators, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_GeneratorExp(elt, generators, lineno, col_offset,
                                   end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Await_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Await");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Await' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Await(value, lineno, col_offset, end_lineno,
                            end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Yield_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            value = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Yield' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Yield(value, lineno, col_offset, end_lineno,
                            end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->YieldFrom_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from YieldFrom");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'YieldFrom' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_YieldFrom(value, lineno, col_offset, end_lineno,
                                end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Compare_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty left = NULL;
        asdl_int_seq* ops = NULL;
        asdl_expr_seq* comparators = NULL;

        if (PyObject_GetOptionalAttr(obj, state->left, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"left\" missing from Compare");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Compare' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &left, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ops, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Compare field \"ops\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            ops = _Py_asdl_int_seq_new(len, arena);
            if (ops == NULL) goto failed;
            for (i = 0; i < len; i++) {
                cmpop_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Compare' node")) {
                    goto failed;
                }
                res = obj2ast_cmpop(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Compare field \"ops\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(ops, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->comparators, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Compare field \"comparators\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            comparators = _Py_asdl_expr_seq_new(len, arena);
            if (comparators == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Compare' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Compare field \"comparators\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(comparators, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Compare(left, ops, comparators, lineno, col_offset,
                              end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Call_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty func = NULL;
        asdl_expr_seq* args = NULL;
        asdl_keyword_seq* keywords = NULL;

        if (PyObject_GetOptionalAttr(obj, state->func, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"func\" missing from Call");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Call' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &func, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->args, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Call field \"args\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            args = _Py_asdl_expr_seq_new(len, arena);
            if (args == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Call' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Call field \"args\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(args, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->keywords, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Call field \"keywords\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            keywords = _Py_asdl_keyword_seq_new(len, arena);
            if (keywords == NULL) goto failed;
            for (i = 0; i < len; i++) {
                keyword_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Call' node")) {
                    goto failed;
                }
                res = obj2ast_keyword(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Call field \"keywords\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(keywords, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Call(func, args, keywords, lineno, col_offset,
                           end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->FormattedValue_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;
        int conversion;
        expr_ty format_spec = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from FormattedValue");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FormattedValue' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->conversion, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"conversion\" missing from FormattedValue");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FormattedValue' node")) {
                goto failed;
            }
            res = obj2ast_int(state, tmp, &conversion, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->format_spec, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            format_spec = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FormattedValue' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &format_spec, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_FormattedValue(value, conversion, format_spec, lineno,
                                     col_offset, end_lineno, end_col_offset,
                                     arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Interpolation_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;
        constant str = NULL;
        int conversion;
        expr_ty format_spec = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Interpolation");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Interpolation' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->str, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"str\" missing from Interpolation");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Interpolation' node")) {
                goto failed;
            }
            res = obj2ast_constant(state, tmp, &str, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->conversion, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"conversion\" missing from Interpolation");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Interpolation' node")) {
                goto failed;
            }
            res = obj2ast_int(state, tmp, &conversion, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->format_spec, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            format_spec = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Interpolation' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &format_spec, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Interpolation(value, str, conversion, format_spec,
                                    lineno, col_offset, end_lineno,
                                    end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->JoinedStr_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* values = NULL;

        if (PyObject_GetOptionalAttr(obj, state->values, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "JoinedStr field \"values\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Py_asdl_expr_seq_new(len, arena);
            if (values == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'JoinedStr' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "JoinedStr field \"values\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(values, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_JoinedStr(values, lineno, col_offset, end_lineno,
                                end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->TemplateStr_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* values = NULL;

        if (PyObject_GetOptionalAttr(obj, state->values, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "TemplateStr field \"values\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Py_asdl_expr_seq_new(len, arena);
            if (values == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'TemplateStr' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "TemplateStr field \"values\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(values, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_TemplateStr(values, lineno, col_offset, end_lineno,
                                  end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Constant_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        constant value = NULL;
        string kind;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Constant");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Constant' node")) {
                goto failed;
            }
            res = obj2ast_constant(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->kind, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            kind = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Constant' node")) {
                goto failed;
            }
            res = obj2ast_string(state, tmp, &kind, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Constant(value, kind, lineno, col_offset, end_lineno,
                               end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Attribute_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;
        identifier attr = NULL;
        expr_context_ty ctx;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Attribute");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Attribute' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->attr, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"attr\" missing from Attribute");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Attribute' node")) {
                goto failed;
            }
            res = obj2ast_identifier(state, tmp, &attr, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ctx, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"ctx\" missing from Attribute");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Attribute' node")) {
                goto failed;
            }
            res = obj2ast_expr_context(state, tmp, &ctx, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Attribute(value, attr, ctx, lineno, col_offset,
                                end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Subscript_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;
        expr_ty slice = NULL;
        expr_context_ty ctx;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Subscript");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Subscript' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->slice, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"slice\" missing from Subscript");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Subscript' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &slice, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ctx, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"ctx\" missing from Subscript");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Subscript' node")) {
                goto failed;
            }
            res = obj2ast_expr_context(state, tmp, &ctx, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Subscript(value, slice, ctx, lineno, col_offset,
                                end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Starred_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;
        expr_context_ty ctx;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Starred");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Starred' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ctx, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"ctx\" missing from Starred");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Starred' node")) {
                goto failed;
            }
            res = obj2ast_expr_context(state, tmp, &ctx, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Starred(value, ctx, lineno, col_offset, end_lineno,
                              end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Name_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier id = NULL;
        expr_context_ty ctx;

        if (PyObject_GetOptionalAttr(obj, state->id, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"id\" missing from Name");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Name' node")) {
                goto failed;
            }
            res = obj2ast_identifier(state, tmp, &id, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ctx, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"ctx\" missing from Name");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Name' node")) {
                goto failed;
            }
            res = obj2ast_expr_context(state, tmp, &ctx, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Name(id, ctx, lineno, col_offset, end_lineno,
                           end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->List_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* elts = NULL;
        expr_context_ty ctx;

        if (PyObject_GetOptionalAttr(obj, state->elts, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "List field \"elts\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Py_asdl_expr_seq_new(len, arena);
            if (elts == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'List' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "List field \"elts\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(elts, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ctx, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"ctx\" missing from List");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'List' node")) {
                goto failed;
            }
            res = obj2ast_expr_context(state, tmp, &ctx, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_List(elts, ctx, lineno, col_offset, end_lineno,
                           end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Tuple_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* elts = NULL;
        expr_context_ty ctx;

        if (PyObject_GetOptionalAttr(obj, state->elts, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "Tuple field \"elts\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Py_asdl_expr_seq_new(len, arena);
            if (elts == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'Tuple' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "Tuple field \"elts\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(elts, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ctx, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"ctx\" missing from Tuple");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Tuple' node")) {
                goto failed;
            }
            res = obj2ast_expr_context(state, tmp, &ctx, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Tuple(elts, ctx, lineno, col_offset, end_lineno,
                            end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->Slice_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty lower = NULL;
        expr_ty upper = NULL;
        expr_ty step = NULL;

        if (PyObject_GetOptionalAttr(obj, state->lower, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            lower = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Slice' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &lower, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->upper, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            upper = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Slice' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &upper, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->step, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            step = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Slice' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &step, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_Slice(lower, upper, step, lineno, col_offset, end_lineno,
                            end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of expr, but got %R", obj);
    failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_expr(struct ast_state *state, PyObject* obj, expr_ty* out)
{
    int isinstance;

    PyObject *tp;
    PyObject *tmp = NULL;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;
    if (Py_TYPE(obj) == (PyTypeObject *)state->_BoolOp_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_NamedExpr_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_BinOp_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_UnaryOp_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Lambda_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_IfExp_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Dict_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Set_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_ListComp_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_SetComp_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_DictComp_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_GeneratorExp_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Await_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Yield_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_YieldFrom_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Compare_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Call_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_FormattedValue_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Interpolation_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_JoinedStr_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_TemplateStr_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Constant_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Attribute_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Subscript_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Starred_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Name_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_List_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Tuple_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_Slice_type) {
        *out = (expr_ty)Py_NewRef(obj);
        return 0;
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from expr");
        goto failed_expr;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'expr' node")) {
            goto failed_expr;
        }
        res = obj2imm_int(state, tmp, &lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_expr;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from expr");
        goto failed_expr;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'expr' node")) {
            goto failed_expr;
        }
        res = obj2imm_int(state, tmp, &col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_expr;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_lineno = lineno;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'expr' node")) {
            goto failed_expr;
        }
        res = obj2imm_int(state, tmp, &end_lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_expr;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_col_offset = col_offset;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'expr' node")) {
            goto failed_expr;
        }
        res = obj2imm_int(state, tmp, &end_col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_expr;
        Py_CLEAR(tmp);
    }
    tp = state->_BoolOp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        boolop_ty op;
        asdl_expr_seq* values = NULL;

        if (PyObject_GetOptionalAttr(obj, state->op, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"op\" missing from BoolOp");
            goto failed_BoolOp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'BoolOp' node")) {
                goto failed_BoolOp;
            }
            res = obj2imm_boolop(state, tmp, &op);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_BoolOp;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->values, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'BoolOp' node")) {
                goto failed_BoolOp;
            }
            res = obj2imm_expr_seq(state, tmp, "BoolOp", "values", &values);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_BoolOp;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_BoolOp_type);
        if (res == NULL) goto failed_BoolOp;
        res->kind = BoolOp_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.BoolOp.op = op;
        res->v.BoolOp.values = values;
        *out = res;
        return 0;
        failed_BoolOp:
        Py_XDECREF(values);
    }
    tp = state->_NamedExpr_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty target = NULL;
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->target, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"target\" missing from NamedExpr");
            goto failed_NamedExpr;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'NamedExpr' node")) {
                goto failed_NamedExpr;
            }
            res = obj2imm_expr(state, tmp, &target);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_NamedExpr;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from NamedExpr");
            goto failed_NamedExpr;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'NamedExpr' node")) {
                goto failed_NamedExpr;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_NamedExpr;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_NamedExpr_type);
        if (res == NULL) goto failed_NamedExpr;
        res->kind = NamedExpr_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.NamedExpr.target = target;
        res->v.NamedExpr.value = value;
        *out = res;
        return 0;
        failed_NamedExpr:
        Py_XDECREF(target);
        Py_XDECREF(value);
    }
    tp = state->_BinOp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty left = NULL;
        operator_ty op;
        expr_ty right = NULL;

        if (PyObject_GetOptionalAttr(obj, state->left, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"left\" missing from BinOp");
            goto failed_BinOp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'BinOp' node")) {
                goto failed_BinOp;
            }
            res = obj2imm_expr(state, tmp, &left);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_BinOp;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->op, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"op\" missing from BinOp");
            goto failed_BinOp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'BinOp' node")) {
                goto failed_BinOp;
            }
            res = obj2imm_operator(state, tmp, &op);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_BinOp;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->right, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"right\" missing from BinOp");
            goto failed_BinOp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'BinOp' node")) {
                goto failed_BinOp;
            }
            res = obj2imm_expr(state, tmp, &right);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_BinOp;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_BinOp_type);
        if (res == NULL) goto failed_BinOp;
        res->kind = BinOp_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.BinOp.left = left;
        res->v.BinOp.op = op;
        res->v.BinOp.right = right;
        *out = res;
        return 0;
        failed_BinOp:
        Py_XDECREF(left);
        Py_XDECREF(right);
    }
    tp = state->_UnaryOp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        unaryop_ty op;
        expr_ty operand = NULL;

        if (PyObject_GetOptionalAttr(obj, state->op, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"op\" missing from UnaryOp");
            goto failed_UnaryOp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'UnaryOp' node")) {
                goto failed_UnaryOp;
            }
            res = obj2imm_unaryop(state, tmp, &op);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_UnaryOp;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->operand, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"operand\" missing from UnaryOp");
            goto failed_UnaryOp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'UnaryOp' node")) {
                goto failed_UnaryOp;
            }
            res = obj2imm_expr(state, tmp, &operand);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_UnaryOp;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_UnaryOp_type);
        if (res == NULL) goto failed_UnaryOp;
        res->kind = UnaryOp_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.UnaryOp.op = op;
        res->v.UnaryOp.operand = operand;
        *out = res;
        return 0;
        failed_UnaryOp:
        Py_XDECREF(operand);
    }
    tp = state->_Lambda_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        arguments_ty args = NULL;
        expr_ty body = NULL;

        if (PyObject_GetOptionalAttr(obj, state->args, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"args\" missing from Lambda");
            goto failed_Lambda;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Lambda' node")) {
                goto failed_Lambda;
            }
            res = obj2imm_arguments(state, tmp, &args);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Lambda;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"body\" missing from Lambda");
            goto failed_Lambda;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Lambda' node")) {
                goto failed_Lambda;
            }
            res = obj2imm_expr(state, tmp, &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Lambda;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_Lambda_type);
        if (res == NULL) goto failed_Lambda;
        res->kind = Lambda_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Lambda.args = args;
        res->v.Lambda.body = body;
        *out = res;
        return 0;
        failed_Lambda:
        Py_XDECREF(args);
        Py_XDECREF(body);
    }
    tp = state->_IfExp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty test = NULL;
        expr_ty body = NULL;
        expr_ty orelse = NULL;

        if (PyObject_GetOptionalAttr(obj, state->test, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"test\" missing from IfExp");
            goto failed_IfExp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'IfExp' node")) {
                goto failed_IfExp;
            }
            res = obj2imm_expr(state, tmp, &test);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_IfExp;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"body\" missing from IfExp");
            goto failed_IfExp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'IfExp' node")) {
                goto failed_IfExp;
            }
            res = obj2imm_expr(state, tmp, &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_IfExp;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->orelse, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"orelse\" missing from IfExp");
            goto failed_IfExp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'IfExp' node")) {
                goto failed_IfExp;
            }
            res = obj2imm_expr(state, tmp, &orelse);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_IfExp;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_IfExp_type);
        if (res == NULL) goto failed_IfExp;
        res->kind = IfExp_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.IfExp.test = test;
        res->v.IfExp.body = body;
        res->v.IfExp.orelse = orelse;
        *out = res;
        return 0;
        failed_IfExp:
        Py_XDECREF(test);
        Py_XDECREF(body);
        Py_XDECREF(orelse);
    }
    tp = state->_Dict_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* keys = NULL;
        asdl_expr_seq* values = NULL;

        if (PyObject_GetOptionalAttr(obj, state->keys, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Dict' node")) {
                goto failed_Dict;
            }
            res = obj2imm_expr_seq(state, tmp, "Dict", "keys", &keys);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Dict;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->values, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Dict' node")) {
                goto failed_Dict;
            }
            res = obj2imm_expr_seq(state, tmp, "Dict", "values", &values);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Dict;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject *)state->_Dict_type);
        if (res == NULL) goto failed_Dict;
        res->kind = Dict_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Dict.keys = keys;
        res->v.Dict.values = values;
        *out = res;
        return 0;
        failed_Dict:
        Py_XDECREF(keys);
        Py_XDECREF(values);
    }
    tp = state->_Set_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* elts = NULL;

        if (PyObject_GetOptionalAttr(obj, state->elts, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Set' node")) {
                goto failed_Set;
            }
            res = obj2imm_expr_seq(state, tmp, "Set", "elts", &elts);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Set;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject *)state->_Set_type);
        if (res == NULL) goto failed_Set;
        res->kind = Set_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Set.elts = elts;
        *out = res;
        return 0;
        failed_Set:
        Py_XDECREF(elts);
    }
    tp = state->_ListComp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty elt = NULL;
        asdl_comprehension_seq* generators = NULL;

        if (PyObject_GetOptionalAttr(obj, state->elt, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"elt\" missing from ListComp");
            goto failed_ListComp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ListComp' node")) {
                goto failed_ListComp;
            }
            res = obj2imm_expr(state, tmp, &elt);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ListComp;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->generators, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ListComp' node")) {
                goto failed_ListComp;
            }
            res = obj2imm_comprehension_seq(state, tmp, "ListComp",
                                            "generators", &generators);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ListComp;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_ListComp_type);
        if (res == NULL) goto failed_ListComp;
        res->kind = ListComp_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.ListComp.elt = elt;
        res->v.ListComp.generators = generators;
        *out = res;
        return 0;
        failed_ListComp:
        Py_XDECREF(elt);
        Py_XDECREF(generators);
    }
    tp = state->_SetComp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty elt = NULL;
        asdl_comprehension_seq* generators = NULL;

        if (PyObject_GetOptionalAttr(obj, state->elt, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"elt\" missing from SetComp");
            goto failed_SetComp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'SetComp' node")) {
                goto failed_SetComp;
            }
            res = obj2imm_expr(state, tmp, &elt);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_SetComp;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->generators, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'SetComp' node")) {
                goto failed_SetComp;
            }
            res = obj2imm_comprehension_seq(state, tmp, "SetComp",
                                            "generators", &generators);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_SetComp;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_SetComp_type);
        if (res == NULL) goto failed_SetComp;
        res->kind = SetComp_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.SetComp.elt = elt;
        res->v.SetComp.generators = generators;
        *out = res;
        return 0;
        failed_SetComp:
        Py_XDECREF(elt);
        Py_XDECREF(generators);
    }
    tp = state->_DictComp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty key = NULL;
        expr_ty value = NULL;
        asdl_comprehension_seq* generators = NULL;

        if (PyObject_GetOptionalAttr(obj, state->key, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"key\" missing from DictComp");
            goto failed_DictComp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'DictComp' node")) {
                goto failed_DictComp;
            }
            res = obj2imm_expr(state, tmp, &key);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_DictComp;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from DictComp");
            goto failed_DictComp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'DictComp' node")) {
                goto failed_DictComp;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_DictComp;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->generators, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'DictComp' node")) {
                goto failed_DictComp;
            }
            res = obj2imm_comprehension_seq(state, tmp, "DictComp",
                                            "generators", &generators);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_DictComp;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_DictComp_type);
        if (res == NULL) goto failed_DictComp;
        res->kind = DictComp_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.DictComp.key = key;
        res->v.DictComp.value = value;
        res->v.DictComp.generators = generators;
        *out = res;
        return 0;
        failed_DictComp:
        Py_XDECREF(key);
        Py_XDECREF(value);
        Py_XDECREF(generators);
    }
    tp = state->_GeneratorExp_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty elt = NULL;
        asdl_comprehension_seq* generators = NULL;

        if (PyObject_GetOptionalAttr(obj, state->elt, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"elt\" missing from GeneratorExp");
            goto failed_GeneratorExp;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'GeneratorExp' node")) {
                goto failed_GeneratorExp;
            }
            res = obj2imm_expr(state, tmp, &elt);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_GeneratorExp;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->generators, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'GeneratorExp' node")) {
                goto failed_GeneratorExp;
            }
            res = obj2imm_comprehension_seq(state, tmp, "GeneratorExp",
                                            "generators", &generators);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_GeneratorExp;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_GeneratorExp_type);
        if (res == NULL) goto failed_GeneratorExp;
        res->kind = GeneratorExp_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.GeneratorExp.elt = elt;
        res->v.GeneratorExp.generators = generators;
        *out = res;
        return 0;
        failed_GeneratorExp:
        Py_XDECREF(elt);
        Py_XDECREF(generators);
    }
    tp = state->_Await_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Await");
            goto failed_Await;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Await' node")) {
                goto failed_Await;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Await;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_Await_type);
        if (res == NULL) goto failed_Await;
        res->kind = Await_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Await.value = value;
        *out = res;
        return 0;
        failed_Await:
        Py_XDECREF(value);
    }
    tp = state->_Yield_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            value = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Yield' node")) {
                goto failed_Yield;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Yield;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_Yield_type);
        if (res == NULL) goto failed_Yield;
        res->kind = Yield_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Yield.value = value;
        *out = res;
        return 0;
        failed_Yield:
        Py_XDECREF(value);
    }
    tp = state->_YieldFrom_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from YieldFrom");
            goto failed_YieldFrom;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'YieldFrom' node")) {
                goto failed_YieldFrom;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_YieldFrom;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_YieldFrom_type);
        if (res == NULL) goto failed_YieldFrom;
        res->kind = YieldFrom_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.YieldFrom.value = value;
        *out = res;
        return 0;
        failed_YieldFrom:
        Py_XDECREF(value);
    }
    tp = state->_Compare_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty left = NULL;
        asdl_int_seq* ops = NULL;
        asdl_expr_seq* comparators = NULL;

        if (PyObject_GetOptionalAttr(obj, state->left, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"left\" missing from Compare");
            goto failed_Compare;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Compare' node")) {
                goto failed_Compare;
            }
            res = obj2imm_expr(state, tmp, &left);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Compare;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ops, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Compare' node")) {
                goto failed_Compare;
            }
            res = obj2imm_cmpop_seq(state, tmp, "Compare", "ops", &ops);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Compare;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->comparators, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Compare' node")) {
                goto failed_Compare;
            }
            res = obj2imm_expr_seq(state, tmp, "Compare", "comparators",
                                   &comparators);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Compare;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_Compare_type);
        if (res == NULL) goto failed_Compare;
        res->kind = Compare_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Compare.left = left;
        res->v.Compare.ops = ops;
        res->v.Compare.comparators = comparators;
        *out = res;
        return 0;
        failed_Compare:
        Py_XDECREF(left);
        Py_XDECREF(ops);
        Py_XDECREF(comparators);
    }
    tp = state->_Call_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty func = NULL;
        asdl_expr_seq* args = NULL;
        asdl_keyword_seq* keywords = NULL;

        if (PyObject_GetOptionalAttr(obj, state->func, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"func\" missing from Call");
            goto failed_Call;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Call' node")) {
                goto failed_Call;
            }
            res = obj2imm_expr(state, tmp, &func);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Call;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->args, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Call' node")) {
                goto failed_Call;
            }
            res = obj2imm_expr_seq(state, tmp, "Call", "args", &args);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Call;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->keywords, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Call' node")) {
                goto failed_Call;
            }
            res = obj2imm_keyword_seq(state, tmp, "Call", "keywords",
                                      &keywords);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Call;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject *)state->_Call_type);
        if (res == NULL) goto failed_Call;
        res->kind = Call_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Call.func = func;
        res->v.Call.args = args;
        res->v.Call.keywords = keywords;
        *out = res;
        return 0;
        failed_Call:
        Py_XDECREF(func);
        Py_XDECREF(args);
        Py_XDECREF(keywords);
    }
    tp = state->_FormattedValue_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;
        int conversion;
        expr_ty format_spec = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from FormattedValue");
            goto failed_FormattedValue;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FormattedValue' node")) {
                goto failed_FormattedValue;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_FormattedValue;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->conversion, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"conversion\" missing from FormattedValue");
            goto failed_FormattedValue;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FormattedValue' node")) {
                goto failed_FormattedValue;
            }
            res = obj2imm_int(state, tmp, &conversion);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_FormattedValue;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->format_spec, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            format_spec = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'FormattedValue' node")) {
                goto failed_FormattedValue;
            }
            res = obj2imm_expr(state, tmp, &format_spec);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_FormattedValue;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_FormattedValue_type);
        if (res == NULL) goto failed_FormattedValue;
        res->kind = FormattedValue_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.FormattedValue.value = value;
        res->v.FormattedValue.conversion = conversion;
        res->v.FormattedValue.format_spec = format_spec;
        *out = res;
        return 0;
        failed_FormattedValue:
        Py_XDECREF(value);
        Py_XDECREF(format_spec);
    }
    tp = state->_Interpolation_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;
        constant str = NULL;
        int conversion;
        expr_ty format_spec = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Interpolation");
            goto failed_Interpolation;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Interpolation' node")) {
                goto failed_Interpolation;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Interpolation;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->str, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"str\" missing from Interpolation");
            goto failed_Interpolation;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Interpolation' node")) {
                goto failed_Interpolation;
            }
            res = obj2imm_constant(state, tmp, &str);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Interpolation;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->conversion, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"conversion\" missing from Interpolation");
            goto failed_Interpolation;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Interpolation' node")) {
                goto failed_Interpolation;
            }
            res = obj2imm_int(state, tmp, &conversion);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Interpolation;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->format_spec, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            format_spec = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Interpolation' node")) {
                goto failed_Interpolation;
            }
            res = obj2imm_expr(state, tmp, &format_spec);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Interpolation;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_Interpolation_type);
        if (res == NULL) goto failed_Interpolation;
        res->kind = Interpolation_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Interpolation.value = value;
        res->v.Interpolation.str = str;
        res->v.Interpolation.conversion = conversion;
        res->v.Interpolation.format_spec = format_spec;
        *out = res;
        return 0;
        failed_Interpolation:
        Py_XDECREF(value);
        Py_XDECREF(str);
        Py_XDECREF(format_spec);
    }
    tp = state->_JoinedStr_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* values = NULL;

        if (PyObject_GetOptionalAttr(obj, state->values, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'JoinedStr' node")) {
                goto failed_JoinedStr;
            }
            res = obj2imm_expr_seq(state, tmp, "JoinedStr", "values", &values);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_JoinedStr;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_JoinedStr_type);
        if (res == NULL) goto failed_JoinedStr;
        res->kind = JoinedStr_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.JoinedStr.values = values;
        *out = res;
        return 0;
        failed_JoinedStr:
        Py_XDECREF(values);
    }
    tp = state->_TemplateStr_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* values = NULL;

        if (PyObject_GetOptionalAttr(obj, state->values, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TemplateStr' node")) {
                goto failed_TemplateStr;
            }
            res = obj2imm_expr_seq(state, tmp, "TemplateStr", "values",
                                   &values);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TemplateStr;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_TemplateStr_type);
        if (res == NULL) goto failed_TemplateStr;
        res->kind = TemplateStr_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.TemplateStr.values = values;
        *out = res;
        return 0;
        failed_TemplateStr:
        Py_XDECREF(values);
    }
    tp = state->_Constant_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        constant value = NULL;
        string kind;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Constant");
            goto failed_Constant;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Constant' node")) {
                goto failed_Constant;
            }
            res = obj2imm_constant(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Constant;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->kind, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            kind = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Constant' node")) {
                goto failed_Constant;
            }
            res = obj2imm_string(state, tmp, &kind);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Constant;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_Constant_type);
        if (res == NULL) goto failed_Constant;
        res->kind = Constant_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Constant.value = value;
        res->v.Constant.kind = kind;
        *out = res;
        return 0;
        failed_Constant:
        Py_XDECREF(value);
    }
    tp = state->_Attribute_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;
        identifier attr = NULL;
        expr_context_ty ctx;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Attribute");
            goto failed_Attribute;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Attribute' node")) {
                goto failed_Attribute;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Attribute;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->attr, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"attr\" missing from Attribute");
            goto failed_Attribute;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Attribute' node")) {
                goto failed_Attribute;
            }
            res = obj2imm_identifier(state, tmp, &attr);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Attribute;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ctx, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"ctx\" missing from Attribute");
            goto failed_Attribute;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Attribute' node")) {
                goto failed_Attribute;
            }
            res = obj2imm_expr_context(state, tmp, &ctx);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Attribute;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_Attribute_type);
        if (res == NULL) goto failed_Attribute;
        res->kind = Attribute_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Attribute.value = value;
        res->v.Attribute.attr = attr;
        res->v.Attribute.ctx = ctx;
        *out = res;
        return 0;
        failed_Attribute:
        Py_XDECREF(value);
        Py_XDECREF(attr);
    }
    tp = state->_Subscript_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;
        expr_ty slice = NULL;
        expr_context_ty ctx;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Subscript");
            goto failed_Subscript;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Subscript' node")) {
                goto failed_Subscript;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Subscript;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->slice, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"slice\" missing from Subscript");
            goto failed_Subscript;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Subscript' node")) {
                goto failed_Subscript;
            }
            res = obj2imm_expr(state, tmp, &slice);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Subscript;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ctx, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"ctx\" missing from Subscript");
            goto failed_Subscript;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Subscript' node")) {
                goto failed_Subscript;
            }
            res = obj2imm_expr_context(state, tmp, &ctx);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Subscript;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_Subscript_type);
        if (res == NULL) goto failed_Subscript;
        res->kind = Subscript_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Subscript.value = value;
        res->v.Subscript.slice = slice;
        res->v.Subscript.ctx = ctx;
        *out = res;
        return 0;
        failed_Subscript:
        Py_XDECREF(value);
        Py_XDECREF(slice);
    }
    tp = state->_Starred_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;
        expr_context_ty ctx;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from Starred");
            goto failed_Starred;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Starred' node")) {
                goto failed_Starred;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Starred;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ctx, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"ctx\" missing from Starred");
            goto failed_Starred;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Starred' node")) {
                goto failed_Starred;
            }
            res = obj2imm_expr_context(state, tmp, &ctx);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Starred;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_Starred_type);
        if (res == NULL) goto failed_Starred;
        res->kind = Starred_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Starred.value = value;
        res->v.Starred.ctx = ctx;
        *out = res;
        return 0;
        failed_Starred:
        Py_XDECREF(value);
    }
    tp = state->_Name_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier id = NULL;
        expr_context_ty ctx;

        if (PyObject_GetOptionalAttr(obj, state->id, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"id\" missing from Name");
            goto failed_Name;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Name' node")) {
                goto failed_Name;
            }
            res = obj2imm_identifier(state, tmp, &id);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Name;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ctx, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"ctx\" missing from Name");
            goto failed_Name;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Name' node")) {
                goto failed_Name;
            }
            res = obj2imm_expr_context(state, tmp, &ctx);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Name;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject *)state->_Name_type);
        if (res == NULL) goto failed_Name;
        res->kind = Name_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Name.id = id;
        res->v.Name.ctx = ctx;
        *out = res;
        return 0;
        failed_Name:
        Py_XDECREF(id);
    }
    tp = state->_List_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* elts = NULL;
        expr_context_ty ctx;

        if (PyObject_GetOptionalAttr(obj, state->elts, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'List' node")) {
                goto failed_List;
            }
            res = obj2imm_expr_seq(state, tmp, "List", "elts", &elts);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_List;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ctx, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"ctx\" missing from List");
            goto failed_List;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'List' node")) {
                goto failed_List;
            }
            res = obj2imm_expr_context(state, tmp, &ctx);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_List;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject *)state->_List_type);
        if (res == NULL) goto failed_List;
        res->kind = List_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.List.elts = elts;
        res->v.List.ctx = ctx;
        *out = res;
        return 0;
        failed_List:
        Py_XDECREF(elts);
    }
    tp = state->_Tuple_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* elts = NULL;
        expr_context_ty ctx;

        if (PyObject_GetOptionalAttr(obj, state->elts, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Tuple' node")) {
                goto failed_Tuple;
            }
            res = obj2imm_expr_seq(state, tmp, "Tuple", "elts", &elts);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Tuple;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->ctx, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"ctx\" missing from Tuple");
            goto failed_Tuple;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Tuple' node")) {
                goto failed_Tuple;
            }
            res = obj2imm_expr_context(state, tmp, &ctx);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Tuple;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_Tuple_type);
        if (res == NULL) goto failed_Tuple;
        res->kind = Tuple_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Tuple.elts = elts;
        res->v.Tuple.ctx = ctx;
        *out = res;
        return 0;
        failed_Tuple:
        Py_XDECREF(elts);
    }
    tp = state->_Slice_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty lower = NULL;
        expr_ty upper = NULL;
        expr_ty step = NULL;

        if (PyObject_GetOptionalAttr(obj, state->lower, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            lower = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Slice' node")) {
                goto failed_Slice;
            }
            res = obj2imm_expr(state, tmp, &lower);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Slice;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->upper, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            upper = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Slice' node")) {
                goto failed_Slice;
            }
            res = obj2imm_expr(state, tmp, &upper);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Slice;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->step, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            step = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'Slice' node")) {
                goto failed_Slice;
            }
            res = obj2imm_expr(state, tmp, &step);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_Slice;
            Py_CLEAR(tmp);
        }
        expr_ty res = (expr_ty)_PyObject_New((PyTypeObject
                       *)state->_Slice_type);
        if (res == NULL) goto failed_Slice;
        res->kind = Slice_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.Slice.lower = lower;
        res->v.Slice.upper = upper;
        res->v.Slice.step = step;
        *out = res;
        return 0;
        failed_Slice:
        Py_XDECREF(lower);
        Py_XDECREF(upper);
        Py_XDECREF(step);
    }
    *out = (expr_ty)Py_NewRef(obj);
    return 0;
failed_expr:
    return -1;
}

static int obj2imm_expr_context_seq(struct ast_state *state, PyObject* obj,
                                    const char *container, const char *field,
                                    asdl_int_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_expr_context_seq_type) {
        *out = (asdl_int_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_int_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_int_seq, (PyTypeObject
                          *)state->_expr_context_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        expr_context_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'expr_context' node")) {
            goto failed;
        }
        int err = obj2imm_expr_context(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_expr_context(struct ast_state *state, PyObject* obj, expr_context_ty*
                     out, PyArena* arena)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, state->Load_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Load;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->Store_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Store;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->Del_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Del;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of expr_context, but got %R", obj);
    return -1;
}

int
obj2imm_expr_context(struct ast_state *state, PyObject* obj, expr_context_ty*
                     out)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, state->_Load_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Load;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_Store_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Store;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_Del_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Del;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of expr_context, but got %R", obj);
    return -1;
}

static int obj2imm_boolop_seq(struct ast_state *state, PyObject* obj, const
                              char *container, const char *field,
                              asdl_int_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_boolop_seq_type) {
        *out = (asdl_int_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_int_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_int_seq, (PyTypeObject
                          *)state->_boolop_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        boolop_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'boolop' node")) {
            goto failed;
        }
        int err = obj2imm_boolop(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_boolop(struct ast_state *state, PyObject* obj, boolop_ty* out, PyArena*
               arena)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, state->And_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = And;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->Or_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Or;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of boolop, but got %R", obj);
    return -1;
}

int
obj2imm_boolop(struct ast_state *state, PyObject* obj, boolop_ty* out)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, state->_And_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = And;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_Or_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Or;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of boolop, but got %R", obj);
    return -1;
}

static int obj2imm_operator_seq(struct ast_state *state, PyObject* obj, const
                                char *container, const char *field,
                                asdl_int_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_operator_seq_type) {
        *out = (asdl_int_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_int_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_int_seq, (PyTypeObject
                          *)state->_operator_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        operator_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'operator' node")) {
            goto failed;
        }
        int err = obj2imm_operator(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_operator(struct ast_state *state, PyObject* obj, operator_ty* out,
                 PyArena* arena)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, state->Add_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Add;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->Sub_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Sub;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->Mult_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Mult;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->MatMult_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = MatMult;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->Div_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Div;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->Mod_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Mod;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->Pow_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Pow;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->LShift_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = LShift;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->RShift_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = RShift;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->BitOr_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = BitOr;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->BitXor_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = BitXor;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->BitAnd_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = BitAnd;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->FloorDiv_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = FloorDiv;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of operator, but got %R", obj);
    return -1;
}

int
obj2imm_operator(struct ast_state *state, PyObject* obj, operator_ty* out)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, state->_Add_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Add;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_Sub_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Sub;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_Mult_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Mult;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_MatMult_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = MatMult;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_Div_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Div;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_Mod_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Mod;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_Pow_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Pow;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_LShift_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = LShift;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_RShift_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = RShift;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_BitOr_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = BitOr;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_BitXor_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = BitXor;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_BitAnd_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = BitAnd;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_FloorDiv_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = FloorDiv;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of operator, but got %R", obj);
    return -1;
}

static int obj2imm_unaryop_seq(struct ast_state *state, PyObject* obj, const
                               char *container, const char *field,
                               asdl_int_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_unaryop_seq_type) {
        *out = (asdl_int_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_int_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_int_seq, (PyTypeObject
                          *)state->_unaryop_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        unaryop_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'unaryop' node")) {
            goto failed;
        }
        int err = obj2imm_unaryop(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_unaryop(struct ast_state *state, PyObject* obj, unaryop_ty* out,
                PyArena* arena)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, state->Invert_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Invert;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->Not_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Not;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->UAdd_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = UAdd;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->USub_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = USub;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of unaryop, but got %R", obj);
    return -1;
}

int
obj2imm_unaryop(struct ast_state *state, PyObject* obj, unaryop_ty* out)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, state->_Invert_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Invert;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_Not_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Not;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_UAdd_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = UAdd;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_USub_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = USub;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of unaryop, but got %R", obj);
    return -1;
}

static int obj2imm_cmpop_seq(struct ast_state *state, PyObject* obj, const char
                             *container, const char *field, asdl_int_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_cmpop_seq_type) {
        *out = (asdl_int_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_int_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_int_seq, (PyTypeObject *)state->_cmpop_seq_type,
                          len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        cmpop_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'cmpop' node")) {
            goto failed;
        }
        int err = obj2imm_cmpop(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_cmpop(struct ast_state *state, PyObject* obj, cmpop_ty* out, PyArena*
              arena)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, state->Eq_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Eq;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->NotEq_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = NotEq;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->Lt_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Lt;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->LtE_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = LtE;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->Gt_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Gt;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->GtE_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = GtE;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->Is_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Is;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->IsNot_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = IsNot;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->In_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = In;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->NotIn_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = NotIn;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of cmpop, but got %R", obj);
    return -1;
}

int
obj2imm_cmpop(struct ast_state *state, PyObject* obj, cmpop_ty* out)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, state->_Eq_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Eq;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_NotEq_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = NotEq;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_Lt_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Lt;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_LtE_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = LtE;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_Gt_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Gt;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_GtE_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = GtE;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_Is_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = Is;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_IsNot_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = IsNot;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_In_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = In;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, state->_NotIn_type);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        *out = NotIn;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of cmpop, but got %R", obj);
    return -1;
}

static int obj2imm_comprehension_seq(struct ast_state *state, PyObject* obj,
                                     const char *container, const char *field,
                                     asdl_comprehension_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_comprehension_seq_type) {
        *out = (asdl_comprehension_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_comprehension_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_comprehension_seq, (PyTypeObject
                          *)state->_comprehension_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        comprehension_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'comprehension' node")) {
            goto failed;
        }
        int err = obj2imm_comprehension(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_comprehension(struct ast_state *state, PyObject* obj, comprehension_ty*
                      out, PyArena* arena)
{
    PyObject* tmp = NULL;
    expr_ty target = NULL;
    expr_ty iter = NULL;
    asdl_expr_seq* ifs = NULL;
    int is_async;

    if (PyObject_GetOptionalAttr(obj, state->target, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"target\" missing from comprehension");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'comprehension' node")) {
            goto failed;
        }
        res = obj2ast_expr(state, tmp, &target, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->iter, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"iter\" missing from comprehension");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'comprehension' node")) {
            goto failed;
        }
        res = obj2ast_expr(state, tmp, &iter, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->ifs, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        tmp = PyList_New(0);
        if (tmp == NULL) {
            return -1;
        }
    }
    {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, "comprehension field \"ifs\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        ifs = _Py_asdl_expr_seq_new(len, arena);
        if (ifs == NULL) goto failed;
        for (i = 0; i < len; i++) {
            expr_ty val;
            PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
            if (_Py_EnterRecursiveCall(" while traversing 'comprehension' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp2, &val, arena);
            _Py_LeaveRecursiveCall();
            Py_DECREF(tmp2);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, "comprehension field \"ifs\" changed size during iteration");
                goto failed;
            }
            asdl_seq_SET(ifs, i, val);
        }
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->is_async, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"is_async\" missing from comprehension");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'comprehension' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &is_async, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    *out = _PyAST_comprehension(target, iter, ifs, is_async, arena);
    if (*out == NULL) goto failed;
    return 0;
failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_comprehension(struct ast_state *state, PyObject* obj, comprehension_ty*
                      out)
{
    expr_ty target = NULL;
    expr_ty iter = NULL;
    asdl_expr_seq* ifs = NULL;
    int is_async;

    if (Py_TYPE(obj) == (PyTypeObject *)state->_comprehension_type) {
        *out = (comprehension_ty)Py_NewRef(obj);
        return *out != NULL ? 0 : -1;
    }

    PyObject* tmp = NULL;
    if (PyObject_GetOptionalAttr(obj, state->target, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"target\" missing from comprehension");
        goto failed_comprehension;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'comprehension' node")) {
            goto failed_comprehension;
        }
        res = obj2imm_expr(state, tmp, &target);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_comprehension;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->iter, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"iter\" missing from comprehension");
        goto failed_comprehension;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'comprehension' node")) {
            goto failed_comprehension;
        }
        res = obj2imm_expr(state, tmp, &iter);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_comprehension;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->ifs, &tmp) < 0) {
        return -1;
    }
    {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'comprehension' node")) {
            goto failed_comprehension;
        }
        res = obj2imm_expr_seq(state, tmp, "comprehension", "ifs", &ifs);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_comprehension;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->is_async, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"is_async\" missing from comprehension");
        goto failed_comprehension;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'comprehension' node")) {
            goto failed_comprehension;
        }
        res = obj2imm_int(state, tmp, &is_async);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_comprehension;
        Py_CLEAR(tmp);
    }
    *out = _PyAST_comprehensionHeap(state, target, iter, ifs, is_async);
    if (*out == NULL) goto failed_comprehension;
    return 0;
failed_comprehension:
    Py_XDECREF(target);
    Py_XDECREF(iter);
    Py_XDECREF(ifs);
    Py_XDECREF(tmp);
    return -1;
}

static int obj2imm_excepthandler_seq(struct ast_state *state, PyObject* obj,
                                     const char *container, const char *field,
                                     asdl_excepthandler_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_excepthandler_seq_type) {
        *out = (asdl_excepthandler_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_excepthandler_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_excepthandler_seq, (PyTypeObject
                          *)state->_excepthandler_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        excepthandler_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'excepthandler' node")) {
            goto failed;
        }
        int err = obj2imm_excepthandler(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_excepthandler(struct ast_state *state, PyObject* obj, excepthandler_ty*
                      out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    PyObject *tp;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from excepthandler");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'excepthandler' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from excepthandler");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'excepthandler' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_lineno = lineno;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'excepthandler' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_col_offset = col_offset;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'excepthandler' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    tp = state->ExceptHandler_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty type = NULL;
        identifier name = NULL;
        asdl_stmt_seq* body = NULL;

        if (PyObject_GetOptionalAttr(obj, state->type, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ExceptHandler' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &type, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            name = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ExceptHandler' node")) {
                goto failed;
            }
            res = obj2ast_identifier(state, tmp, &name, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "ExceptHandler field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_stmt_seq_new(len, arena);
            if (body == NULL) goto failed;
            for (i = 0; i < len; i++) {
                stmt_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'ExceptHandler' node")) {
                    goto failed;
                }
                res = obj2ast_stmt(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "ExceptHandler field \"body\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(body, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_ExceptHandler(type, name, body, lineno, col_offset,
                                    end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of excepthandler, but got %R", obj);
    failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_excepthandler(struct ast_state *state, PyObject* obj, excepthandler_ty*
                      out)
{
    int isinstance;

    PyObject *tp;
    PyObject *tmp = NULL;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;
    if (Py_TYPE(obj) == (PyTypeObject *)state->_ExceptHandler_type) {
        *out = (excepthandler_ty)Py_NewRef(obj);
        return 0;
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from excepthandler");
        goto failed_excepthandler;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'excepthandler' node")) {
            goto failed_excepthandler;
        }
        res = obj2imm_int(state, tmp, &lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_excepthandler;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from excepthandler");
        goto failed_excepthandler;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'excepthandler' node")) {
            goto failed_excepthandler;
        }
        res = obj2imm_int(state, tmp, &col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_excepthandler;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_lineno = lineno;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'excepthandler' node")) {
            goto failed_excepthandler;
        }
        res = obj2imm_int(state, tmp, &end_lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_excepthandler;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_col_offset = col_offset;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'excepthandler' node")) {
            goto failed_excepthandler;
        }
        res = obj2imm_int(state, tmp, &end_col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_excepthandler;
        Py_CLEAR(tmp);
    }
    tp = state->_ExceptHandler_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty type = NULL;
        identifier name = NULL;
        asdl_stmt_seq* body = NULL;

        if (PyObject_GetOptionalAttr(obj, state->type, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            type = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ExceptHandler' node")) {
                goto failed_ExceptHandler;
            }
            res = obj2imm_expr(state, tmp, &type);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ExceptHandler;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            name = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ExceptHandler' node")) {
                goto failed_ExceptHandler;
            }
            res = obj2imm_identifier(state, tmp, &name);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ExceptHandler;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ExceptHandler' node")) {
                goto failed_ExceptHandler;
            }
            res = obj2imm_stmt_seq(state, tmp, "ExceptHandler", "body", &body);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ExceptHandler;
            Py_CLEAR(tmp);
        }
        excepthandler_ty res = (excepthandler_ty)_PyObject_New((PyTypeObject
                                *)state->_ExceptHandler_type);
        if (res == NULL) goto failed_ExceptHandler;
        res->kind = ExceptHandler_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.ExceptHandler.type = type;
        res->v.ExceptHandler.name = name;
        res->v.ExceptHandler.body = body;
        *out = res;
        return 0;
        failed_ExceptHandler:
        Py_XDECREF(type);
        Py_XDECREF(name);
        Py_XDECREF(body);
    }
    *out = (excepthandler_ty)Py_NewRef(obj);
    return 0;
failed_excepthandler:
    return -1;
}

static int obj2imm_arguments_seq(struct ast_state *state, PyObject* obj, const
                                 char *container, const char *field,
                                 asdl_arguments_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_arguments_seq_type) {
        *out = (asdl_arguments_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_arguments_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_arguments_seq, (PyTypeObject
                          *)state->_arguments_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        arguments_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
            goto failed;
        }
        int err = obj2imm_arguments(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_arguments(struct ast_state *state, PyObject* obj, arguments_ty* out,
                  PyArena* arena)
{
    PyObject* tmp = NULL;
    asdl_arg_seq* posonlyargs = NULL;
    asdl_arg_seq* args = NULL;
    arg_ty vararg = NULL;
    asdl_arg_seq* kwonlyargs = NULL;
    asdl_expr_seq* kw_defaults = NULL;
    arg_ty kwarg = NULL;
    asdl_expr_seq* defaults = NULL;

    if (PyObject_GetOptionalAttr(obj, state->posonlyargs, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        tmp = PyList_New(0);
        if (tmp == NULL) {
            return -1;
        }
    }
    {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, "arguments field \"posonlyargs\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        posonlyargs = _Py_asdl_arg_seq_new(len, arena);
        if (posonlyargs == NULL) goto failed;
        for (i = 0; i < len; i++) {
            arg_ty val;
            PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
            if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
                goto failed;
            }
            res = obj2ast_arg(state, tmp2, &val, arena);
            _Py_LeaveRecursiveCall();
            Py_DECREF(tmp2);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, "arguments field \"posonlyargs\" changed size during iteration");
                goto failed;
            }
            asdl_seq_SET(posonlyargs, i, val);
        }
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->args, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        tmp = PyList_New(0);
        if (tmp == NULL) {
            return -1;
        }
    }
    {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, "arguments field \"args\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        args = _Py_asdl_arg_seq_new(len, arena);
        if (args == NULL) goto failed;
        for (i = 0; i < len; i++) {
            arg_ty val;
            PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
            if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
                goto failed;
            }
            res = obj2ast_arg(state, tmp2, &val, arena);
            _Py_LeaveRecursiveCall();
            Py_DECREF(tmp2);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, "arguments field \"args\" changed size during iteration");
                goto failed;
            }
            asdl_seq_SET(args, i, val);
        }
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->vararg, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        vararg = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
            goto failed;
        }
        res = obj2ast_arg(state, tmp, &vararg, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->kwonlyargs, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        tmp = PyList_New(0);
        if (tmp == NULL) {
            return -1;
        }
    }
    {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, "arguments field \"kwonlyargs\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        kwonlyargs = _Py_asdl_arg_seq_new(len, arena);
        if (kwonlyargs == NULL) goto failed;
        for (i = 0; i < len; i++) {
            arg_ty val;
            PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
            if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
                goto failed;
            }
            res = obj2ast_arg(state, tmp2, &val, arena);
            _Py_LeaveRecursiveCall();
            Py_DECREF(tmp2);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, "arguments field \"kwonlyargs\" changed size during iteration");
                goto failed;
            }
            asdl_seq_SET(kwonlyargs, i, val);
        }
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->kw_defaults, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        tmp = PyList_New(0);
        if (tmp == NULL) {
            return -1;
        }
    }
    {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, "arguments field \"kw_defaults\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        kw_defaults = _Py_asdl_expr_seq_new(len, arena);
        if (kw_defaults == NULL) goto failed;
        for (i = 0; i < len; i++) {
            expr_ty val;
            PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
            if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp2, &val, arena);
            _Py_LeaveRecursiveCall();
            Py_DECREF(tmp2);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, "arguments field \"kw_defaults\" changed size during iteration");
                goto failed;
            }
            asdl_seq_SET(kw_defaults, i, val);
        }
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->kwarg, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        kwarg = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
            goto failed;
        }
        res = obj2ast_arg(state, tmp, &kwarg, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->defaults, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        tmp = PyList_New(0);
        if (tmp == NULL) {
            return -1;
        }
    }
    {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, "arguments field \"defaults\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        defaults = _Py_asdl_expr_seq_new(len, arena);
        if (defaults == NULL) goto failed;
        for (i = 0; i < len; i++) {
            expr_ty val;
            PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
            if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp2, &val, arena);
            _Py_LeaveRecursiveCall();
            Py_DECREF(tmp2);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, "arguments field \"defaults\" changed size during iteration");
                goto failed;
            }
            asdl_seq_SET(defaults, i, val);
        }
        Py_CLEAR(tmp);
    }
    *out = _PyAST_arguments(posonlyargs, args, vararg, kwonlyargs, kw_defaults,
                            kwarg, defaults, arena);
    if (*out == NULL) goto failed;
    return 0;
failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_arguments(struct ast_state *state, PyObject* obj, arguments_ty* out)
{
    asdl_arg_seq* posonlyargs = NULL;
    asdl_arg_seq* args = NULL;
    arg_ty vararg = NULL;
    asdl_arg_seq* kwonlyargs = NULL;
    asdl_expr_seq* kw_defaults = NULL;
    arg_ty kwarg = NULL;
    asdl_expr_seq* defaults = NULL;

    if (Py_TYPE(obj) == (PyTypeObject *)state->_arguments_type) {
        *out = (arguments_ty)Py_NewRef(obj);
        return *out != NULL ? 0 : -1;
    }

    PyObject* tmp = NULL;
    if (PyObject_GetOptionalAttr(obj, state->posonlyargs, &tmp) < 0) {
        return -1;
    }
    {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
            goto failed_arguments;
        }
        res = obj2imm_arg_seq(state, tmp, "arguments", "posonlyargs",
                              &posonlyargs);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arguments;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->args, &tmp) < 0) {
        return -1;
    }
    {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
            goto failed_arguments;
        }
        res = obj2imm_arg_seq(state, tmp, "arguments", "args", &args);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arguments;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->vararg, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        vararg = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
            goto failed_arguments;
        }
        res = obj2imm_arg(state, tmp, &vararg);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arguments;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->kwonlyargs, &tmp) < 0) {
        return -1;
    }
    {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
            goto failed_arguments;
        }
        res = obj2imm_arg_seq(state, tmp, "arguments", "kwonlyargs",
                              &kwonlyargs);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arguments;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->kw_defaults, &tmp) < 0) {
        return -1;
    }
    {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
            goto failed_arguments;
        }
        res = obj2imm_expr_seq(state, tmp, "arguments", "kw_defaults",
                               &kw_defaults);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arguments;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->kwarg, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        kwarg = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
            goto failed_arguments;
        }
        res = obj2imm_arg(state, tmp, &kwarg);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arguments;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->defaults, &tmp) < 0) {
        return -1;
    }
    {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arguments' node")) {
            goto failed_arguments;
        }
        res = obj2imm_expr_seq(state, tmp, "arguments", "defaults", &defaults);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arguments;
        Py_CLEAR(tmp);
    }
    *out = _PyAST_argumentsHeap(state, posonlyargs, args, vararg, kwonlyargs,
                                kw_defaults, kwarg, defaults);
    if (*out == NULL) goto failed_arguments;
    return 0;
failed_arguments:
    Py_XDECREF(posonlyargs);
    Py_XDECREF(args);
    Py_XDECREF(vararg);
    Py_XDECREF(kwonlyargs);
    Py_XDECREF(kw_defaults);
    Py_XDECREF(kwarg);
    Py_XDECREF(defaults);
    Py_XDECREF(tmp);
    return -1;
}

static int obj2imm_arg_seq(struct ast_state *state, PyObject* obj, const char
                           *container, const char *field, asdl_arg_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_arg_seq_type) {
        *out = (asdl_arg_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_arg_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_arg_seq, (PyTypeObject *)state->_arg_seq_type,
                          len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        arg_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed;
        }
        int err = obj2imm_arg(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_arg(struct ast_state *state, PyObject* obj, arg_ty* out, PyArena* arena)
{
    PyObject* tmp = NULL;
    identifier arg = NULL;
    expr_ty annotation = NULL;
    string type_comment;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;

    if (PyObject_GetOptionalAttr(obj, state->arg, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"arg\" missing from arg");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed;
        }
        res = obj2ast_identifier(state, tmp, &arg, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->annotation, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        annotation = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed;
        }
        res = obj2ast_expr(state, tmp, &annotation, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        type_comment = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed;
        }
        res = obj2ast_string(state, tmp, &type_comment, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from arg");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from arg");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_lineno = lineno;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_col_offset = col_offset;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    *out = _PyAST_arg(arg, annotation, type_comment, lineno, col_offset,
                      end_lineno, end_col_offset, arena);
    if (*out == NULL) goto failed;
    return 0;
failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_arg(struct ast_state *state, PyObject* obj, arg_ty* out)
{
    identifier arg = NULL;
    expr_ty annotation = NULL;
    string type_comment;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;

    if (Py_TYPE(obj) == (PyTypeObject *)state->_arg_type) {
        *out = (arg_ty)Py_NewRef(obj);
        return *out != NULL ? 0 : -1;
    }

    PyObject* tmp = NULL;
    if (PyObject_GetOptionalAttr(obj, state->arg, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"arg\" missing from arg");
        goto failed_arg;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed_arg;
        }
        res = obj2imm_identifier(state, tmp, &arg);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arg;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->annotation, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        annotation = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed_arg;
        }
        res = obj2imm_expr(state, tmp, &annotation);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arg;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->type_comment, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        type_comment = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed_arg;
        }
        res = obj2imm_string(state, tmp, &type_comment);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arg;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from arg");
        goto failed_arg;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed_arg;
        }
        res = obj2imm_int(state, tmp, &lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arg;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from arg");
        goto failed_arg;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed_arg;
        }
        res = obj2imm_int(state, tmp, &col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arg;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_lineno = lineno;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed_arg;
        }
        res = obj2imm_int(state, tmp, &end_lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arg;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_col_offset = col_offset;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'arg' node")) {
            goto failed_arg;
        }
        res = obj2imm_int(state, tmp, &end_col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_arg;
        Py_CLEAR(tmp);
    }
    *out = _PyAST_argHeap(state, arg, annotation, type_comment, lineno,
                          col_offset, end_lineno, end_col_offset);
    if (*out == NULL) goto failed_arg;
    return 0;
failed_arg:
    Py_XDECREF(arg);
    Py_XDECREF(annotation);
    Py_XDECREF(tmp);
    return -1;
}

static int obj2imm_keyword_seq(struct ast_state *state, PyObject* obj, const
                               char *container, const char *field,
                               asdl_keyword_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_keyword_seq_type) {
        *out = (asdl_keyword_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_keyword_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_keyword_seq, (PyTypeObject
                          *)state->_keyword_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        keyword_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'keyword' node")) {
            goto failed;
        }
        int err = obj2imm_keyword(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_keyword(struct ast_state *state, PyObject* obj, keyword_ty* out,
                PyArena* arena)
{
    PyObject* tmp = NULL;
    identifier arg = NULL;
    expr_ty value = NULL;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;

    if (PyObject_GetOptionalAttr(obj, state->arg, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        arg = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'keyword' node")) {
            goto failed;
        }
        res = obj2ast_identifier(state, tmp, &arg, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from keyword");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'keyword' node")) {
            goto failed;
        }
        res = obj2ast_expr(state, tmp, &value, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from keyword");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'keyword' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from keyword");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'keyword' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_lineno = lineno;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'keyword' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_col_offset = col_offset;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'keyword' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    *out = _PyAST_keyword(arg, value, lineno, col_offset, end_lineno,
                          end_col_offset, arena);
    if (*out == NULL) goto failed;
    return 0;
failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_keyword(struct ast_state *state, PyObject* obj, keyword_ty* out)
{
    identifier arg = NULL;
    expr_ty value = NULL;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;

    if (Py_TYPE(obj) == (PyTypeObject *)state->_keyword_type) {
        *out = (keyword_ty)Py_NewRef(obj);
        return *out != NULL ? 0 : -1;
    }

    PyObject* tmp = NULL;
    if (PyObject_GetOptionalAttr(obj, state->arg, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        arg = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'keyword' node")) {
            goto failed_keyword;
        }
        res = obj2imm_identifier(state, tmp, &arg);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_keyword;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from keyword");
        goto failed_keyword;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'keyword' node")) {
            goto failed_keyword;
        }
        res = obj2imm_expr(state, tmp, &value);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_keyword;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from keyword");
        goto failed_keyword;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'keyword' node")) {
            goto failed_keyword;
        }
        res = obj2imm_int(state, tmp, &lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_keyword;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from keyword");
        goto failed_keyword;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'keyword' node")) {
            goto failed_keyword;
        }
        res = obj2imm_int(state, tmp, &col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_keyword;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_lineno = lineno;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'keyword' node")) {
            goto failed_keyword;
        }
        res = obj2imm_int(state, tmp, &end_lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_keyword;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_col_offset = col_offset;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'keyword' node")) {
            goto failed_keyword;
        }
        res = obj2imm_int(state, tmp, &end_col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_keyword;
        Py_CLEAR(tmp);
    }
    *out = _PyAST_keywordHeap(state, arg, value, lineno, col_offset,
                              end_lineno, end_col_offset);
    if (*out == NULL) goto failed_keyword;
    return 0;
failed_keyword:
    Py_XDECREF(arg);
    Py_XDECREF(value);
    Py_XDECREF(tmp);
    return -1;
}

static int obj2imm_alias_seq(struct ast_state *state, PyObject* obj, const char
                             *container, const char *field, asdl_alias_seq**
                             out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_alias_seq_type) {
        *out = (asdl_alias_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_alias_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_alias_seq, (PyTypeObject
                          *)state->_alias_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        alias_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'alias' node")) {
            goto failed;
        }
        int err = obj2imm_alias(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_alias(struct ast_state *state, PyObject* obj, alias_ty* out, PyArena*
              arena)
{
    PyObject* tmp = NULL;
    identifier name = NULL;
    identifier asname = NULL;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;

    if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from alias");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'alias' node")) {
            goto failed;
        }
        res = obj2ast_identifier(state, tmp, &name, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->asname, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        asname = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'alias' node")) {
            goto failed;
        }
        res = obj2ast_identifier(state, tmp, &asname, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from alias");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'alias' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from alias");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'alias' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_lineno = lineno;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'alias' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_col_offset = col_offset;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'alias' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    *out = _PyAST_alias(name, asname, lineno, col_offset, end_lineno,
                        end_col_offset, arena);
    if (*out == NULL) goto failed;
    return 0;
failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_alias(struct ast_state *state, PyObject* obj, alias_ty* out)
{
    identifier name = NULL;
    identifier asname = NULL;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;

    if (Py_TYPE(obj) == (PyTypeObject *)state->_alias_type) {
        *out = (alias_ty)Py_NewRef(obj);
        return *out != NULL ? 0 : -1;
    }

    PyObject* tmp = NULL;
    if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from alias");
        goto failed_alias;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'alias' node")) {
            goto failed_alias;
        }
        res = obj2imm_identifier(state, tmp, &name);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_alias;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->asname, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        asname = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'alias' node")) {
            goto failed_alias;
        }
        res = obj2imm_identifier(state, tmp, &asname);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_alias;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from alias");
        goto failed_alias;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'alias' node")) {
            goto failed_alias;
        }
        res = obj2imm_int(state, tmp, &lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_alias;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from alias");
        goto failed_alias;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'alias' node")) {
            goto failed_alias;
        }
        res = obj2imm_int(state, tmp, &col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_alias;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_lineno = lineno;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'alias' node")) {
            goto failed_alias;
        }
        res = obj2imm_int(state, tmp, &end_lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_alias;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        end_col_offset = col_offset;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'alias' node")) {
            goto failed_alias;
        }
        res = obj2imm_int(state, tmp, &end_col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_alias;
        Py_CLEAR(tmp);
    }
    *out = _PyAST_aliasHeap(state, name, asname, lineno, col_offset,
                            end_lineno, end_col_offset);
    if (*out == NULL) goto failed_alias;
    return 0;
failed_alias:
    Py_XDECREF(name);
    Py_XDECREF(asname);
    Py_XDECREF(tmp);
    return -1;
}

static int obj2imm_withitem_seq(struct ast_state *state, PyObject* obj, const
                                char *container, const char *field,
                                asdl_withitem_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_withitem_seq_type) {
        *out = (asdl_withitem_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_withitem_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_withitem_seq, (PyTypeObject
                          *)state->_withitem_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        withitem_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'withitem' node")) {
            goto failed;
        }
        int err = obj2imm_withitem(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_withitem(struct ast_state *state, PyObject* obj, withitem_ty* out,
                 PyArena* arena)
{
    PyObject* tmp = NULL;
    expr_ty context_expr = NULL;
    expr_ty optional_vars = NULL;

    if (PyObject_GetOptionalAttr(obj, state->context_expr, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"context_expr\" missing from withitem");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'withitem' node")) {
            goto failed;
        }
        res = obj2ast_expr(state, tmp, &context_expr, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->optional_vars, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        optional_vars = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'withitem' node")) {
            goto failed;
        }
        res = obj2ast_expr(state, tmp, &optional_vars, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    *out = _PyAST_withitem(context_expr, optional_vars, arena);
    if (*out == NULL) goto failed;
    return 0;
failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_withitem(struct ast_state *state, PyObject* obj, withitem_ty* out)
{
    expr_ty context_expr = NULL;
    expr_ty optional_vars = NULL;

    if (Py_TYPE(obj) == (PyTypeObject *)state->_withitem_type) {
        *out = (withitem_ty)Py_NewRef(obj);
        return *out != NULL ? 0 : -1;
    }

    PyObject* tmp = NULL;
    if (PyObject_GetOptionalAttr(obj, state->context_expr, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"context_expr\" missing from withitem");
        goto failed_withitem;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'withitem' node")) {
            goto failed_withitem;
        }
        res = obj2imm_expr(state, tmp, &context_expr);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_withitem;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->optional_vars, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        optional_vars = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'withitem' node")) {
            goto failed_withitem;
        }
        res = obj2imm_expr(state, tmp, &optional_vars);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_withitem;
        Py_CLEAR(tmp);
    }
    *out = _PyAST_withitemHeap(state, context_expr, optional_vars);
    if (*out == NULL) goto failed_withitem;
    return 0;
failed_withitem:
    Py_XDECREF(context_expr);
    Py_XDECREF(optional_vars);
    Py_XDECREF(tmp);
    return -1;
}

static int obj2imm_match_case_seq(struct ast_state *state, PyObject* obj, const
                                  char *container, const char *field,
                                  asdl_match_case_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_match_case_seq_type) {
        *out = (asdl_match_case_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_match_case_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_match_case_seq, (PyTypeObject
                          *)state->_match_case_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        match_case_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'match_case' node")) {
            goto failed;
        }
        int err = obj2imm_match_case(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_match_case(struct ast_state *state, PyObject* obj, match_case_ty* out,
                   PyArena* arena)
{
    PyObject* tmp = NULL;
    pattern_ty pattern = NULL;
    expr_ty guard = NULL;
    asdl_stmt_seq* body = NULL;

    if (PyObject_GetOptionalAttr(obj, state->pattern, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"pattern\" missing from match_case");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'match_case' node")) {
            goto failed;
        }
        res = obj2ast_pattern(state, tmp, &pattern, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->guard, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        guard = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'match_case' node")) {
            goto failed;
        }
        res = obj2ast_expr(state, tmp, &guard, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        tmp = PyList_New(0);
        if (tmp == NULL) {
            return -1;
        }
    }
    {
        int res;
        Py_ssize_t len;
        Py_ssize_t i;
        if (!PyList_Check(tmp)) {
            PyErr_Format(PyExc_TypeError, "match_case field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
            goto failed;
        }
        len = PyList_GET_SIZE(tmp);
        body = _Py_asdl_stmt_seq_new(len, arena);
        if (body == NULL) goto failed;
        for (i = 0; i < len; i++) {
            stmt_ty val;
            PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
            if (_Py_EnterRecursiveCall(" while traversing 'match_case' node")) {
                goto failed;
            }
            res = obj2ast_stmt(state, tmp2, &val, arena);
            _Py_LeaveRecursiveCall();
            Py_DECREF(tmp2);
            if (res != 0) goto failed;
            if (len != PyList_GET_SIZE(tmp)) {
                PyErr_SetString(PyExc_RuntimeError, "match_case field \"body\" changed size during iteration");
                goto failed;
            }
            asdl_seq_SET(body, i, val);
        }
        Py_CLEAR(tmp);
    }
    *out = _PyAST_match_case(pattern, guard, body, arena);
    if (*out == NULL) goto failed;
    return 0;
failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_match_case(struct ast_state *state, PyObject* obj, match_case_ty* out)
{
    pattern_ty pattern = NULL;
    expr_ty guard = NULL;
    asdl_stmt_seq* body = NULL;

    if (Py_TYPE(obj) == (PyTypeObject *)state->_match_case_type) {
        *out = (match_case_ty)Py_NewRef(obj);
        return *out != NULL ? 0 : -1;
    }

    PyObject* tmp = NULL;
    if (PyObject_GetOptionalAttr(obj, state->pattern, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"pattern\" missing from match_case");
        goto failed_match_case;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'match_case' node")) {
            goto failed_match_case;
        }
        res = obj2imm_pattern(state, tmp, &pattern);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_match_case;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->guard, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL || tmp == Py_None) {
        Py_CLEAR(tmp);
        guard = NULL;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'match_case' node")) {
            goto failed_match_case;
        }
        res = obj2imm_expr(state, tmp, &guard);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_match_case;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->body, &tmp) < 0) {
        return -1;
    }
    {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'match_case' node")) {
            goto failed_match_case;
        }
        res = obj2imm_stmt_seq(state, tmp, "match_case", "body", &body);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_match_case;
        Py_CLEAR(tmp);
    }
    *out = _PyAST_match_caseHeap(state, pattern, guard, body);
    if (*out == NULL) goto failed_match_case;
    return 0;
failed_match_case:
    Py_XDECREF(pattern);
    Py_XDECREF(guard);
    Py_XDECREF(body);
    Py_XDECREF(tmp);
    return -1;
}

static int obj2imm_pattern_seq(struct ast_state *state, PyObject* obj, const
                               char *container, const char *field,
                               asdl_pattern_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_pattern_seq_type) {
        *out = (asdl_pattern_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_pattern_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_pattern_seq, (PyTypeObject
                          *)state->_pattern_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        pattern_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'pattern' node")) {
            goto failed;
        }
        int err = obj2imm_pattern(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_pattern(struct ast_state *state, PyObject* obj, pattern_ty* out,
                PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    PyObject *tp;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from pattern");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'pattern' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from pattern");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'pattern' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"end_lineno\" missing from pattern");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'pattern' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"end_col_offset\" missing from pattern");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'pattern' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    tp = state->MatchValue_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from MatchValue");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchValue' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_MatchValue(value, lineno, col_offset, end_lineno,
                                 end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->MatchSingleton_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        constant value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from MatchSingleton");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchSingleton' node")) {
                goto failed;
            }
            res = obj2ast_constant(state, tmp, &value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_MatchSingleton(value, lineno, col_offset, end_lineno,
                                     end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->MatchSequence_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_pattern_seq* patterns = NULL;

        if (PyObject_GetOptionalAttr(obj, state->patterns, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "MatchSequence field \"patterns\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            patterns = _Py_asdl_pattern_seq_new(len, arena);
            if (patterns == NULL) goto failed;
            for (i = 0; i < len; i++) {
                pattern_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'MatchSequence' node")) {
                    goto failed;
                }
                res = obj2ast_pattern(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "MatchSequence field \"patterns\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(patterns, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_MatchSequence(patterns, lineno, col_offset, end_lineno,
                                    end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->MatchMapping_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* keys = NULL;
        asdl_pattern_seq* patterns = NULL;
        identifier rest = NULL;

        if (PyObject_GetOptionalAttr(obj, state->keys, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "MatchMapping field \"keys\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            keys = _Py_asdl_expr_seq_new(len, arena);
            if (keys == NULL) goto failed;
            for (i = 0; i < len; i++) {
                expr_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'MatchMapping' node")) {
                    goto failed;
                }
                res = obj2ast_expr(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "MatchMapping field \"keys\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(keys, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->patterns, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "MatchMapping field \"patterns\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            patterns = _Py_asdl_pattern_seq_new(len, arena);
            if (patterns == NULL) goto failed;
            for (i = 0; i < len; i++) {
                pattern_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'MatchMapping' node")) {
                    goto failed;
                }
                res = obj2ast_pattern(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "MatchMapping field \"patterns\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(patterns, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->rest, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            rest = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchMapping' node")) {
                goto failed;
            }
            res = obj2ast_identifier(state, tmp, &rest, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_MatchMapping(keys, patterns, rest, lineno, col_offset,
                                   end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->MatchClass_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty cls = NULL;
        asdl_pattern_seq* patterns = NULL;
        asdl_identifier_seq* kwd_attrs = NULL;
        asdl_pattern_seq* kwd_patterns = NULL;

        if (PyObject_GetOptionalAttr(obj, state->cls, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"cls\" missing from MatchClass");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchClass' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &cls, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->patterns, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "MatchClass field \"patterns\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            patterns = _Py_asdl_pattern_seq_new(len, arena);
            if (patterns == NULL) goto failed;
            for (i = 0; i < len; i++) {
                pattern_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'MatchClass' node")) {
                    goto failed;
                }
                res = obj2ast_pattern(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "MatchClass field \"patterns\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(patterns, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->kwd_attrs, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "MatchClass field \"kwd_attrs\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            kwd_attrs = _Py_asdl_identifier_seq_new(len, arena);
            if (kwd_attrs == NULL) goto failed;
            for (i = 0; i < len; i++) {
                identifier val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'MatchClass' node")) {
                    goto failed;
                }
                res = obj2ast_identifier(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "MatchClass field \"kwd_attrs\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(kwd_attrs, i, val);
            }
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->kwd_patterns, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "MatchClass field \"kwd_patterns\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            kwd_patterns = _Py_asdl_pattern_seq_new(len, arena);
            if (kwd_patterns == NULL) goto failed;
            for (i = 0; i < len; i++) {
                pattern_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'MatchClass' node")) {
                    goto failed;
                }
                res = obj2ast_pattern(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "MatchClass field \"kwd_patterns\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(kwd_patterns, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_MatchClass(cls, patterns, kwd_attrs, kwd_patterns,
                                 lineno, col_offset, end_lineno,
                                 end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->MatchStar_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            name = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchStar' node")) {
                goto failed;
            }
            res = obj2ast_identifier(state, tmp, &name, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_MatchStar(name, lineno, col_offset, end_lineno,
                                end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->MatchAs_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        pattern_ty pattern = NULL;
        identifier name = NULL;

        if (PyObject_GetOptionalAttr(obj, state->pattern, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            pattern = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchAs' node")) {
                goto failed;
            }
            res = obj2ast_pattern(state, tmp, &pattern, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            name = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchAs' node")) {
                goto failed;
            }
            res = obj2ast_identifier(state, tmp, &name, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_MatchAs(pattern, name, lineno, col_offset, end_lineno,
                              end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->MatchOr_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_pattern_seq* patterns = NULL;

        if (PyObject_GetOptionalAttr(obj, state->patterns, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            tmp = PyList_New(0);
            if (tmp == NULL) {
                return -1;
            }
        }
        {
            int res;
            Py_ssize_t len;
            Py_ssize_t i;
            if (!PyList_Check(tmp)) {
                PyErr_Format(PyExc_TypeError, "MatchOr field \"patterns\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
                goto failed;
            }
            len = PyList_GET_SIZE(tmp);
            patterns = _Py_asdl_pattern_seq_new(len, arena);
            if (patterns == NULL) goto failed;
            for (i = 0; i < len; i++) {
                pattern_ty val;
                PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(tmp, i));
                if (_Py_EnterRecursiveCall(" while traversing 'MatchOr' node")) {
                    goto failed;
                }
                res = obj2ast_pattern(state, tmp2, &val, arena);
                _Py_LeaveRecursiveCall();
                Py_DECREF(tmp2);
                if (res != 0) goto failed;
                if (len != PyList_GET_SIZE(tmp)) {
                    PyErr_SetString(PyExc_RuntimeError, "MatchOr field \"patterns\" changed size during iteration");
                    goto failed;
                }
                asdl_seq_SET(patterns, i, val);
            }
            Py_CLEAR(tmp);
        }
        *out = _PyAST_MatchOr(patterns, lineno, col_offset, end_lineno,
                              end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of pattern, but got %R", obj);
    failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_pattern(struct ast_state *state, PyObject* obj, pattern_ty* out)
{
    int isinstance;

    PyObject *tp;
    PyObject *tmp = NULL;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;
    if (Py_TYPE(obj) == (PyTypeObject *)state->_MatchValue_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_MatchSingleton_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_MatchSequence_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_MatchMapping_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_MatchClass_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_MatchStar_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_MatchAs_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_MatchOr_type) {
        *out = (pattern_ty)Py_NewRef(obj);
        return 0;
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from pattern");
        goto failed_pattern;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'pattern' node")) {
            goto failed_pattern;
        }
        res = obj2imm_int(state, tmp, &lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_pattern;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from pattern");
        goto failed_pattern;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'pattern' node")) {
            goto failed_pattern;
        }
        res = obj2imm_int(state, tmp, &col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_pattern;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"end_lineno\" missing from pattern");
        goto failed_pattern;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'pattern' node")) {
            goto failed_pattern;
        }
        res = obj2imm_int(state, tmp, &end_lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_pattern;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"end_col_offset\" missing from pattern");
        goto failed_pattern;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'pattern' node")) {
            goto failed_pattern;
        }
        res = obj2imm_int(state, tmp, &end_col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_pattern;
        Py_CLEAR(tmp);
    }
    tp = state->_MatchValue_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from MatchValue");
            goto failed_MatchValue;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchValue' node")) {
                goto failed_MatchValue;
            }
            res = obj2imm_expr(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchValue;
            Py_CLEAR(tmp);
        }
        pattern_ty res = (pattern_ty)_PyObject_New((PyTypeObject
                          *)state->_MatchValue_type);
        if (res == NULL) goto failed_MatchValue;
        res->kind = MatchValue_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.MatchValue.value = value;
        *out = res;
        return 0;
        failed_MatchValue:
        Py_XDECREF(value);
    }
    tp = state->_MatchSingleton_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        constant value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"value\" missing from MatchSingleton");
            goto failed_MatchSingleton;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchSingleton' node")) {
                goto failed_MatchSingleton;
            }
            res = obj2imm_constant(state, tmp, &value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchSingleton;
            Py_CLEAR(tmp);
        }
        pattern_ty res = (pattern_ty)_PyObject_New((PyTypeObject
                          *)state->_MatchSingleton_type);
        if (res == NULL) goto failed_MatchSingleton;
        res->kind = MatchSingleton_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.MatchSingleton.value = value;
        *out = res;
        return 0;
        failed_MatchSingleton:
        Py_XDECREF(value);
    }
    tp = state->_MatchSequence_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_pattern_seq* patterns = NULL;

        if (PyObject_GetOptionalAttr(obj, state->patterns, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchSequence' node")) {
                goto failed_MatchSequence;
            }
            res = obj2imm_pattern_seq(state, tmp, "MatchSequence", "patterns",
                                      &patterns);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchSequence;
            Py_CLEAR(tmp);
        }
        pattern_ty res = (pattern_ty)_PyObject_New((PyTypeObject
                          *)state->_MatchSequence_type);
        if (res == NULL) goto failed_MatchSequence;
        res->kind = MatchSequence_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.MatchSequence.patterns = patterns;
        *out = res;
        return 0;
        failed_MatchSequence:
        Py_XDECREF(patterns);
    }
    tp = state->_MatchMapping_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_expr_seq* keys = NULL;
        asdl_pattern_seq* patterns = NULL;
        identifier rest = NULL;

        if (PyObject_GetOptionalAttr(obj, state->keys, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchMapping' node")) {
                goto failed_MatchMapping;
            }
            res = obj2imm_expr_seq(state, tmp, "MatchMapping", "keys", &keys);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchMapping;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->patterns, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchMapping' node")) {
                goto failed_MatchMapping;
            }
            res = obj2imm_pattern_seq(state, tmp, "MatchMapping", "patterns",
                                      &patterns);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchMapping;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->rest, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            rest = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchMapping' node")) {
                goto failed_MatchMapping;
            }
            res = obj2imm_identifier(state, tmp, &rest);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchMapping;
            Py_CLEAR(tmp);
        }
        pattern_ty res = (pattern_ty)_PyObject_New((PyTypeObject
                          *)state->_MatchMapping_type);
        if (res == NULL) goto failed_MatchMapping;
        res->kind = MatchMapping_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.MatchMapping.keys = keys;
        res->v.MatchMapping.patterns = patterns;
        res->v.MatchMapping.rest = rest;
        *out = res;
        return 0;
        failed_MatchMapping:
        Py_XDECREF(keys);
        Py_XDECREF(patterns);
        Py_XDECREF(rest);
    }
    tp = state->_MatchClass_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        expr_ty cls = NULL;
        asdl_pattern_seq* patterns = NULL;
        asdl_identifier_seq* kwd_attrs = NULL;
        asdl_pattern_seq* kwd_patterns = NULL;

        if (PyObject_GetOptionalAttr(obj, state->cls, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"cls\" missing from MatchClass");
            goto failed_MatchClass;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchClass' node")) {
                goto failed_MatchClass;
            }
            res = obj2imm_expr(state, tmp, &cls);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchClass;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->patterns, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchClass' node")) {
                goto failed_MatchClass;
            }
            res = obj2imm_pattern_seq(state, tmp, "MatchClass", "patterns",
                                      &patterns);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchClass;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->kwd_attrs, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchClass' node")) {
                goto failed_MatchClass;
            }
            res = obj2imm_identifier_seq(state, tmp, "MatchClass", "kwd_attrs",
                                         &kwd_attrs);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchClass;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->kwd_patterns, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchClass' node")) {
                goto failed_MatchClass;
            }
            res = obj2imm_pattern_seq(state, tmp, "MatchClass", "kwd_patterns",
                                      &kwd_patterns);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchClass;
            Py_CLEAR(tmp);
        }
        pattern_ty res = (pattern_ty)_PyObject_New((PyTypeObject
                          *)state->_MatchClass_type);
        if (res == NULL) goto failed_MatchClass;
        res->kind = MatchClass_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.MatchClass.cls = cls;
        res->v.MatchClass.patterns = patterns;
        res->v.MatchClass.kwd_attrs = kwd_attrs;
        res->v.MatchClass.kwd_patterns = kwd_patterns;
        *out = res;
        return 0;
        failed_MatchClass:
        Py_XDECREF(cls);
        Py_XDECREF(patterns);
        Py_XDECREF(kwd_attrs);
        Py_XDECREF(kwd_patterns);
    }
    tp = state->_MatchStar_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            name = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchStar' node")) {
                goto failed_MatchStar;
            }
            res = obj2imm_identifier(state, tmp, &name);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchStar;
            Py_CLEAR(tmp);
        }
        pattern_ty res = (pattern_ty)_PyObject_New((PyTypeObject
                          *)state->_MatchStar_type);
        if (res == NULL) goto failed_MatchStar;
        res->kind = MatchStar_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.MatchStar.name = name;
        *out = res;
        return 0;
        failed_MatchStar:
        Py_XDECREF(name);
    }
    tp = state->_MatchAs_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        pattern_ty pattern = NULL;
        identifier name = NULL;

        if (PyObject_GetOptionalAttr(obj, state->pattern, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            pattern = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchAs' node")) {
                goto failed_MatchAs;
            }
            res = obj2imm_pattern(state, tmp, &pattern);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchAs;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            name = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchAs' node")) {
                goto failed_MatchAs;
            }
            res = obj2imm_identifier(state, tmp, &name);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchAs;
            Py_CLEAR(tmp);
        }
        pattern_ty res = (pattern_ty)_PyObject_New((PyTypeObject
                          *)state->_MatchAs_type);
        if (res == NULL) goto failed_MatchAs;
        res->kind = MatchAs_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.MatchAs.pattern = pattern;
        res->v.MatchAs.name = name;
        *out = res;
        return 0;
        failed_MatchAs:
        Py_XDECREF(pattern);
        Py_XDECREF(name);
    }
    tp = state->_MatchOr_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        asdl_pattern_seq* patterns = NULL;

        if (PyObject_GetOptionalAttr(obj, state->patterns, &tmp) < 0) {
            return -1;
        }
        {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'MatchOr' node")) {
                goto failed_MatchOr;
            }
            res = obj2imm_pattern_seq(state, tmp, "MatchOr", "patterns",
                                      &patterns);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_MatchOr;
            Py_CLEAR(tmp);
        }
        pattern_ty res = (pattern_ty)_PyObject_New((PyTypeObject
                          *)state->_MatchOr_type);
        if (res == NULL) goto failed_MatchOr;
        res->kind = MatchOr_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.MatchOr.patterns = patterns;
        *out = res;
        return 0;
        failed_MatchOr:
        Py_XDECREF(patterns);
    }
    *out = (pattern_ty)Py_NewRef(obj);
    return 0;
failed_pattern:
    return -1;
}

static int obj2imm_type_ignore_seq(struct ast_state *state, PyObject* obj,
                                   const char *container, const char *field,
                                   asdl_type_ignore_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_type_ignore_seq_type) {
        *out = (asdl_type_ignore_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_type_ignore_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_type_ignore_seq, (PyTypeObject
                          *)state->_type_ignore_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        type_ignore_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'type_ignore' node")) {
            goto failed;
        }
        int err = obj2imm_type_ignore(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_type_ignore(struct ast_state *state, PyObject* obj, type_ignore_ty*
                    out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    PyObject *tp;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    tp = state->TypeIgnore_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        int lineno;
        string tag;

        if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from TypeIgnore");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeIgnore' node")) {
                goto failed;
            }
            res = obj2ast_int(state, tmp, &lineno, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->tag, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"tag\" missing from TypeIgnore");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeIgnore' node")) {
                goto failed;
            }
            res = obj2ast_string(state, tmp, &tag, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_TypeIgnore(lineno, tag, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of type_ignore, but got %R", obj);
    failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_type_ignore(struct ast_state *state, PyObject* obj, type_ignore_ty* out)
{
    int isinstance;

    PyObject *tp;
    PyObject *tmp = NULL;
    if (Py_TYPE(obj) == (PyTypeObject *)state->_TypeIgnore_type) {
        *out = (type_ignore_ty)Py_NewRef(obj);
        return 0;
    }
    tp = state->_TypeIgnore_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        int lineno;
        string tag;

        if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from TypeIgnore");
            goto failed_TypeIgnore;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeIgnore' node")) {
                goto failed_TypeIgnore;
            }
            res = obj2imm_int(state, tmp, &lineno);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TypeIgnore;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->tag, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"tag\" missing from TypeIgnore");
            goto failed_TypeIgnore;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeIgnore' node")) {
                goto failed_TypeIgnore;
            }
            res = obj2imm_string(state, tmp, &tag);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TypeIgnore;
            Py_CLEAR(tmp);
        }
        type_ignore_ty res = (type_ignore_ty)_PyObject_New((PyTypeObject
                              *)state->_TypeIgnore_type);
        if (res == NULL) goto failed_TypeIgnore;
        res->kind = TypeIgnore_kind;
        res->v.TypeIgnore.lineno = lineno;
        res->v.TypeIgnore.tag = tag;
        *out = res;
        return 0;
        failed_TypeIgnore:
    }
    *out = (type_ignore_ty)Py_NewRef(obj);
    return 0;
}

static int obj2imm_type_param_seq(struct ast_state *state, PyObject* obj, const
                                  char *container, const char *field,
                                  asdl_type_param_seq** out)
{
    if (Py_TYPE(obj) == (PyTypeObject *)state->_type_param_seq_type) {
        *out = (asdl_type_param_seq*)Py_NewRef(obj);
        return 0;
    }
    if (obj == NULL) {
        obj = PyList_New(0);
        if (obj == NULL) {
            return -1;
        }
    }
    Py_ssize_t len;
    Py_ssize_t i;
    asdl_type_param_seq* res;
    if (!PyList_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "%s field \"%s\" must be a list, not a %.200s", container, field, _PyType_Name(Py_TYPE(obj)));
        goto failed;
    }
    len = PyList_GET_SIZE(obj);
    res = PyObject_NewVar(asdl_type_param_seq, (PyTypeObject
                          *)state->_type_param_seq_type, len);
    if (res == NULL) goto failed;
    for (i = 0; i < len; i++) {
        type_param_ty val;
        PyObject *tmp2 = Py_NewRef(PyList_GET_ITEM(obj, i));
        if (_Py_EnterRecursiveCall(" while traversing 'type_param' node")) {
            goto failed;
        }
        int err = obj2imm_type_param(state, tmp2, &val);
        _Py_LeaveRecursiveCall();
        Py_DECREF(tmp2);
        if (err != 0) goto failed;
        if (len != PyList_GET_SIZE(obj)) {
            PyErr_Format(PyExc_RuntimeError, "%s field \"%s\" changed size during iteration", container, field);
            goto failed;
        }
        asdl_seq_SET(res, i, val);
    }
failed:
    *out = NULL;
    return -1;
}

int
obj2ast_type_param(struct ast_state *state, PyObject* obj, type_param_ty* out,
                   PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    PyObject *tp;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from type_param");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'type_param' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from type_param");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'type_param' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"end_lineno\" missing from type_param");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'type_param' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_lineno, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"end_col_offset\" missing from type_param");
        return -1;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'type_param' node")) {
            goto failed;
        }
        res = obj2ast_int(state, tmp, &end_col_offset, arena);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed;
        Py_CLEAR(tmp);
    }
    tp = state->TypeVar_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;
        expr_ty bound = NULL;
        expr_ty default_value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from TypeVar");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeVar' node")) {
                goto failed;
            }
            res = obj2ast_identifier(state, tmp, &name, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->bound, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            bound = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeVar' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &bound, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->default_value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            default_value = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeVar' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &default_value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_TypeVar(name, bound, default_value, lineno, col_offset,
                              end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->ParamSpec_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;
        expr_ty default_value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from ParamSpec");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ParamSpec' node")) {
                goto failed;
            }
            res = obj2ast_identifier(state, tmp, &name, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->default_value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            default_value = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ParamSpec' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &default_value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_ParamSpec(name, default_value, lineno, col_offset,
                                end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = state->TypeVarTuple_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;
        expr_ty default_value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from TypeVarTuple");
            return -1;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeVarTuple' node")) {
                goto failed;
            }
            res = obj2ast_identifier(state, tmp, &name, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->default_value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            default_value = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeVarTuple' node")) {
                goto failed;
            }
            res = obj2ast_expr(state, tmp, &default_value, arena);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = _PyAST_TypeVarTuple(name, default_value, lineno, col_offset,
                                   end_lineno, end_col_offset, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of type_param, but got %R", obj);
    failed:
    Py_XDECREF(tmp);
    return -1;
}

int
obj2imm_type_param(struct ast_state *state, PyObject* obj, type_param_ty* out)
{
    int isinstance;

    PyObject *tp;
    PyObject *tmp = NULL;
    int lineno;
    int col_offset;
    int end_lineno;
    int end_col_offset;
    if (Py_TYPE(obj) == (PyTypeObject *)state->_TypeVar_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_ParamSpec_type ||
        Py_TYPE(obj) == (PyTypeObject *)state->_TypeVarTuple_type) {
        *out = (type_param_ty)Py_NewRef(obj);
        return 0;
    }
    if (PyObject_GetOptionalAttr(obj, state->lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"lineno\" missing from type_param");
        goto failed_type_param;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'type_param' node")) {
            goto failed_type_param;
        }
        res = obj2imm_int(state, tmp, &lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_type_param;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"col_offset\" missing from type_param");
        goto failed_type_param;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'type_param' node")) {
            goto failed_type_param;
        }
        res = obj2imm_int(state, tmp, &col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_type_param;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_lineno, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"end_lineno\" missing from type_param");
        goto failed_type_param;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'type_param' node")) {
            goto failed_type_param;
        }
        res = obj2imm_int(state, tmp, &end_lineno);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_type_param;
        Py_CLEAR(tmp);
    }
    if (PyObject_GetOptionalAttr(obj, state->end_col_offset, &tmp) < 0) {
        return -1;
    }
    if (tmp == NULL) {
        PyErr_SetString(PyExc_TypeError, "required field \"end_col_offset\" missing from type_param");
        goto failed_type_param;
    }
    else {
        int res;
        if (_Py_EnterRecursiveCall(" while traversing 'type_param' node")) {
            goto failed_type_param;
        }
        res = obj2imm_int(state, tmp, &end_col_offset);
        _Py_LeaveRecursiveCall();
        if (res != 0) goto failed_type_param;
        Py_CLEAR(tmp);
    }
    tp = state->_TypeVar_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;
        expr_ty bound = NULL;
        expr_ty default_value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from TypeVar");
            goto failed_TypeVar;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeVar' node")) {
                goto failed_TypeVar;
            }
            res = obj2imm_identifier(state, tmp, &name);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TypeVar;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->bound, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            bound = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeVar' node")) {
                goto failed_TypeVar;
            }
            res = obj2imm_expr(state, tmp, &bound);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TypeVar;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->default_value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            default_value = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeVar' node")) {
                goto failed_TypeVar;
            }
            res = obj2imm_expr(state, tmp, &default_value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TypeVar;
            Py_CLEAR(tmp);
        }
        type_param_ty res = (type_param_ty)_PyObject_New((PyTypeObject
                             *)state->_TypeVar_type);
        if (res == NULL) goto failed_TypeVar;
        res->kind = TypeVar_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.TypeVar.name = name;
        res->v.TypeVar.bound = bound;
        res->v.TypeVar.default_value = default_value;
        *out = res;
        return 0;
        failed_TypeVar:
        Py_XDECREF(name);
        Py_XDECREF(bound);
        Py_XDECREF(default_value);
    }
    tp = state->_ParamSpec_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;
        expr_ty default_value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from ParamSpec");
            goto failed_ParamSpec;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ParamSpec' node")) {
                goto failed_ParamSpec;
            }
            res = obj2imm_identifier(state, tmp, &name);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ParamSpec;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->default_value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            default_value = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'ParamSpec' node")) {
                goto failed_ParamSpec;
            }
            res = obj2imm_expr(state, tmp, &default_value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_ParamSpec;
            Py_CLEAR(tmp);
        }
        type_param_ty res = (type_param_ty)_PyObject_New((PyTypeObject
                             *)state->_ParamSpec_type);
        if (res == NULL) goto failed_ParamSpec;
        res->kind = ParamSpec_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.ParamSpec.name = name;
        res->v.ParamSpec.default_value = default_value;
        *out = res;
        return 0;
        failed_ParamSpec:
        Py_XDECREF(name);
        Py_XDECREF(default_value);
    }
    tp = state->_TypeVarTuple_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return -1;
    }
    if (isinstance) {
        identifier name = NULL;
        expr_ty default_value = NULL;

        if (PyObject_GetOptionalAttr(obj, state->name, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"name\" missing from TypeVarTuple");
            goto failed_TypeVarTuple;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeVarTuple' node")) {
                goto failed_TypeVarTuple;
            }
            res = obj2imm_identifier(state, tmp, &name);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TypeVarTuple;
            Py_CLEAR(tmp);
        }
        if (PyObject_GetOptionalAttr(obj, state->default_value, &tmp) < 0) {
            return -1;
        }
        if (tmp == NULL || tmp == Py_None) {
            Py_CLEAR(tmp);
            default_value = NULL;
        }
        else {
            int res;
            if (_Py_EnterRecursiveCall(" while traversing 'TypeVarTuple' node")) {
                goto failed_TypeVarTuple;
            }
            res = obj2imm_expr(state, tmp, &default_value);
            _Py_LeaveRecursiveCall();
            if (res != 0) goto failed_TypeVarTuple;
            Py_CLEAR(tmp);
        }
        type_param_ty res = (type_param_ty)_PyObject_New((PyTypeObject
                             *)state->_TypeVarTuple_type);
        if (res == NULL) goto failed_TypeVarTuple;
        res->kind = TypeVarTuple_kind;
        res->lineno = lineno;
        res->col_offset = col_offset;
        res->end_lineno = end_lineno;
        res->end_col_offset = end_col_offset;
        res->v.TypeVarTuple.name = name;
        res->v.TypeVarTuple.default_value = default_value;
        *out = res;
        return 0;
        failed_TypeVarTuple:
        Py_XDECREF(name);
        Py_XDECREF(default_value);
    }
    *out = (type_param_ty)Py_NewRef(obj);
    return 0;
failed_type_param:
    return -1;
}


static int
astmodule_exec(PyObject *m)
{
    struct ast_state *state = get_ast_state();
    if (state == NULL) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "AST", state->AST_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_AST", state->_AST_type) < 0) {
        return -1;
    }
    if (PyModule_AddIntMacro(m, PyCF_ALLOW_TOP_LEVEL_AWAIT) < 0) {
        return -1;
    }
    if (PyModule_AddIntMacro(m, PyCF_ONLY_AST) < 0) {
        return -1;
    }
    if (PyModule_AddIntMacro(m, PyCF_TYPE_COMMENTS) < 0) {
        return -1;
    }
    if (PyModule_AddIntMacro(m, PyCF_OPTIMIZED_AST) < 0) {
        return -1;
    }
    static PyMethodDef repr_def = {"__repr__", ast_repr_generic, METH_NOARGS,
                                    NULL};
    PyObject *repr = PyDescr_NewMethod(&PyBaseObject_Type, &repr_def);
    if (repr == NULL) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_repr", repr) < 0) {
        Py_DECREF(repr);
        return -1;
    }
    Py_DECREF(repr);
    if (PyModule_AddObjectRef(m, "mod", state->mod_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_mod", state->_mod_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_mod_seq", state->_mod_seq_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Module", state->Module_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Module", state->_Module_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Interactive", state->Interactive_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Interactive", state->_Interactive_type) < 0)
        {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Expression", state->Expression_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Expression", state->_Expression_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "FunctionType", state->FunctionType_type) < 0)
        {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_FunctionType", state->_FunctionType_type) <
        0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "stmt", state->stmt_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_stmt", state->_stmt_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_stmt_seq", state->_stmt_seq_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "FunctionDef", state->FunctionDef_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_FunctionDef", state->_FunctionDef_type) < 0)
        {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "AsyncFunctionDef",
        state->AsyncFunctionDef_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_AsyncFunctionDef",
        state->_AsyncFunctionDef_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "ClassDef", state->ClassDef_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_ClassDef", state->_ClassDef_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Return", state->Return_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Return", state->_Return_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Delete", state->Delete_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Delete", state->_Delete_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Assign", state->Assign_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Assign", state->_Assign_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "TypeAlias", state->TypeAlias_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_TypeAlias", state->_TypeAlias_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "AugAssign", state->AugAssign_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_AugAssign", state->_AugAssign_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "AnnAssign", state->AnnAssign_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_AnnAssign", state->_AnnAssign_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "For", state->For_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_For", state->_For_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "AsyncFor", state->AsyncFor_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_AsyncFor", state->_AsyncFor_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "While", state->While_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_While", state->_While_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "If", state->If_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_If", state->_If_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "With", state->With_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_With", state->_With_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "AsyncWith", state->AsyncWith_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_AsyncWith", state->_AsyncWith_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Match", state->Match_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Match", state->_Match_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Raise", state->Raise_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Raise", state->_Raise_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Try", state->Try_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Try", state->_Try_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "TryStar", state->TryStar_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_TryStar", state->_TryStar_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Assert", state->Assert_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Assert", state->_Assert_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Import", state->Import_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Import", state->_Import_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "ImportFrom", state->ImportFrom_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_ImportFrom", state->_ImportFrom_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Global", state->Global_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Global", state->_Global_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Nonlocal", state->Nonlocal_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Nonlocal", state->_Nonlocal_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Expr", state->Expr_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Expr", state->_Expr_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Pass", state->Pass_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Pass", state->_Pass_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Break", state->Break_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Break", state->_Break_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Continue", state->Continue_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Continue", state->_Continue_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "expr", state->expr_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_expr", state->_expr_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_expr_seq", state->_expr_seq_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "BoolOp", state->BoolOp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_BoolOp", state->_BoolOp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "NamedExpr", state->NamedExpr_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_NamedExpr", state->_NamedExpr_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "BinOp", state->BinOp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_BinOp", state->_BinOp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "UnaryOp", state->UnaryOp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_UnaryOp", state->_UnaryOp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Lambda", state->Lambda_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Lambda", state->_Lambda_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "IfExp", state->IfExp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_IfExp", state->_IfExp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Dict", state->Dict_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Dict", state->_Dict_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Set", state->Set_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Set", state->_Set_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "ListComp", state->ListComp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_ListComp", state->_ListComp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "SetComp", state->SetComp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_SetComp", state->_SetComp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "DictComp", state->DictComp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_DictComp", state->_DictComp_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "GeneratorExp", state->GeneratorExp_type) < 0)
        {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_GeneratorExp", state->_GeneratorExp_type) <
        0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Await", state->Await_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Await", state->_Await_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Yield", state->Yield_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Yield", state->_Yield_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "YieldFrom", state->YieldFrom_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_YieldFrom", state->_YieldFrom_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Compare", state->Compare_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Compare", state->_Compare_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Call", state->Call_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Call", state->_Call_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "FormattedValue", state->FormattedValue_type)
        < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_FormattedValue",
        state->_FormattedValue_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Interpolation", state->Interpolation_type) <
        0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Interpolation", state->_Interpolation_type)
        < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "JoinedStr", state->JoinedStr_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_JoinedStr", state->_JoinedStr_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "TemplateStr", state->TemplateStr_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_TemplateStr", state->_TemplateStr_type) < 0)
        {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Constant", state->Constant_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Constant", state->_Constant_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Attribute", state->Attribute_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Attribute", state->_Attribute_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Subscript", state->Subscript_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Subscript", state->_Subscript_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Starred", state->Starred_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Starred", state->_Starred_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Name", state->Name_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Name", state->_Name_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "List", state->List_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_List", state->_List_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Tuple", state->Tuple_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Tuple", state->_Tuple_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Slice", state->Slice_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_Slice", state->_Slice_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "expr_context", state->expr_context_type) < 0)
        {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Load", state->Load_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Store", state->Store_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Del", state->Del_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "boolop", state->boolop_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "And", state->And_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Or", state->Or_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "operator", state->operator_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Add", state->Add_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Sub", state->Sub_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Mult", state->Mult_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "MatMult", state->MatMult_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Div", state->Div_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Mod", state->Mod_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Pow", state->Pow_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "LShift", state->LShift_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "RShift", state->RShift_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "BitOr", state->BitOr_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "BitXor", state->BitXor_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "BitAnd", state->BitAnd_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "FloorDiv", state->FloorDiv_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "unaryop", state->unaryop_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Invert", state->Invert_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Not", state->Not_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "UAdd", state->UAdd_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "USub", state->USub_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "cmpop", state->cmpop_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Eq", state->Eq_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "NotEq", state->NotEq_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Lt", state->Lt_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "LtE", state->LtE_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Gt", state->Gt_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "GtE", state->GtE_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "Is", state->Is_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "IsNot", state->IsNot_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "In", state->In_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "NotIn", state->NotIn_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "comprehension", state->comprehension_type) <
        0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_comprehension_seq",
        state->_comprehension_seq_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "excepthandler", state->excepthandler_type) <
        0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_excepthandler", state->_excepthandler_type)
        < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_excepthandler_seq",
        state->_excepthandler_seq_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "ExceptHandler", state->ExceptHandler_type) <
        0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_ExceptHandler", state->_ExceptHandler_type)
        < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "arguments", state->arguments_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_arguments_seq", state->_arguments_seq_type)
        < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "arg", state->arg_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_arg_seq", state->_arg_seq_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "keyword", state->keyword_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_keyword_seq", state->_keyword_seq_type) < 0)
        {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "alias", state->alias_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_alias_seq", state->_alias_seq_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "withitem", state->withitem_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_withitem_seq", state->_withitem_seq_type) <
        0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "match_case", state->match_case_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_match_case_seq",
        state->_match_case_seq_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "pattern", state->pattern_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_pattern", state->_pattern_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_pattern_seq", state->_pattern_seq_type) < 0)
        {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "MatchValue", state->MatchValue_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_MatchValue", state->_MatchValue_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "MatchSingleton", state->MatchSingleton_type)
        < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_MatchSingleton",
        state->_MatchSingleton_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "MatchSequence", state->MatchSequence_type) <
        0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_MatchSequence", state->_MatchSequence_type)
        < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "MatchMapping", state->MatchMapping_type) < 0)
        {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_MatchMapping", state->_MatchMapping_type) <
        0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "MatchClass", state->MatchClass_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_MatchClass", state->_MatchClass_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "MatchStar", state->MatchStar_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_MatchStar", state->_MatchStar_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "MatchAs", state->MatchAs_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_MatchAs", state->_MatchAs_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "MatchOr", state->MatchOr_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_MatchOr", state->_MatchOr_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "type_ignore", state->type_ignore_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_type_ignore", state->_type_ignore_type) < 0)
        {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_type_ignore_seq",
        state->_type_ignore_seq_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "TypeIgnore", state->TypeIgnore_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_TypeIgnore", state->_TypeIgnore_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "type_param", state->type_param_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_type_param", state->_type_param_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_type_param_seq",
        state->_type_param_seq_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "TypeVar", state->TypeVar_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_TypeVar", state->_TypeVar_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "ParamSpec", state->ParamSpec_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_ParamSpec", state->_ParamSpec_type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "TypeVarTuple", state->TypeVarTuple_type) < 0)
        {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "_TypeVarTuple", state->_TypeVarTuple_type) <
        0) {
        return -1;
    }
    return 0;
}

static PyModuleDef_Slot astmodule_slots[] = {
    {Py_mod_exec, astmodule_exec},
    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL}
};

static struct PyModuleDef _astmodule = {
    PyModuleDef_HEAD_INIT,
    .m_name = "_ast",
    // The _ast module uses a per-interpreter state (PyInterpreterState.ast)
    .m_size = 0,
    .m_slots = astmodule_slots,
};

PyMODINIT_FUNC
PyInit__ast(void)
{
    return PyModuleDef_Init(&_astmodule);
}


PyObject* PyAST_mod2obj(mod_ty t)
{
    struct ast_state *state = get_ast_state();
    if (state == NULL) {
        return NULL;
    }
    PyObject *result = ast2obj_mod(state, t);

    return result;
}

/* mode is 0 for "exec", 1 for "eval" and 2 for "single" input */
int PyAst_CheckMode(PyObject *ast, int mode)
{
    const char * const req_name[] = {"Module", "Expression", "Interactive"};

    struct ast_state *state = get_ast_state();
    if (state == NULL) {
        return -1;
    }

    PyObject *req_type[3];
    req_type[0] = state->Module_type;
    req_type[1] = state->Expression_type;
    req_type[2] = state->Interactive_type;

    assert(0 <= mode && mode <= 2);
    int isinstance = PyObject_IsInstance(ast, req_type[mode]);
    if (isinstance == -1) {
        return -1;
    }
    if (!isinstance) {
        PyErr_Format(PyExc_TypeError, "expected %s node, got %.400s",
                     req_name[mode], _PyType_Name(Py_TYPE(ast)));
        return -1;
    }
    return 0;
}

mod_ty PyAST_obj2mod(PyObject* ast, PyArena* arena, int mode)
{
    if (PySys_Audit("compile", "OO", ast, Py_None) < 0) {
        return NULL;
    }

    struct ast_state *state = get_ast_state();
    if (state == NULL) {
        return NULL;
    }

    if (PyAst_CheckMode(ast, mode) < 0) {
        return NULL;
    }

    mod_ty res = NULL;
    if (obj2ast_mod(state, ast, &res, arena) != 0)
        return NULL;
    else
        return res;
}

int PyAST_Check(PyObject* obj)
{
    struct ast_state *state = get_ast_state();
    if (state == NULL) {
        return -1;
    }
    return PyObject_IsInstance(obj, state->AST_type);
}


